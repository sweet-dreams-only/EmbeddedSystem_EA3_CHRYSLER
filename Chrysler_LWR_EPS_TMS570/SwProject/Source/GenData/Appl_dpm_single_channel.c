/* -----------------------------------------------------------------------------
  Filename:    Appl_dpm_single_channel_TEMPLATE.c
  Description: Toolversion: 01.00.35.01.21.00.21.01.00.00
               
               Serial Number: CBD1210021
               Customer Info: Nxtr
                              Package: CBD_Chrysler_SLP1_UDS_Sgl
                              Micro: TexasInstruments TMS570 - TMX570LS0805APGEQQ1
                              Compiler: Texas Instruments 4.9.5
               
               
               Generator Fwk   : GENy 
               Generator Module: DPM
               
               Configuration   : C:\Synergy\Chrysler_LWR_EPS_TMS570-zz4r1x\Chrysler_LWR_EPS_TMS570\Tools\AsrProject\GENy\Chrsyler_SLP1_EPS.gny
               
               ECU: 
                       TargetSystem: Hw_Tms470/570Cpu (Dcan)
                       Compiler:     TexasInstruments
                       Derivates:    TMS570PSFC66
               
               Channel "Channel0":
                       Databasefile: C:\Synergy\Chrysler_LWR_EPS_TMS570-zz4r1x\Chrysler_LWR_EPS_TMS570\Tools\AsrProject\GENy\CAN C v1232 EPS.dbc
                       Bussystem:    CAN
                       Manufacturer: DaimlerChrysler
                       Node:         EPS

  Generated by , 2012-12-12  11:24:17
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2011 by Vctr Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vctr Informatik 
  GmbH.
  
  Vctr Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

#include "v_inc.h"
#include "ccl_inc.h"
#include "Rte_Type.h"			/*Include for DiagMgr*/
#include "DiagMgr_Cfg.h"
#include "Ap_DfltConfigData.h"

/* This variables should be located in non volatile memory on a real ECU. */

V_MEMRAM0 V_MEMRAM1 vuint8 V_MEMRAM2 gVariantAndRestriction = 0xc2; /* initial value is external mode and  variant bit is set */

V_MEMRAM0 V_MEMRAM1 vuint16 V_MEMRAM2 gDpmSleepForceCounter  = 0x00;
V_MEMRAM0 V_MEMRAM1 vuint16 V_MEMRAM2 gCounterNoExternalMode = 0x00;
/******************************************************************************
Name          : ApplDpmReadMaxChMode 
Called by     : DpmInitPowerOn 
Preconditions : value for DpmMaxChMode must be available 
Parameters    : none 
Returnvalue   : DpmMaxChMode out of non volatile memory 
Description   : During PowerOn initialization the dpm needs  
******************************************************************************/ 
t_DpmMaxChModeVariantCode DPM_API_CALLBACK_TYPE ApplDpmReadMaxChMode(void)
{
  return ((t_DpmMaxChModeVariantCode)gVariantAndRestriction); /* no restricion*/
}
/******************************************************************************
Name          : ApplDpmSaveMaxChMode
Called by     : DpmTask
Preconditions : Dpm must be initialized
Parameters    : bit coded maximum channel activity mode
Returnvalue   : none
Description   : DPM hands maximum channel activity mode to the application. The
                application has to save this information into non volatile memory 
******************************************************************************/
void DPM_API_CALLBACK_TYPE ApplDpmSaveMaxChMode(t_DpmMaxChMode DpmMaxChMode)
{
  gVariantAndRestriction &= 0xC0;         /* mask out the two variant bits and delete all other bits */
  gVariantAndRestriction |= DpmMaxChMode; /* load the new maximum activity mode */
}
/******************************************************************************
Name          : ApplDpmModeChangeSystem
Called by     : DpmTask, out of wake up interrupt
Preconditions : none
Parameters    : target: target mode of transition
                active: current activ mode 
Returnvalue   : DPM_ACTION_COMPLETED      from application point of view the transition can be performed
                DPM_ANOTHER_CALL_REQUIRED the application needs time to prepare the ECU for new target mode
Description   : this function notifies the application when a transition to a new mode is required. With 
                the return value of this function the application has the possibility to delay the transition
                if the ECU is not ready for the new mode.
******************************************************************************/
t_DpmApplRet DPM_API_CALLBACK_TYPE ApplDpmModeChangeSystem(t_DpmState target, t_DpmState active)
{
	  switch(active)
	  {
	    case Sleep_PowerDown:
	    {
	      if(target == Local_EmcDetection)
	      {
	        /* this transition is called out of interrupt context !!!*/
			DPMShutDownState_Cnt_lgc = FALSE;
	      }
	      else
	      {
	        if(target == Local_BusLocal)
	        {DPMShutDownState_Cnt_lgc = FALSE;}
	        else
	        {
	          /* undefined transition */
			  DPMShutDownState_Cnt_lgc = TRUE;
	        }
	      }
	    }
	    break;
	    case Local_PrepareSleep:
	      if(target == Local_EmcDetection)
	      {
	        /* this transition is called out of interrupt context !!!*/
			DPMShutDownState_Cnt_lgc = FALSE;
	      }
	      else if(target == Local_BusLocal)
	        {DPMShutDownState_Cnt_lgc = FALSE;}
	      else if(target == Sleep_PowerDown)
	        {DPMShutDownState_Cnt_lgc = TRUE;}
	      else
	        {
	          /* undefined transition */
	        }
	    break;
	    case Local_BusLocal:
	      if(target == External_StartUpDelay)
	      {DPMShutDownState_Cnt_lgc = FALSE;}
	      else if(target == Local_EmcDetection)
	      {
	        /* this transition is called out of interrupt context !!!*/
			DPMShutDownState_Cnt_lgc = FALSE;
	      }
	      else if(target == Local_PrepareSleep)
	      {DPMShutDownState_Cnt_lgc = TRUE;}
	      else
	      {
	        /* undefined transition */
	      }
	    break;
	    case Local_EmcDetection:
	      if(target == External_StartUpDelay)
	      {DPMShutDownState_Cnt_lgc = FALSE;}
	      else if(target == Local_BusLocal)
	      {DPMShutDownState_Cnt_lgc = FALSE;}
	      else if(target == Local_PrepareSleep)
	      {DPMShutDownState_Cnt_lgc = TRUE;}
	      else
	      {
	        /* undefined transition */
	      }
	    break;
	    case External_WaitBusSleep:
	      if(target == External_StartUpDelay)
	      {DPMShutDownState_Cnt_lgc = FALSE;}
	      else
	      {
	        if(target == Local_EmcDetection)
	        {
	          /* this transition is called out of interrupt context !!!*/
			  DPMShutDownState_Cnt_lgc = FALSE;
	        }
	        else
	        {
	          if(target == Local_BusLocal)
	          {DPMShutDownState_Cnt_lgc = TRUE;}
	          else
	          {
	            /* undefined transition */
	          }
	        }
	      }
	    break;
	    case External_BusActive:
	    	DPMShutDownState_Cnt_lgc = FALSE;
	      if(target == External_WaitBusSleep)
	      {DPMShutDownState_Cnt_lgc = FALSE;}
	      else
	      {
	        if(target == External_StartUpDelay)
	        {DPMShutDownState_Cnt_lgc = FALSE;}
	        else
	        {
	          /* undefined transition */
	        }
	      }
	    break;
	    case External_StartUpDelay:
	    {
	    	DPMShutDownState_Cnt_lgc = FALSE;
	      if(target == External_BusActive)
	      {DPMShutDownState_Cnt_lgc = FALSE;}
	      else
	      {
	        if(target == External_WaitBusSleep)
	        {DPMShutDownState_Cnt_lgc = FALSE;}
	        else
	        {
	          /* undefined transition */
	        }
	      }
	    }
	    break;
	    default:
	    	DPMShutDownState_Cnt_lgc = FALSE;
	      /* undefined transition */
	    break;
	  }
	  return ((t_DpmApplRet)DPM_ACTION_COMPLETED);
}

/******************************************************************************
Name          : ApplDpmReadCounterSleepForced
Called by     : DPM
Preconditions : 
Parameters    : 
Returnvalue   : Value of sleep force counter
Description   : Hands the value of sleep forced counter out of non volatile
                memory to DPM.
******************************************************************************/
vuint16 DPM_API_CALLBACK_TYPE ApplDpmReadCounterSleepForced(void)
{
  return gDpmSleepForceCounter;
}
/******************************************************************************
Name          : ApplDpmReadCounterNoExternalMode
Called by     : DPM
Preconditions : 
Parameters    : 
Returnvalue   : Value of no external mode counter
Description   : Hands the value of no external mode counter out of non volatile
                memory to DPM 
******************************************************************************/
vuint16 DPM_API_CALLBACK_TYPE ApplDpmReadCounterNoExternalMode(void)
{
  return gCounterNoExternalMode;
}
/******************************************************************************
Name          : ApplDpmSaveCounterValues
Called by     : DPM
Preconditions : 
Parameters    : DpmDebugCounterValueNoExternalMode
                DpmDebugCounterValuesSleepForced
Returnvalue   : 
Description   : With this function the DPM hands the values of both restricton
                counters to the application.
******************************************************************************/
void DPM_API_CALLBACK_TYPE ApplDpmSaveCounterValues(vuint16 DpmDebugCounterValueNoExternalMode, vuint16 DpmDebugCounterValuesSleepForced)
{
  gDpmSleepForceCounter  = DpmDebugCounterValuesSleepForced;
  gCounterNoExternalMode = DpmDebugCounterValueNoExternalMode;
}
/******************************************************************************
Name          : ApplDpmSystemShutdown
Called by     : DPM or Application depends on configuration
Preconditions : 
Parameters    : 
Returnvalue   : 
Description   : Within this function the application hast to set the CPU into 
                stop / low power mode.
******************************************************************************/
void DPM_API_CALLBACK_TYPE ApplDpmSystemShutdown(void)
{
  /* this function is called with disabled global interrupts after return of
     this function the DPM will restore the old interrupt context */
}
/******************************************************************************
Name          : ApplCclCanStandby
Called by     : CCL Task
Preconditions : 
Parameters    : 
Returnvalue   : 
Description   : the application has to handle the error case if the CAN cell does
                not enter sleep mode after call of CanSleep.
******************************************************************************/
vuint8 CCL_API_CALLBACK_TYPE ApplCclCanStandby(CCL_CHANNEL_CCLTYPE_FIRST vuint8 SleepState)
{
  vuint8 rc;
  if(SleepState == kCanFailed)
  {
    /* CanSleep retruns kCanFail: CAN cell does not enter sleep mode */
    /* Attention: endless loop 
       The appliction has to decide how much */
    rc = kCclRepeatCanSleep;
  }
  else
  {
    rc = kCclNoRepeatCanSleep;
  }

  return (rc);
}
/******************************************************************************
Name          : ApplDpmFatalError
Called by     : dpm
Preconditions : debug mode must be enabled
Parameters    : error code number
Returnvalue   : none
Description   : all assertions out of DPM leads to this function
******************************************************************************/
void DPM_API_CALLBACK_TYPE ApplDpmFatalError(vuint8 DpmErrorCode)
{
  DpmErrorCode = DpmErrorCode;  /* to prevent compiler warnings */
}
/******************************************************************************
Name          : ApplCclBusOffStart
Called by     : CCL
Preconditions : 
Parameters    : 
Returnvalue   : 
Description   : Bus off notification out of ApplNmBusOff
******************************************************************************/
void CCL_API_CALLBACK_TYPE ApplCclBusOffStart( CCL_CHANNEL_CCLTYPE_ONLY )
{
	NxtrDiagMgr9_SetNTCStatus(NTC_Num_BusOffCh1, 0x01, NTC_STATUS_FAILED);
}
/******************************************************************************
Name          : ApplCclBusOffEnd
Called by     : CCL
Preconditions : 
Parameters    : 
Returnvalue   : 
Description   : Bus off notification out of ApplNmBusOffEnd
******************************************************************************/
void CCL_API_CALLBACK_TYPE ApplCclBusOffEnd( CCL_CHANNEL_CCLTYPE_ONLY )
{
	NxtrDiagMgr9_SetNTCStatus(NTC_Num_BusOffCh1, 0x01, NTC_STATUS_PASSED);
}
/******************************************************************************
Name          : ApplCclInit
Called by     : CCL
Preconditions : 
Parameters    : 
Returnvalue   : 
Description   : Init notification out of CclInit.
                The application has to implement the init of the CANbedded 
                components depending on CAN channels.
******************************************************************************/
void CCL_API_CALLBACK_TYPE ApplCclInit( CCL_CHANNEL_CCLTYPE_ONLY )
{
}

void ApplCclInitTrcv()
{
}

void ApplCclStandbyTrcv()
{
}

void ApplCclWakeUpTrcv()
{
}

/* begin Fileversion check */
#ifndef SKIP_MAGIC_NUMBER
#ifdef MAGIC_NUMBER
  #if MAGIC_NUMBER != 103168731
      #error "The magic number of the generated file <C:\Synergy\Chrysler_LWR_EPS_TMS570-zz4r1x\Chrysler_LWR_EPS_TMS570\SwProject\Source\_GenData\Appl_dpm_single_channel.c> is different. Please check time and date of generated files!"
  #endif
#else
  #error "The magic number is not defined in the generated file <C:\Synergy\Chrysler_LWR_EPS_TMS570-zz4r1x\Chrysler_LWR_EPS_TMS570\SwProject\Source\_GenData\Appl_dpm_single_channel.c> "

#endif  /* MAGIC_NUMBER */
#endif  /* SKIP_MAGIC_NUMBER */

/* end Fileversion check */

