/* -----------------------------------------------------------------------------
  Filename:     frfm.c
  Description:  Toolversion: 01.00.35.01.21.00.21.01.00.00
                
                Serial Number: CBD1210021
                Customer Info: Nxtr
                               Package: CBD_Chrysler_SLP1_UDS_Sgl
                               Micro: TexasInstruments TMS570 - TMX570LS0805APGEQQ1
                               Compiler: Texas Instruments 4.9.5
                Manufacturer : Chrysler (Car)
                
                Configuration: C:\cmsynergy\My_CL\Chrysler_LWR_EPS_TMS570\Tools\AsrProject\GENy\EPS_PN_4102_EI1555.cdi
                
                
                Implementation of DiagFrfm.

  Generated by  DtcGen v3.20.1 (2012-08-17)  at:  2014-02-06 21:12:42 -05:00
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2004-2012 by Vctr Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vctr Informatik 
  GmbH.
  
  Vctr Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* standard vector types */
#include "can_inc.h"

/* -- NULL Definition -- */
#if !defined (V_NULL)
# define V_NULL                                                         0
#endif

/* include diagnostics header for version check */
#if defined (VGEN_ENABLE_DIAG_CANDESC_BASIC_UDS)
# include "desc.h"
#endif

#include "frfm.h"
#include "applfrfm.h"


#include "dbk_par.h"

#include "RTE_GlobalData.h"
/* -----------------------------------------------------------------------------
    &&&~ Preprocessor constants (defines)
 ----------------------------------------------------------------------------- */

/* This magic number provides inter Frfm generation process consistency check.All Frfm files must have the same one. */
#define FRFM_IMPLEMENTATION_MAGIC_NUMBER                               31611
/* Generation consistency check */
#if (FRFM_DECL_INTERFACE_MAGIC_NUMBER != FRFM_IMPLEMENTATION_MAGIC_NUMBER)
# error "frfm.h doesn't match the frfm.c generation time!"
#endif

#if (FRFM_APPL_INTERFACE_MAGIC_NUMBER != FRFM_IMPLEMENTATION_MAGIC_NUMBER)
# error "applfrfm.h doesn't match the frfm.c generation time!"
#endif

#if defined (FRFM_ENABLE_MON_NVRAM_CORRUPT)
# if ! defined (FRFM_ENABLE_CONSISTENCY_CHECK)
#  error "NVRAM checksum monitoring needs the activated GENy feature 'Use checksum for NVRAM'"
# endif
# if ! defined (FRFM_ENABLE_PATTERN_CHECK)
#  error "NVRAM checksum monitoring needs the activated GENy feature 'Use pattern to recognize uninitialized NVRAM'"
# endif
#endif

/* Support of UDS Diagn. Service 19 0a needs CANdescBasic v3.00.34 (or later) */
#if defined (FRFM_ENABLE_REPORT_ALLSUPPORTED) && defined (VGEN_ENABLE_DIAG_CANDESC_BASIC_UDS)
# if (DIAG_CANDESC__CORE_VERSION < 0x0300) || ((DIAG_CANDESC__CORE_VERSION == 0x0300) && (DIAG_CANDESC__CORE_RELEASE_VERSION < 0x34))
#  error "The support of UDS diagn. service 'ReadSupportedDtcs' requires CANdesc(Basic) version 3.00.34 or later"
# endif
#endif


#define kFrfmRoelOk                                                     0x00
#define kFrfmRoelFifoFull                                               0x01
#define kFrfmRoelFifoEmpty                                              kFrfmRoelFifoFull
#define kFrfmRoelElmExists                                              0x02

#if defined (VGEN_GENY)
  #define FRFM_ROEL_SEND_BUFFER(x) (x)
#elif defined (VGEN_DBKGEN_VERSION)
  #define FRFM_ROEL_SEND_BUFFER(x) (x).c
#endif


/* ResponseOnEventLight Number of FIFO elements. */
#define kFrfmRoelNumFifoElmts                                          4
/* ResponseOnEventLight cycle time (in ms). */
#define kFrfmRoelCycleTime                                             0
/* fault detection counter jump-to-zero when maturing */
#define FRFM_ENABLE_DTC_MATUR_JUMPZERO
/* fault detection counter jump-to-zero when de-maturing */
#define FRFM_ENABLE_DTC_DEMAT_JUMPZERO


/* count of elements (SFNs) in the mutual exclusion matrix */
#define kFrfmNumDtcMutualExclusionEntry                                0
/* Total number of different DTC properties found in the database. */
#define kFrfmNumDtcProperties                                          7

/* Limit for EnableCondition 5: IOD-Fuse Status (in km) */
#define kFrfmOdometerLimitIodFuse                                      80
/* Value for signalling invalid voltage */
#define kFrfmVoltageInvalid                                            ((t_FrfmVoltage)0xffff)




/* -----------------------------------------------------------------------------
    &&&~ Datatype definitions
 ----------------------------------------------------------------------------- */

/* Filter for external Requests */
typedef union
{
  struct {
    vuint8           matchingSfn[((kFrfmNumDtc-1)/8)+1];              /* DTCs ordered by sfn */
    t_FrfmDtcSfnType matchingSfnCount;                                /* "1"-bit count in matchingSfn[] */
    t_FrfmDtcSfnType listOfIdentified[kFrfmChronoStackSize];          /* keep CS sequence */
  } cs;              /* chrono stack (plus DTCs w/ solely status information) */
#if defined (FRFM_ENABLE_DTC_DEBOUNCING) || defined (FRFM_ENABLE_REPORT_ALLSUPPORTED)
  struct {
    vuint8           matchingSfn[((kFrfmNumDtc-1)/8)+1];              /* DTCs ordered by sfn */
    t_FrfmDtcSfnType matchingSfnCount;                                /* "1"-bit count in matchingSfn[] */
  } sfn;             /* for matching fault detection counters */
#endif
} t_frfmFilter;

typedef enum
{
  kFrfmCSListOfIdentified = 0   /* using: g_frfmFilter.cs.listOfIdentified[] + ..matchingSfn[]   */
 /* ,unused1 = 1 */
 ,kFrfmSfnIdentified      = 2   /* using: g_frfmFilter.sfn.matchingSfn[]                         */
 ,kFrfmSfnSupported       = 3   /* using: g_frfmFilter.sfn.matchingSfn[]                         */
} t_frfmFilterType;


typedef unsigned int frfmuint;
typedef   signed int frfmsint;

/* Initialization status of the FRFM */
typedef enum
{
  storageInitialized        = 0,
  storageUninitialized      = 1
} t_FrfmInitializationState;


/* FIFO element for Response on Event (light) */
typedef struct
{
  t_FrfmDtcSfnType roelDtcSfn;
} t_FrfmRoelErrFifo;


typedef union t_FrfmRoelMessageBufferTag
{
  vuint8 cSD_RS_EPS[8];
  vuint8 c[8];
} t_FrfmRoelMessageBuffer;
typedef t_FrfmDtcSfnType t_frfmMutualExclusionMatrix[1];
typedef vuint8 t_FrfmNumDtcProperties; /* DTC properties number type is dependent on pre-calculated different DTC properties. */
/* This structure defines the DTC properties for the current database. */
typedef struct t_FrfmDtcInfoTag
{
  vuint8 dtcPriorityValue;
  vuint8 dtcSelfHealingCounter;
  vuint8 envDataRecordNumber_mostRecent;
  vuint8 envDataRecordSize_mostRecent;
  vuint8 dtcMaturationStepSize;
  vuint8 dtcDematurationStepSize;
  t_FrfmDtcMutualExclusionRef mutualDtcListIndex;
  t_FrfmMutualListLength mutualDtcListLength;
  vbittype dtcOccurenceFlag : 1;
  vbittype dtcWarningIndFlag : 1;
  vbittype dtcSuppressFlag : 1;
  vbittype dtcEnableConditionGroup : 3;
} t_FrfmDtcInfo;
/* Lock for chrono or historical stack during external read access */
typedef enum
{
  frfmLL_None               = 0,  /*nothing locked*/
  frfmLL_StatusStack        = 1,  /*prevent status modification*/
  frfmLL_ChronoStack        = 2   /*prevent chrono stack modification*/
  /* ,unused3 = 3 */
} t_FrfmLockLocation;

typedef struct t_FrfmLockTag {
  t_FrfmLockLocation      location;
  t_FrfmDtcSfnType        dtcSfn;
} t_FrfmLockType;




/* -----------------------------------------------------------------------------
    &&&~ Function prototypes
 ----------------------------------------------------------------------------- */

static t_FrfmDtcChronoRefType FrfmGetChronoStackMgrIndex(t_FrfmDtcSfnType dtcSfn);
static t_FrfmChronoStack*     FrfmGetChronoStackPtr(t_FrfmDtcSfnType dtcSfn);
static t_FrfmDtcSfnType       FrfmGetSfn(const t_FrfmDtcNumType dtcNum);


static t_FrfmDtcSfnType       FrfmFindSetBitInArrayAndReset(vuint8 *array, t_FrfmDtcSfnType const sizeInBit);


static t_FrfmDtcStatusByte    FrfmNarrowDownSupportedStatus(t_FrfmDtcStatusByte status);
static t_FrfmReturnCode       FrfmNsGetExtDataRecordByDTC(vuint8 **sourceBuffer, vuint16 *bufferSize);
static t_FrfmReturnCode       FrfmCsGetExtDataRecordByDTC(vuint8 **sourceBuffer, vuint16 *bufferSize);


static void                   FrfmClearChronoStack(t_FrfmBool notifyApplication);
static void                   FrfmReinitPowerCycle(void);
static void                   FrfmUnpackStatusByte(void);
static void                   FrfmPackStatusByte(void);
static vbittype               FrfmGetPackedStatusBit(frfmuint currentBitCount);
static void                   FrfmSetPackedStatusBit(frfmuint currentBitCount, vbittype statusBit);
#if defined (FRFM_ENABLE_CONSISTENCY_CHECK)
static t_FrfmBool             FrfmCalculateChecksum(vuint8 const * const dataPtr, frfmuint const dataSize, t_checksum const oldChecksum, t_checksum * newChecksum);
#endif


static void                   FrfmRoelNotifyStatusChange(t_FrfmDtcSfnType dtcSfn, t_FrfmDtcStatusByte oldStatus, t_FrfmDtcStatusByte newStatus);
static void                   FrfmRoelInitErrFifo(void);                                          /* initialize FIFO   */
static vuint8                 FrfmRoelWriteErrFifo(t_FrfmRoelErrFifo const * const pRoelErrFifo); /* write into FIFO   */
static vuint8                 FrfmRoelReadErrFifo(t_FrfmRoelErrFifo *pRoelErrFifo);               /* read out of FIFO  */
static void                   FrfmRoelSendErrFifo(void);                                          /* send FIFO entries */


static void                   FrfmInternalEventDebounce(const t_FrfmDtcSfnType dtcSfn, t_FrfmSetEventStatus *eventStatus);


static t_FrfmBool             FrfmIsDtcBlockedByMutExclMatrix(t_FrfmDtcSfnType dtcSfn);



static void                   FrfmInternalSetEventStatus(t_FrfmDtcSfnType dtcSfn, t_FrfmSetEventStatus eventStatus);
static void                   FrfmAddNewDTCtoChronoStack(t_FrfmDtcSfnType dtcSfn);
static void                   FrfmUpdateDTCinCS_NotActiveToActive(t_FrfmDtcSfnType dtcSfn);
static void                   FrfmUpdateDTCinCS_ActiveToNotActive(t_FrfmDtcSfnType dtcSfn);
static void                   FrfmUpdateDTCinCS_ActiveToActive(t_FrfmDtcSfnType dtcSfn);
static void                   FrfmDeleteDTCinChronoStack(t_FrfmDtcChronoRefType chronoStackManagerIndex, t_FrfmBool triggerRoe);
static void                   FrfmEvalNWCommDebounceTimer(void);
static void                   FrfmEvalPowerDistrDebounceTimer(void);
static t_FrfmBool             FrfmCheckOfEnableCond(t_FrfmDtcSfnType dtcSfn);
static t_FrfmBool             FrfmCheckOfStorageEnableCond(void);               /* EC 1 */
static t_FrfmBool             FrfmCheckOfIgnitionEnableCond(void);              /* EC 2 */
static t_FrfmBool             FrfmCheckOfLocVoltageEnableCond(void);            /* EC 3 */
static t_FrfmBool             FrfmCheckOfSysVoltageEnableCond(void);            /* EC 4 */
static t_FrfmBool             FrfmCheckOfIodFuseEnableCond(void);               /* EC 5 */
static t_FrfmBool             FrfmCheckOfNwConfigEnableCond(void);              /* EC 6 */
static t_FrfmBool             FrfmCheckOfBusPhysicEnableCond(void);             /* EC 7 */
static t_FrfmBool             FrfmCheckOfIODevConfEnableCond(void);             /* EC 8 */
static t_FrfmBool             FrfmCheckOfNWDebounceEnableCond(void);            /* EC 9-NW Debounce */
static t_FrfmBool             FrfmCheckOfPDDebounceEnableCond(void);            /* EC 9-PD Debounce */
static t_FrfmBool             FrfmCheckECGroupEcuLevel(void);                   /* Group #0     EC 1,3,8 */
static t_FrfmBool             FrfmCheckECGroupNwCommunication(void);            /* Group #1'    EC 1,2,4,5,6,7 (i.e. without EC 9-NW debounce) */
static t_FrfmBool             FrfmCheckECGroupPowerDistrib(void);               /* Group #2'    EC 1,2 (i.e. without EC 9-PD debounce) */
static t_FrfmBool             FrfmCheckECGroupNone(void);                       /* Group #6     EC 1 */

static vuint8                 FrfmGetStatusByte(t_FrfmDtcSfnType dtcSfn);




/* -----------------------------------------------------------------------------
    &&&~ Global variable declarations
 ----------------------------------------------------------------------------- */

/* Buffer for NVRAM data (RAM mirror) */
t_FrfmNonVolatileData g_frfmNVData;




/* -----------------------------------------------------------------------------
    &&&~ RAM definitions
 ----------------------------------------------------------------------------- */

static t_frfmFilterType g_frfmFilterType;
static t_FrfmLockType   g_frfmLock;
static t_FrfmDtcSfnType g_frfmIdxOfFilteredDtc;
static t_frfmFilter     g_frfmFilter;
static vuint8           g_frfmCurrentExtendedRecord;


#if (kFrfmNumConfigs > 1)
/* Multiple Configuration */
static t_FrfmNumConfigs g_frfmCurrConfig;
#else
# define g_frfmCurrConfig                                              ((t_FrfmNumConfigs)0)
#endif

static vuint16 g_frfmTimerIgnitionTimer;
static t_FrfmInitializationState  g_frfmInitializationStatus;
static t_FrfmDtcStatusByte        g_frfmDtcStatusByte[kFrfmNumDtc];


/* FIFO-Control */
static vuint8 g_frfmRoelErrFifoRdToken;  /* read pointer */
static vuint8 g_frfmRoelErrFifoWrToken;  /* write pointer */
static vuint8 g_frfmRoelErrFifoElmCount; /* element count */

/* FIFO-Definition */
static t_FrfmRoelErrFifo g_frfmRoelErrFifo[kFrfmRoelNumFifoElmts];

static vsint16 g_frfmRoelCycleCount; /* cycle counter */


/* De-bouncing of DTCs */
static volatile vsint8        g_frfmFaultDetectionCounter[kFrfmNumDtc];


/* Store last measured/received valid voltages */
static t_FrfmVoltage       g_frfmLocalVoltage;                /* last known valid value measured during current power cycle (used by monitors) */
static t_FrfmVoltage       g_frfmSystemVoltage;               /* last known valid value received during current power cycle (used by monitors) */

/* Store EnableCondition state and corresponding data */
static t_FrfmStorageState  g_frfmControlDTCstatus;            /* EC 1: DTC Setting */
static t_FrfmIgnitionState g_frfmIgnitionStatus;              /* EC 2: Ignition Status */
static t_FrfmVoltage       g_frfmLocalVoltageForEC;           /* EC 3: Local Voltage (for EnableCondition: measured or substituted from SysVoltg) */
static t_FrfmVoltage       g_frfmSystemVoltageForEC;          /* EC 4: System Voltage (for EnableCondition: received or substituted from LocVoltg) */
static vuint8              g_frfmECx;                         /* EC 5..8 Conditions: TRUE := 1, FALSE := 0 */
                                                              /*  0x01  EC 5: IOD-Fuse Status */
                                                              /*  0x04  EC 6: Network Configuration Status */
                                                              /*  0x08  EC 7: Bus Physical Status */
                                                              /*  0x10  EC 8: I/O Device Configuration Status */

/* EnableCondition de-bounce timer:
 *  0: Timer stopped, storage disabled
 *  1: Timer elapsed (stopped), storage enabled
 * >1: Timer running, storage disabled */
static vuint16             g_frfmTimerDeBounceECNwComm;       /* EC 9-Network Communication */
static vuint16             g_frfmTimerDeBounceECPowerDistr;   /* EC 9-PowerDistribution */

static t_FrfmIgnitionState g_frfmIgnitionStatusLocal;         /* local measured ignition status */

/* synchronization of NVRAM mirror */
static volatile t_FrfmBool g_frfmNvramMirrorSyncDone;         /* synchronization finished */
static volatile t_FrfmBool g_frfmNvramMirrorIsDirty;          /* nvram mirror is modified */

#if defined (FRFM_ENABLE_REENTRANCY)
static volatile frfmuint g_frfmChronoStackConsistency;
#endif

/* Suppress DTC specific the trigger of RoE/DM1 message */
#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER) && !defined (FRFM_ENABLE_NVRAM_CHG_TRIGGER)
static t_FrfmSuppressTriggerStatusChg g_frfmSuppressTrOnEvFlag;
#endif




/* -----------------------------------------------------------------------------
    &&&~ ROM definitions
 ----------------------------------------------------------------------------- */


/* ROM variables for component version (coded as BCD). */
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 kFrfmMainVersion = (vuint8)0x03;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 kFrfmSubVersion = (vuint8)0x20;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 kFrfmReleaseVersion = (vuint8)0x01;
#if defined (FRFM_ENABLE_PATTERN_CHECK)
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 originalCSPattern[kFrfmPatternSize] = {0x9A, 0xBD, 0xA0, 0xF3};
#endif /*FRFM_ENABLE_PATTERN_CHECK*/


/* Mutual exclusion table */
V_MEMROM0 static V_MEMROM1 t_frfmMutualExclusionMatrix V_MEMROM2 g_frfmMutualExclusionMatrix = 
{
  0
};
/* DTC format for each configuration. 0: Iso15031-6, 1: Iso14229-1, 2: SaeJ1939-73, 3: Iso11992-4 */
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_frfmDTCFormat[kFrfmNumConfigs] = 
{
   1 /* EPS_PN_4102_EI1555 */
};
/* SFN to DTC number map. */
V_MEMROM0 static V_MEMROM1 t_FrfmDtcNumType V_MEMROM2 g_frfmDtcNumTable[kFrfmNumDtc] = 
{
  0x000000, 0x55C100, 0x55DB00, 0x612800, 0x612916, 0x612917, 0x612A84, 0x612A85, 0x620600, 0x621000, 0x621700, 0x621900, 0xC00200, 0xC10000, 0xC10100, 0xC12100, 
  0xC14000, 0xC15500, 0xC15900, 0xC21200, 0xC40100, 0xC40200, 0xC41500, 0xC42200, 0xC42300, 0xC45A00, 0xD21500, 0xD41500, 0xD44700, 0xD48D00, 0xD60100
};
/* DTC properties table. */
V_MEMROM0 static V_MEMROM1 t_FrfmDtcInfo V_MEMROM2 g_frfmDtcInfoTable[kFrfmNumDtcProperties] = 
{
  { 0x02, 0x64, 0x02, 0x11, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } /* 0x000000 (0), 0x55c100 (0), 0x621000 (0), 0x621700 (0), 0x621900 (0), 0xc00200 (0), 0xd60100 (0) */, 
  { 0x02, 0x64, 0x02, 0x11, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06 } /* 0x55db00 (0) */, 
  { 0x02, 0x64, 0x02, 0x11, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } /* 0x612800 (0), 0xc40100 (0), 0xd41500 (0) */, 
  { 0x02, 0x64, 0x02, 0x11, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02 } /* 0x612916 (0), 0x612917 (0) */, 
  { 0x02, 0x64, 0x02, 0x11, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 } /* 0x612a84 (0), 0x612a85 (0) */, 
  { 0x02, 0x64, 0x02, 0x11, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 } /* 0x620600 (0), 0xc10000 (0), 0xc10100 (0), 0xc12100 (0), 0xc14000 (0), 0xc15500 (0), 0xc15900 (0), 0xc21200 (0), 0xc40200 (0), 0xc41500 (0), 0xc42200 (0), 0xc45a00 (0), 0xd21500 (0), 0xd44700 (0), 0xd48d00 (0) */, 
  { 0x02, 0x64, 0x02, 0x11, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01 } /* 0xc42300 (0) */
};
/* Mappings of sfn to DTC property (in g_frfmDtcInfoTable). */
V_MEMROM0 static V_MEMROM1 t_FrfmNumDtcProperties V_MEMROM2 g_frfmDtcInfoIdx[kFrfmNumConfigs][kFrfmNumDtc] = 
{
  
  {
      0 /* 0x000000 */,   0 /* 0x55c100 */,   1 /* 0x55db00 */,   2 /* 0x612800 */, 
      3 /* 0x612916 */,   3 /* 0x612917 */,   4 /* 0x612a84 */,   4 /* 0x612a85 */, 
      5 /* 0x620600 */,   0 /* 0x621000 */,   0 /* 0x621700 */,   0 /* 0x621900 */, 
      0 /* 0xc00200 */,   5 /* 0xc10000 */,   5 /* 0xc10100 */,   5 /* 0xc12100 */, 
      5 /* 0xc14000 */,   5 /* 0xc15500 */,   5 /* 0xc15900 */,   5 /* 0xc21200 */, 
      2 /* 0xc40100 */,   5 /* 0xc40200 */,   5 /* 0xc41500 */,   5 /* 0xc42200 */, 
      6 /* 0xc42300 */,   5 /* 0xc45a00 */,   5 /* 0xd21500 */,   2 /* 0xd41500 */, 
      5 /* 0xd44700 */,   5 /* 0xd48d00 */,   0 /* 0xd60100 */
  } /* EPS_PN_4102_EI1555 */
};



/* -----------------------------------------------------------------------------
    &&&~ Macro definitions
 ----------------------------------------------------------------------------- */

#if defined (FRFM_ENABLE_DEBUG_MODE)
# define FrfmAssert(p, e)                                               if(!(p)) {ApplFrfmFatalError((e), (vuint16)__LINE__);}
# define FrfmAssertUnconditional(e)                                     ApplFrfmFatalError((e), (vuint16)__LINE__);
#else
# define FrfmAssert(p, e)                                               /* Not used */
# define FrfmAssertUnconditional(e)                                     /* Not used */
#endif


#define FRFM_INFOTABLE_IDX(sfn)                                        ((g_frfmDtcInfoIdx[g_frfmCurrConfig][sfn]))
#define FrfmIsValidMultiConfigSfn(sfn)                                 ((FRFM_INFOTABLE_IDX(sfn) != kFrfmNumDtcProperties))
/* convert from Unit to internal stored format */
#define FrfmConvertKilometer(x)                                        ((x)/16)
#define FrfmConvertVolt(x)                                             ((x)*10)

#define FrfmNvramMirrorIsDirty()                                       (g_frfmNvramMirrorIsDirty = frfmTrue)  /* use this assignment before modifying data */

#if defined (FRFM_ENABLE_DTC_RUNTIME_CONFIG)
# define FrfmIsSfnNotSuppressed(dtcSfn)                                (FrfmIsBitClearedInArray((dtcSfn), g_frfmNVData.chron.runtimeConfigurableData.frfmRtDtcSuppressFlag))
#else
# define FrfmIsSfnNotSuppressed(dtcSfn)                                (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX((dtcSfn))].dtcSuppressFlag == 0)
#endif

#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
# if defined (FRFM_ENABLE_NVRAM_CHG_TRIGGER)
#  define FrfmIsTriggerOnEventSuppressed(dtcSfn)                        (FrfmIsBitSetInArray((dtcSfn), g_frfmNVData.chron.suppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag))
# else
#  define FrfmIsTriggerOnEventSuppressed(dtcSfn)                        (FrfmIsBitSetInArray((dtcSfn), g_frfmSuppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag))
# endif
#endif

/* Invert the bits of a preprocessor constant without compiler warnings */
#define FRFM_NEG_U8(const_u8)                                           (0xFFu - (const_u8))




/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

/*******************************************************************************
* NAME:              FrfmGetChronoStackMgrIndex
*
* CALLED BY:         FRFM
* PRECONDITIONS:     
*
* DESCRIPTION:       Scans for a certain internal DTC number and returns its 
*                    position(index) in the stack.
*******************************************************************************/
static t_FrfmDtcChronoRefType FrfmGetChronoStackMgrIndex(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmDtcChronoRefType iter = 0;

  while ((iter < g_frfmNVData.chron.chronoStackCurrentSize) &&
       (g_frfmNVData.chron.chronoStackManager[iter].dtcInternalNumber != dtcSfn))
  {
    iter++;
  }
  return iter;
}

/*******************************************************************************
* NAME:              FrfmGetChronoStackPtr
*
* CALLED BY:         FRFM
* PRECONDITIONS:     
*
* DESCRIPTION:       Scans for a certain internal DTC number and returns pointer
*                    to its ChronoStack entry (NULL if dtcSfn not in ChronoStack).
*******************************************************************************/
static t_FrfmChronoStack* FrfmGetChronoStackPtr(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmChronoStack*     chronoStackPtr = V_NULL;
  t_FrfmDtcChronoRefType iter = FrfmGetChronoStackMgrIndex(dtcSfn);

  if (iter < g_frfmNVData.chron.chronoStackCurrentSize)
  {
    chronoStackPtr = &g_frfmNVData.chron.chronoStack[g_frfmNVData.chron.chronoStackManager[iter].ref];
  }
  return chronoStackPtr;
}

/*******************************************************************************
* NAME:              FrfmGetSfn
*
* CALLED BY:         internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Scans whole DTC table for a matching single DTC
*                    independent of current config and delivers its SFN.
*                    
* RETURN VALUE:      internal DTC number (SFN) or 
*                    'kFrfmInvalidDtc' if no DTC is matching
*******************************************************************************/
static t_FrfmDtcSfnType FrfmGetSfn(const t_FrfmDtcNumType dtcNum)
{
  t_FrfmDtcSfnType   scanIdx,loIdx,hiIdx;
  t_FrfmDtcSfnType   result = kFrfmInvalidDtc;

  /* Init TOP and BOTTOM boundaries */
  loIdx = 0;
  hiIdx = kFrfmNumDtc - 1;

  while (loIdx <= hiIdx)
  {
    /* Calculate the probe reference */
    scanIdx = (t_FrfmDtcSfnType)((hiIdx + loIdx)>>1);

    /* Check if DTC found */
    if(g_frfmDtcNumTable[scanIdx] == dtcNum)
    {
      /* found a matching element */
      result = scanIdx;
      break;
    }
    else
    {
      /* Determine which half shall be taken */
      if (g_frfmDtcNumTable[scanIdx] > dtcNum)
      {
        /* Searched DTC number is lower than the current reference: Use lower half of interval... */
        if(scanIdx > 0)
        {
          hiIdx = (t_FrfmDtcSfnType)(scanIdx - 1);
        }
        else
        { /* Not available */
          break;  /* result = kFrfmInvalidDtc */
        }
      }
      else
      {
        /* Searched DTC number is greater than the current reference: Use upper half of interval... */
        if(scanIdx < kFrfmNumDtc)
        {
          loIdx = (t_FrfmDtcSfnType)(scanIdx + 1);
        }
        else
        { /* Not available */
          break;  /* result = kFrfmInvalidDtc */
        }
      }
    }
  }
  /* if while() not break'd: Nothing found */
  return result;
}


/*******************************************************************************
* NAME:              FrfmGetDtcSFN
*
* CALLED BY:         FRFM/DiagApplication
* PRECONDITIONS:     
*
* DESCRIPTION:       Scans the DTC table for a matching single DTC in the 
*                    current config and delivers its SFN.
*                    
* RETURN VALUE:      internal DTC number (SFN) or 
*                    'kFrfmInvalidDtc' if no DTC is matching
*******************************************************************************/
t_FrfmDtcSfnType FrfmGetDtcSFN(const t_FrfmDtcNumType dtcNum)
{
  t_FrfmDtcSfnType  foundSfn;
  foundSfn = FrfmGetSfn(dtcNum);
  if (foundSfn != kFrfmInvalidDtc)
  { /* Check if found DTC exists in current multi-config */
    if (!FrfmIsValidMultiConfigSfn(foundSfn))
    { /* Not available in current configuration */
      foundSfn = kFrfmInvalidDtc;
    }
  }
  return foundSfn;
}


/*******************************************************************************
* NAME:              FrfmGetDtcNum
*
* CALLED BY:         Application
* PRECONDITIONS:     Limit 'sfn' to valid range 0..(kFrfmNumDtc-1)
*
* DESCRIPTION:       Returns the DTC number for a given SFN.
*                    The SFN is not restricted to the current config.
*                    
* RETURN VALUE:      external used DTC number
*
*******************************************************************************/
t_FrfmDtcNumType FrfmGetDtcNum(const t_FrfmDtcSfnType dtcSfn)
{
  FrfmAssert((dtcSfn < kFrfmNumDtc), kFrfmAssertIllegalSfn);
  return g_frfmDtcNumTable[dtcSfn];
}


/*******************************************************************************
* NAME:              FrfmMemMove
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Copies a RAM data block to another RAM data block, blocks
*                    may overlap
*
*******************************************************************************/
void FrfmMemMove(vuint8* tgtAddr, const vuint8* srcAddr, vuint16 blockLen)
{
  FrfmAssert((srcAddr != NULL), kFrfmAssertZeroPointer);
  FrfmAssert((tgtAddr != NULL), kFrfmAssertZeroPointer);
  /* Check for destructive overlap */
  if ((srcAddr < tgtAddr) && (tgtAddr < &srcAddr[blockLen]))
  { /* Destructive overlapping, we have to copy backwards */
#if defined ( V_ENABLE_USE_DUMMY_STATEMENT )
    for (blockLen=blockLen, srcAddr = &srcAddr[blockLen], tgtAddr = &tgtAddr[blockLen]; blockLen > 0; --blockLen)
#else
    for (srcAddr = &srcAddr[blockLen], tgtAddr = &tgtAddr[blockLen]; blockLen > 0; --blockLen)
#endif
    {
      *--tgtAddr = *--srcAddr;
    }
  }
  else if (tgtAddr != srcAddr)
  { /* No overlapping, do a forward copy */
    for ( ; blockLen > 0 ; --blockLen)
    {
      *(tgtAddr++) = *(srcAddr++);    /* MISRA required parentheses irritate here ;-) first we do *tgtAddr=*srcAddr, then tgtAddr++ srcAddr++ */
    }
  }
  else
  { /* src == dst, no copying */
    /* MISRA Rule 60 needs this empty statement */
  }
}


/*******************************************************************************
* NAME:              FrfmMemClear
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Initializes a RAM data block to 0 (zero)
*
*******************************************************************************/
void FrfmMemClear(void* tgtAddr, vuint16 blockLen)
{
#if defined (VSTD_ENABLE_SUPPORT_MEM_FCT)
  VStdMemClr(tgtAddr, blockLen);
#else
  while(blockLen != 0u)
  {
    --blockLen;
    ((vuint8*)tgtAddr)[blockLen] = (vuint8)0x00;
  }
#endif
}

/*******************************************************************************
* NAME:              FrfmClearDTC
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       Clear DTC group "ALL" by diagnostic request (UDS)
*                    
*******************************************************************************/
t_FrfmReturnCode FrfmClearDTC(t_FrfmDtcNumType reqDtcCode, t_FrfmDTCOrigin dtcOrigin)
{
  t_FrfmReturnCode returnValue = frfmRC_Failed;

  /* check requested DTC origin */
  if (dtcOrigin == frfmDO_ChronoStack)
  { /* Chrono stack was choosen */
    if (reqDtcCode == (t_FrfmDtcNumType) 0xFFFFFFu)
    { /* yes, all DTCs are addressed */
      if (g_frfmInitializationStatus == storageInitialized)
      {
#if defined (FRFM_ENABLE_APPL_CLEARDIAGINFO)
        if (frfmTrue == ApplFrfmCheckClearDTC(reqDtcCode))
#endif
        {
          returnValue = frfmRC_OK;

#if defined FRFM_ENABLE_CLEAR_DTC_NOTIFY
          ApplFrfmDtcWillBeCleared(reqDtcCode);         /* callback before internal clear will start */
#endif
          /* initialize the whole chrono stack and reset status of all DTCs */
          g_frfmLock.location = frfmLL_None;            /* remove stale lock */
          FrfmClearChronoStack(frfmTrue);               /* notify status change(s) to Application, but no RoE */

#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
          /* each (successful) ClearDiagnosticInformation request resets all FaultDetectionCounters */
          { /* see ISO 14229-1.2: Request Message sub function definition */
            t_FrfmDtcSfnType dtcSfn;
            for (dtcSfn=0; dtcSfn<kFrfmNumDtc; ++dtcSfn)
            {
              g_frfmFaultDetectionCounter[dtcSfn] = 0;
            }
          }
#endif /*FRFM_ENABLE_DTC_DEBOUNCING*/
#if defined FRFM_ENABLE_CLEAR_DTC_NOTIFY
          ApplFrfmDtcWasCleared(reqDtcCode);            /* callback after internal clear has finished */
#endif
        }
#if defined (FRFM_ENABLE_APPL_CLEARDIAGINFO)
        /* else: returnValue = frfmRC_Failed; is already set */
#endif
      }
      else
      {
        /* returnValue = frfmRC_Failed; is already set */
      }
    }
    else
    {
      returnValue = frfmRC_WrongDTC;
    }
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmGetSizeOfExtendedDataRecord
*
* CALLED BY:         Appl
* PRECONDITIONS:     
*
* DESCRIPTION:       get size of specified data record (UDS). The size sums the
*                    number of all user data bytes (StandardRecord incl. DTC-
*                    Number and Status plus ExtendedDataRecord(s) RecordID(s)).
*                    
*******************************************************************************/
vuint16 FrfmGetSizeOfExtendedDataRecord(t_FrfmDtcNumType reqDtcCode,
                                        t_FrfmDTCOrigin dtcOrigin,
                                        t_FrfmRecordNumber recordNumber)
{
  vuint16 length = 0;

  t_FrfmDtcSfnType dtcSfn = FrfmGetDtcSFN(reqDtcCode);
  if (dtcSfn != kFrfmNumDtc)
  {
    if ((recordNumber == 0x01) || (recordNumber == 0xff))
    {
      length = 4;                                         /* always: DTC, Status */
      switch(dtcOrigin)
      {
      case frfmDO_ChronoStack:
        length += 8;                                      /* std data: recordID, OccFlag, OrigOdo, MRecOdo, Freq, OCC */
        break;
#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
      case frfmDO_FaultDetectionCounter:
#endif
      default:
        length = 0;
        recordNumber = 0;                                 /* used to skip following code */
        break;
      }
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA) || defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
      if (recordNumber == 0xff)
      {
# if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
        /* do not add 1Byte recordID for a zero-sized record */
        if (0 != g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm)
        {
          length += (vuint16)1u + (vuint16)(g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm);  /* opt data: recordID, values */
        }
# endif
# if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
        /* do not add 1Byte recordID for a zero-sized record */
        if (0 != g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent)
        {
          length += (vuint16)1u + (vuint16)(g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent);    /* opt data: recordID, values */
        }
# endif
      }
#endif
    }
  }

  return length;
}

/*******************************************************************************
* NAME:              FrfmLockExtendedDataRecordByDTC
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       Lock a data record (UDS)
*                    - responseDataLength may have invalid data, if return code isn't 'frfmRC_OK'
*                    - responseDataLength will be >0, if return code is 'frfmRC_OK'
*******************************************************************************/
t_FrfmReturnCode FrfmLockExtendedDataRecordByDTC(t_FrfmDtcNumType reqDtcCode,
                                                 t_FrfmDTCOrigin dtcOrigin,
                                                 t_FrfmRecordNumber recordNumber,
                                                 vuint16* responseDataLength)
{
  t_FrfmReturnCode  returnValue = frfmRC_Failed;

  g_frfmLock.location = frfmLL_None;    /*unlock previous locks*/

  if ((g_frfmInitializationStatus == storageInitialized) &&
      ((dtcOrigin == frfmDO_ChronoStack)
     ))
  {
    /* Is DTC supported by the ECU? Check for single DTC number */
    t_FrfmDtcSfnType dtcSfn = FrfmGetDtcSFN(reqDtcCode);

    if (dtcSfn != kFrfmNumDtc)
    { /* yes, the requested DTC is defined */
      if (FrfmIsSfnNotSuppressed(dtcSfn))
      { /* DTC is not suppressed */
        if ((recordNumber == 0x01) || (recordNumber == 0xff))
        {
          /* set defaults, for sfn not found in the chrono/historical stack */
          *responseDataLength         = 4;
          g_frfmCurrentExtendedRecord = 0xF0u;
          g_frfmLock.location         = frfmLL_StatusStack;
          g_frfmLock.dtcSfn           = dtcSfn;

          /* check requested DTC origin */
          if (dtcOrigin == frfmDO_ChronoStack)
          { /* Chrono stack was choosen */
            t_FrfmDtcChronoRefType chronoStackManagerIndex = FrfmGetChronoStackMgrIndex(dtcSfn);
            if (chronoStackManagerIndex < g_frfmNVData.chron.chronoStackCurrentSize)
            {
              g_frfmLock.location = frfmLL_ChronoStack;
              *responseDataLength += 8;       /*recordID + 7 data*/
              if (recordNumber == 0x01)
              {
                g_frfmCurrentExtendedRecord = 0x10u; /*standard environmental data (chrono stack)*/
              }
              else
              {
                g_frfmCurrentExtendedRecord = 0x20u; /*all environmental data      (chrono stack)*/
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
                /* do not add 1Byte recordID for a zero-sized record */
                if (0 != g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm)
                {
                  *responseDataLength += (vuint16)1u + (vuint16)(g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm); /* opt data: recordID, values */
                }
#endif
#if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
                /* do not add 1Byte recordID for a zero-sized record */
                if (0 != g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent)
                {
                  *responseDataLength += (vuint16)1u + (vuint16)(g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent);   /* opt data: recordID, values */
                }
#endif
              }
            }
          }
          returnValue = frfmRC_OK;
        }
        else /* invalid record number chosen */
        {
          returnValue = frfmRC_WrongRecordNumber;
        }
      }
      else /* requested DTC is suppressed */
      {
        returnValue = frfmRC_WrongDTC;
      }
    }
    else /* requested DTC is not single DTC */
    {
      returnValue = frfmRC_WrongDTC;
    }
  }
  /* else: invalid origin  or  g_frfmInitializationStatus==storageUninitialized, returnValue is set to frfmRC_Failed */
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmGetExtendedDataRecordByDTC
*
* CALLED BY:         Desc
* PRECONDITIONS:     Data record is locked by FrfmLockExtendedDataRecordByDTC
*
* DESCRIPTION:       Get next part of the locked ExtendedDataRecord (UDS)
*                    
*******************************************************************************/
t_FrfmReturnCode FrfmGetExtendedDataRecordByDTC(vuint8 **sourceBuffer, vuint16 *bufferSize)
{
  t_FrfmReturnCode  returnValue;

  *sourceBuffer = 0;
  *bufferSize = 0;

  if ((g_frfmLock.location == frfmLL_None) || (g_frfmInitializationStatus != storageInitialized))
  {
    returnValue = frfmRC_Failed;
  }
  else
  {
    if (g_frfmLock.location == frfmLL_ChronoStack)
    { /* standard/all environmental data from chrono stack */
      returnValue = FrfmCsGetExtDataRecordByDTC(sourceBuffer, bufferSize);
    }
    else
    { /* valid DTC, not in chrono/historical stack */
      returnValue = FrfmNsGetExtDataRecordByDTC(sourceBuffer, bufferSize);
    }
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmGetNsExtendedDataRecordByDTC
*
* CALLED BY:         Desc
* PRECONDITIONS:     Data record is locked by FrfmLockExtendedDataRecordByDTC
*
* DESCRIPTION:       Get next part of the locked ExtendedDataRecord (UDS)
*                    for a dtc neither in Chrono nor in Historical Stack
*******************************************************************************/
static t_FrfmReturnCode FrfmNsGetExtDataRecordByDTC(vuint8 **sourceBuffer, vuint16 *bufferSize)
{
  static vuint8 dataPtr[2];
  t_FrfmReturnCode  returnValue = frfmRC_OK;

  switch (g_frfmCurrentExtendedRecord)
  {
  case 0xE0u:        /* valid DTC, not in historical stack */
  case 0xF0u:        /* valid DTC, not in chrono stack */
    dataPtr[0]  = FrfmGetHiLoByte(g_frfmDtcNumTable[g_frfmLock.dtcSfn]);  /*DTC HighByte*/
    dataPtr[1]  = FrfmGetLoHiByte(g_frfmDtcNumTable[g_frfmLock.dtcSfn]);  /*DTC MiddleByte*/
    *sourceBuffer = dataPtr;
    *bufferSize   = 2;
    break;
  case 0xE1u:
  case 0xF1u:
    dataPtr[0]  = FrfmGetLoLoByte(g_frfmDtcNumTable[g_frfmLock.dtcSfn]);  /*DTC LowByte*/
    dataPtr[1]  = (vuint8)((g_frfmCurrentExtendedRecord == 0xE1u) ? 0u    /*case 0xE1: DTC status not-in-HStack: always 0x00 */
      : FrfmGetStatusByte(g_frfmLock.dtcSfn));                            /*case 0xF1: DTC status not-in-CStack*/
    *sourceBuffer = dataPtr;
    *bufferSize   = 2;
    break;
  default:
    returnValue = frfmRC_NoMoreData;
    /* set state to invalid number */
    g_frfmCurrentExtendedRecord = 0xFEu;
    break;
  }
  g_frfmCurrentExtendedRecord++;
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmGetCsExtendedDataRecordByDTC
*
* CALLED BY:         Desc
* PRECONDITIONS:     Data record is locked by FrfmLockExtendedDataRecordByDTC
*
* DESCRIPTION:       Get next part of the locked ExtendedDataRecord (UDS)
*                    for a dtc in ChronoStack
*******************************************************************************/
static t_FrfmReturnCode FrfmCsGetExtDataRecordByDTC(vuint8 **sourceBuffer, vuint16 *bufferSize)
{
  static vuint8 dataPtr[2];
  t_FrfmReturnCode  returnValue = frfmRC_OK;
  t_FrfmBool        lookAhead   = frfmFalse;            /* re-iterate statemachine for handling states without reportable data */
  /* lookAhead==true: data was collected and next state shall give no data - but to sync the statemachine go to next state now */

  t_FrfmChronoStack     *lCStackPtr;
  lCStackPtr = FrfmGetChronoStackPtr(g_frfmLock.dtcSfn);
  do 
  {
    switch (g_frfmCurrentExtendedRecord)
    {
    case 0x10u:        /* standard environmental data (chrono stack)*/
    case 0x20u:        /* all environmental data      (chrono stack)*/
      dataPtr[0]  = FrfmGetHiLoByte(g_frfmDtcNumTable[g_frfmLock.dtcSfn]);  /*DTC HighByte*/
      dataPtr[1]  = FrfmGetLoHiByte(g_frfmDtcNumTable[g_frfmLock.dtcSfn]);  /*DTC MiddleByte*/
      *sourceBuffer = dataPtr;
      *bufferSize   = 2;
      break;
    case 0x11u:
    case 0x21u:
      dataPtr[0]  = FrfmGetLoLoByte(g_frfmDtcNumTable[g_frfmLock.dtcSfn]);  /*DTC LowByte*/
      dataPtr[1]  = FrfmGetStatusByte(g_frfmLock.dtcSfn);                   /*DTC status for chrono stack*/
      *sourceBuffer = dataPtr;
      *bufferSize   = 2;
      break;
    case 0x12u:
    case 0x22u:
      dataPtr[0]  = 0x01u;                                                  /* DTCExtendedDataRecordNumber for standard env data*/
      dataPtr[1]  = (vuint8)(( g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].dtcOccurenceFlag != 0) ? 0x01u : 0x00u);
      *sourceBuffer = dataPtr;
      *bufferSize   = 2;
      break;
    case 0x13u:
    case 0x23u:
      FrfmAssert((lCStackPtr != V_NULL), kFrfmAssertIllegalCStackReference);
      dataPtr[0]  = FrfmGetHiByte(lCStackPtr->originalOdometer);
      dataPtr[1]  = FrfmGetLoByte(lCStackPtr->originalOdometer);
      *sourceBuffer = dataPtr;
      *bufferSize   = 2;
      break;
    case 0x14u:
    case 0x24u:
      FrfmAssert((lCStackPtr != V_NULL), kFrfmAssertIllegalCStackReference);
      dataPtr[0]  = FrfmGetHiByte(lCStackPtr->mostRecentOdometer);
      dataPtr[1]  = FrfmGetLoByte(lCStackPtr->mostRecentOdometer);
      *sourceBuffer = dataPtr;
      *bufferSize   = 2;
      break;
    case 0x15u:
      lookAhead = frfmFalse;                                  /* all done, last part of data was copied */
      /* fallthrough - execute next code lines, too */
    case 0x25u:
      FrfmAssert((lCStackPtr != V_NULL), kFrfmAssertIllegalCStackReference);
      dataPtr[0]  = lCStackPtr->frequencyCounter;
      dataPtr[1]  = lCStackPtr->ignitionCycleCounter;
      *sourceBuffer = dataPtr;
      *bufferSize   = 2;
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
      if ( (lookAhead == frfmFalse)
        && (0 == g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordSize_firstConfirm))
      { /* there is no first confirmed record defined, try most recent record */
        g_frfmCurrentExtendedRecord = 0x28u;                  /* next state will be 0x28 - check Most Recent record */
        lookAhead = frfmTrue;
      }
#elif defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
      if ( (lookAhead == frfmFalse)
        && (0 == g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordSize_mostRecent))
      { /* there is no most recent record defined, we can terminate */
        lookAhead = frfmFalse;                                /* all done, last part of data was copied */
      }
#else
      /* no additional environmental data configured */
      lookAhead = frfmFalse;                                  /* all done, last part of data was copied */
#endif
      break;
    case 0x26u:      /* additional environmental data (chrono stack) - First Confirmed record - number */
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
      /* there is a first confirmed record defined, just return its record number */
      dataPtr[0]  = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordNumber_firstConfirm;
      *sourceBuffer = dataPtr;
      *bufferSize   = 1;
      break;
    case 0x27u:      /* additional environmental data (chrono stack) - First Confirmed record - data */
      *sourceBuffer = &(g_frfmNVData.chron.chronoStackAddEnvData[lCStackPtr->envDataIndex_firstConfirmed]);
      *bufferSize   = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordSize_firstConfirm;
# if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
      if ( (lookAhead == frfmFalse)
        && (0 == g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordSize_mostRecent))
# endif
      { /* there is no most recent record defined or configured, copy record to historical stack */
       lookAhead = frfmFalse;                                  /* all done, last part of data was copied */
     }
      break;
#else
      g_frfmCurrentExtendedRecord = 0x28u;                    /* no FIRST_CONFIRMED_ENV_DATA configured, but there is a most recent record */
      /* fall through */
#endif
    case 0x28u:      /* additional environmental data (chrono stack) - Most Recent record - number */
# if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
      if (0 == g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordSize_mostRecent)
      { /* there is no most recent record configured, copy record to historical stack */
        lookAhead = frfmFalse;                                /* all done, last part of data was copied */
      }
      else if (lookAhead != frfmFalse)
      { /* there is a most recent record defined, but we just did a lookahead for it - handle with next function call */
        --g_frfmCurrentExtendedRecord;                        /* next state will be 0x28 again */
        lookAhead = frfmFalse;                                /* return with already set data now */
      }
      else
      { /* there is a most recent record defined and we now return the data, return record number */
        dataPtr[0]  = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordNumber_mostRecent;
        *sourceBuffer = dataPtr;
        *bufferSize   = 1;
      }
      break;
    case 0x29u:      /* additional environmental data (chrono stack) - Most Recent record - data */
      *sourceBuffer = &g_frfmNVData.chron.chronoStackAddEnvData[lCStackPtr->envDataIndex_mostRecent];
      *bufferSize   = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(g_frfmLock.dtcSfn)].envDataRecordSize_mostRecent;
# endif
      lookAhead = frfmFalse;                                  /* all done, last part of data was copied */
      break;
    default:
      returnValue = frfmRC_NoMoreData;
      lookAhead = frfmFalse;
      /* set state to invalid number */
      g_frfmCurrentExtendedRecord = 0xFEu;
      break;
    }
  } while (frfmFalse != lookAhead);

  /* prepare for next call */
  ++g_frfmCurrentExtendedRecord;

  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmUnlockExtDataRecordByDTC
*
* CALLED BY:         Desc
* PRECONDITIONS:     previous call of FrfmLockExtendedDataRecordByDTC
*
* DESCRIPTION:       Unlock a data record (UDS)
*                    
*******************************************************************************/
t_FrfmBool FrfmUnlockExtDataRecordByDTC(void)
{
  t_FrfmBool returnValue = frfmFalse;

  if (g_frfmLock.location != frfmLL_None)
  {
    g_frfmLock.location = frfmLL_None;
    returnValue = frfmTrue;
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmGetDtcFormat
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       Get the DTC format of the currently used configuration
*                    See ISO14229-1.2, ReadDTCInformation service 19 01/11
*                    0: Iso15031-6, 1: Iso14229-1, 2: SaeJ1939-73, 3: Iso11992-4 
*                    
*******************************************************************************/
vuint8 FrfmGetDtcFormat(void)
{
  return g_frfmDTCFormat[g_frfmCurrConfig];
}


/*******************************************************************************
* NAME:             FrfmIsSupportedDTC
*                   
* CALLED BY:        Application 
* PRECONDITIONS:     
*
* DESCRIPTION:      check, if given reqDtcCode is a supported number 
*                   (valid dtc group or a configured single dtc number) (UDS)  
*******************************************************************************/
t_FrfmBool FrfmIsSupportedDTC(t_FrfmDtcNumType reqDtcCode)
{
  t_FrfmBool returnValue = frfmFalse;

  switch(reqDtcCode)
  { /* Check for DTC Groups */
  case 0xFFFFFFu:  /* All Groups */
    returnValue = frfmTrue;
    break;
  default:
    { /* Check for Single DTC */
      t_FrfmDtcSfnType dtcSfnNumber = FrfmGetDtcSFN(reqDtcCode);
      if (dtcSfnNumber != kFrfmNumDtc)
      {
        returnValue = frfmTrue;
      }
    }
    break;
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmSetDTCFilter
*
* CALLED BY:         DiagFrfm
* PRECONDITIONS:     
* RETURN VALUE:      0xFFFF on non-operative FRFM (introduced in v2.01.00)
*                    0      on no matching DTC(s) or invalid dtcOrigin
*                    else:  total Number of filtered DTCs matching the defined
*                           filter mask 
*
*                    g_frfmIdxOfFilteredDtc contains the number of DTCs in the
*                    Chrono/Historical Stack and is used as element count for
*                    g_frfmFilter.cs.listOfIdentified[] resp.
*                    g_frfmFilter.hs.listOfIdentified[]
* DESCRIPTION:       set filter mask over DTCs for FrfmGetNextFilteredDTC()
*                    (UDS)
*******************************************************************************/
vuint16 FrfmSetDTCFilter(t_FrfmDTCStatusMask reqDtcStatusMask, t_FrfmDTCOrigin dtcOrigin)
{
  vuint16  countOfIdentified = 0;
  g_frfmIdxOfFilteredDtc = 0;           /* counter for used elements of g_frfmFilter.NN.listOfIdentified[] */

  if (g_frfmInitializationStatus == storageInitialized)
  {
    t_FrfmDtcSfnType        dtcSfn;

    if (dtcOrigin == frfmDO_ChronoStack)
    {
      frfmuint                i;
      t_FrfmDTCStatusMask     dtcStatus;

      /* remove unsupported bits from requested dtcStatusMask */
      reqDtcStatusMask &= FrfmGetDTCStatusAvailab_Mask();

      g_frfmFilterType                 = kFrfmCSListOfIdentified;
      g_frfmFilter.cs.matchingSfnCount = 0;
      for (i=0; i<sizeof(g_frfmFilter.cs.matchingSfn); ++i)
      {
        g_frfmFilter.cs.matchingSfn[i] = 0;
      }

      if (reqDtcStatusMask != 0x00)
      {
        t_FrfmDtcChronoRefType  chronoStackManagerIndex;

        /* first: scan all DTCs in chrono stack */
        for (chronoStackManagerIndex = 0;
             chronoStackManagerIndex < g_frfmNVData.chron.chronoStackCurrentSize;
             ++chronoStackManagerIndex)
        {
          dtcSfn    = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].dtcInternalNumber;
          dtcStatus = FrfmMapStatusByteIntToExt(g_frfmDtcStatusByte[dtcSfn]);
          /* check requested status mask against status of DTC */
          if ((reqDtcStatusMask & dtcStatus) != 0x00)
          {
            g_frfmFilter.cs.listOfIdentified[g_frfmIdxOfFilteredDtc] = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].dtcInternalNumber;
            ++g_frfmIdxOfFilteredDtc;
            ++countOfIdentified;
          }
        }

        /* second: scan all (other) DTCs for a matching status */
        for (dtcSfn = 0; dtcSfn < kFrfmNumDtc; ++dtcSfn)
        {
          if ((FrfmIsValidMultiConfigSfn(dtcSfn)) &&        /* is the DTC available in the current config and */
              (FrfmIsSfnNotSuppressed(dtcSfn)))                                       /* is it not suppressed */
          {
            /* this DTC is available in the current config and not suppressed */
            dtcStatus = FrfmMapStatusByteIntToExt(g_frfmDtcStatusByte[dtcSfn]);
            if ((reqDtcStatusMask & dtcStatus) != 0x00)
            { /* this DTC matches requested status mask */
              if ((dtcStatus & (t_FrfmDTCStatusMask)(kFrfmConfirmedDTCBit)) == ((t_FrfmDTCStatusMask) 0))
              { /* this sfn was not marked by above chrono stack scan */
                FrfmSetBitInArray(dtcSfn, g_frfmFilter.cs.matchingSfn);  /* set the matching sfn in bitfield 'matchingSfn' */
                ++g_frfmFilter.cs.matchingSfnCount;
                ++countOfIdentified;
              }
            }
          }
          /* else: skip sfn which is not part of current config */
        }
      }
    }
#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
    else if (dtcOrigin == frfmDO_FaultDetectionCounter)
    {
      frfmuint                i;
      vsint8                  faultDetectCntr;

      g_frfmFilterType                  = kFrfmSfnIdentified;
      g_frfmFilter.sfn.matchingSfnCount = 0;
      for (i=0; i<sizeof(g_frfmFilter.sfn.matchingSfn); ++i)
      {
        g_frfmFilter.sfn.matchingSfn[i] = 0;
      }

# if (kFrfmNumConfigs > 1)
/* Multiple Configuration: check, that FRFM is correctly initialized */
      if (((vsint16)g_frfmCurrConfig >= (vsint16)0)
        &&((vsint16)g_frfmCurrConfig <= (vsint16)(kFrfmNumConfigs-1)))
# endif
      {
        for (dtcSfn = 0; dtcSfn < kFrfmNumDtc; ++dtcSfn)
        {
          if ((FrfmIsValidMultiConfigSfn(dtcSfn)) &&        /* is the DTC available in the current config and */
              (FrfmIsSfnNotSuppressed(dtcSfn)))                                       /* is it not suppressed */
          {
            /* this DTC is available in the current config and not suppressed */
            faultDetectCntr = FrfmGetFaultDetectionCounter(dtcSfn);
            if ((0 < faultDetectCntr) && (faultDetectCntr < 127))
            { /* this DTC has counter between excl. 0 and 127, so tag it */
              FrfmSetBitInArray(dtcSfn, g_frfmFilter.sfn.matchingSfn);  /* set the matching sfn in bitfield 'matchingSfn' */
              ++g_frfmFilter.sfn.matchingSfnCount;
              ++countOfIdentified;
            }
            /* else: skip sfn which has FDC outside range 1..126 */
          }
          /* else: skip sfn which is not part of current config */
        }
      }
    } /* if (dtcOrigin == frfmDO_FaultDetectionCounter) */
#endif /*FRFM_ENABLE_DTC_DEBOUNCING*/
#if defined (FRFM_ENABLE_REPORT_ALLSUPPORTED)
    else if (dtcOrigin == frfmDO_AllSupported)
    { /* reportSupportedDTCs */
      frfmuint                i;

      g_frfmFilterType                  = kFrfmSfnSupported;
      g_frfmFilter.sfn.matchingSfnCount = 0;
      for (i=0; i<sizeof(g_frfmFilter.sfn.matchingSfn); ++i)
      {
        g_frfmFilter.sfn.matchingSfn[i] = 0;
      }

# if (kFrfmNumConfigs > 1)
/* Multiple Configuration: check, that FRFM is correctly initialized */
      if (((vsint16)g_frfmCurrConfig >= (vsint16)0)
        &&((vsint16)g_frfmCurrConfig <= (vsint16)(kFrfmNumConfigs-1)))
# endif
      {
        for (dtcSfn = 1; dtcSfn < kFrfmNumDtc; ++dtcSfn)
        {
          if (FrfmIsValidMultiConfigSfn(dtcSfn))
          { /* this DTC is available in the current config */
            /* Is DTC suppressed? If yes, do not report to Client */
            if (FrfmIsSfnNotSuppressed(dtcSfn))
            { /* this DTC shall not be suppressed, so tag it */
              FrfmSetBitInArray(dtcSfn, g_frfmFilter.sfn.matchingSfn);  /* set the matching sfn in bitfield 'matchingSfn' */
              ++g_frfmFilter.sfn.matchingSfnCount;
              ++countOfIdentified;
            }
          }
          /* else: skip sfn which is not part of current config */
        }
      }
    } /* if (dtcOrigin == frfmDO_AllSupported) */
#endif /*FRFM_ENABLE_REPORT_ALLSUPPORTED*/
  }
  else
  {
    countOfIdentified = 0xFFFFu;
  }

  return  countOfIdentified;
}


/*******************************************************************************
* NAME:              FrfmGetDTCStatusAvailab_Mask
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       Available bits in DTC status byte (UDS)
*                    
*******************************************************************************/
t_FrfmDTCStatusMask FrfmGetDTCStatusAvailab_Mask(void)
{
  return (
#if defined (FRFM_ENABLE_TESTFAILED_STATUS)
         kFrfmTestFailedBit +
#endif
#if defined (FRFM_ENABLE_TFTOC_BIT_STATUS)
         kFrfmTestFailedThisOperationCycleBit +
#endif
#if defined (FRFM_ENABLE_PREFAILED_STATUS)
         /* kFrfmPreFailedBit + ** never report PreFailed bit */
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
         kFrfmPendingDTCBit +
#endif
#if defined (FRFM_ENABLE_CONFIRMEDDTC_STATUS)
         kFrfmConfirmedDTCBit +
#endif
#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
         kFrfmTestNotCompletedSinceLastClearBit +
#endif
#if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
         kFrfmTestFailedSinceLastClearBit +
#endif
#if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS)
         kFrfmTestNotCompletedThisOperationCycleBit +
#endif
#if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
         kFrfmWarningIndicatorRequestedBit +
#endif
         0u
         );
}


/*******************************************************************************
* NAME:              FrfmNarrowDownSupportedStatus
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       Unset all statusbits in 'status', that were not
*                    configured to be supported. For some algorithms we may need
*                    internally additional status bits, these pure internal bits
*                    are set to 0 here.
*                    This is a weaker masking than FrfmGetDTCStatusAvailab_Mask()
*                    as we here keep supported bits (e.g. PreFailed), that will
*                    never be reported in UDS status.
*                    
*******************************************************************************/
static t_FrfmDtcStatusByte FrfmNarrowDownSupportedStatus(t_FrfmDtcStatusByte status)
{
#if ! defined (FRFM_ENABLE_TESTFAILED_STATUS)
  status.s.bTestFailed = 0;
#endif
#if ! defined (FRFM_ENABLE_TFTOC_BIT_STATUS)
  status.s.unused1 = 0;
#endif
#if (! defined (FRFM_ENABLE_PENDINGDTC_STATUS)) && (! defined (FRFM_ENABLE_PREFAILED_STATUS))
  status.s.unused2 = 0;
#endif
#if ! defined (FRFM_ENABLE_CONFIRMEDDTC_STATUS)
  status.s.bConfirmedDTC = 0;
#endif
#if ! defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
  status.s.unused4 = 0;
#endif
#if ! defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
  status.s.unused5 = 0;
#endif
#if ! defined (FRFM_ENABLE_TNCTOC_BIT_STATUS)
  status.s.unused6 = 0;
#endif
#if ! defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
  status.s.unused7 = 0;
#endif
  return status;
}


/*******************************************************************************
* NAME:              FrfmFindSetBitInArrayAndReset
*
* CALLED BY:         FrfmGetNextFilteredDTC
* PRECONDITIONS:     the (unused) bits of the last byte in 'array' must be 0 !!
*
* DESCRIPTION:       find the lowest set ('1') bit in the bit-array, return its
*                    bit position (counting 0..n) and clear the bit
*                    
*                    Result: 0=bit#0, 1=bit#1, 2=bit#2,... (sizeInBit-1)=lastBit
*                        or  'sizeInBit' if no bit was set
*******************************************************************************/
static t_FrfmDtcSfnType FrfmFindSetBitInArrayAndReset(vuint8 *array, t_FrfmDtcSfnType const sizeInBit)
{
  t_FrfmDtcSfnType sizeInByte = (t_FrfmDtcSfnType)(((sizeInBit-1)/8)+1);
  t_FrfmDtcSfnType bitpos = 0;
  while (sizeInByte > 0)
  {
    --sizeInByte;                               /* prepare for next loop */
    if (*array == 0)
    {                                           /* no bit is set in this byte */
      if (sizeInByte != 0)
      {                                         /* if not the last byte */
        bitpos += 8;
      }
      else
      {                                         /* last byte was empty, too */
        bitpos = sizeInBit;
      }
    }
    else
    {                                           /* at least one bit is set in this byte */
      vuint8 bBit   = 0;
      vuint8 bValue = *array;
      if ((vuint8)(bValue & (vuint8)0xfu) == (vuint8)0)                 /* do binary search for lowest set bit */
      {
        bValue >>= 4;
        bBit += 4;
      }
      if ((vuint8)(bValue & (vuint8)0x3u) == (vuint8)0)
      {
        bValue >>= 2;
        bBit += 2;
      }
      if ((vuint8)(bValue & (vuint8)0x1u) == (vuint8)0)
      {
        bBit++;
      }
      bitpos = (t_FrfmDtcSfnType)(bitpos + bBit);
      *array &= (vuint8)(~(1u<<bBit));          /* clear found bit */
      sizeInByte = 0;                           /* abort while loop */
    }
    ++array;
  }
  return (bitpos);
}


/*******************************************************************************
* NAME:              FrfmGetNextFilteredDTC
*
* CALLED BY:         DiagFrfm
* PRECONDITIONS:     FrfmSetDTCFilter() was called before! This must be granted
*                    by external mechanism, as it is not verified here.
* DESCRIPTION:       
*                    
*******************************************************************************/
t_FrfmReturnCode FrfmGetNextFilteredDTC(t_FrfmDtcNumType *reqDtcCode, vuint8 *value)
{
  t_FrfmReturnCode returnValue = frfmRC_Failed;

  if (g_frfmInitializationStatus == storageInitialized)
  {
    if (g_frfmFilterType == kFrfmCSListOfIdentified)
    {
      /* set the end return code - for case of no hit */
      returnValue = frfmRC_NoMoreData;
      if (g_frfmIdxOfFilteredDtc != 0)          /* first write the matching cs DTCs */
      {
        --g_frfmIdxOfFilteredDtc;
        *reqDtcCode = g_frfmDtcNumTable[g_frfmFilter.cs.listOfIdentified[g_frfmIdxOfFilteredDtc]];
        /* value is here: dtcStatus */
        *value      = FrfmGetStatusByte(g_frfmFilter.cs.listOfIdentified[g_frfmIdxOfFilteredDtc]);
        /* change return code to success */
        returnValue = frfmRC_OK;
      }
      else if (g_frfmFilter.cs.matchingSfnCount != 0) /* second write the matching remaining DTCs */
      { /* all DTCs from chronostack are reported, now continue with remaining DTCs */
        t_FrfmDtcSfnType idx;
        --g_frfmFilter.cs.matchingSfnCount;
        idx = FrfmFindSetBitInArrayAndReset(g_frfmFilter.cs.matchingSfn, (t_FrfmDtcSfnType) kFrfmNumDtc);
        if (idx != kFrfmNumDtc)
        {
          *reqDtcCode = g_frfmDtcNumTable[idx];
          /* value is here: dtcStatus */
          *value      = FrfmGetStatusByte(idx);
          /* change return code to success */
          returnValue = frfmRC_OK;
        }
      }
      else
      {
        /* MISRA Rule 60 needs this empty statement */
      }
    }
#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
    else if (g_frfmFilterType == kFrfmSfnIdentified)
    {
      /* set the end return code - for case of no hit */
      returnValue = frfmRC_NoMoreData;
      if (g_frfmFilter.sfn.matchingSfnCount != 0)
      {
        t_FrfmDtcSfnType idx;
        --g_frfmFilter.sfn.matchingSfnCount;
        idx = FrfmFindSetBitInArrayAndReset(g_frfmFilter.sfn.matchingSfn, (t_FrfmDtcSfnType) kFrfmNumDtc);
        if (idx != kFrfmNumDtc)
        {
          vsint8 faultDetectCntr;
          *reqDtcCode = g_frfmDtcNumTable[idx];
          /* value is here: fault detection counter */
          faultDetectCntr = FrfmGetFaultDetectionCounter(idx);
          if (faultDetectCntr >= 0)
          {
            *value = (vuint8) faultDetectCntr;
          }
          else
          { /* counter changed between tagging and the present reading, map value to 0 */
            *value = 0;
          }
          /* change return code to success */
          returnValue = frfmRC_OK;
        }
      }

    }
#endif /*FRFM_ENABLE_DTC_DEBOUNCING*/
#if defined (FRFM_ENABLE_REPORT_ALLSUPPORTED)
    else if (g_frfmFilterType == kFrfmSfnSupported)
    {
      /* set the end return code - for case of no hit */
      returnValue = frfmRC_NoMoreData;
      if (g_frfmFilter.sfn.matchingSfnCount != 0)
      {
        t_FrfmDtcSfnType idx;
        --g_frfmFilter.sfn.matchingSfnCount;
        idx = FrfmFindSetBitInArrayAndReset(g_frfmFilter.sfn.matchingSfn, (t_FrfmDtcSfnType) kFrfmNumDtc);
        if (idx != kFrfmNumDtc)
        {
          *reqDtcCode = g_frfmDtcNumTable[idx];
          /* value is here: dtcStatus */
          *value      = FrfmGetStatusByte(idx);
          /* change return code to success */
          returnValue = frfmRC_OK;
        }
      }
    }
#endif /*FRFM_ENABLE_REPORT_ALLSUPPORTED*/
  }
  /* no else necessary - return code is already set */
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmClearChronoStack
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Re-Initialization of chrono stack.
*                    
*******************************************************************************/
static void FrfmClearChronoStack(t_FrfmBool notifyApplication)
{
  frfmuint i;

  FrfmNvramMirrorIsDirty();

  /* Set the DTC's status to default value */
  for (i=0; i<(frfmuint)kFrfmNumDtc; i++)
  {
    /* make a local copy of current status byte */
    t_FrfmDtcStatusByte oldStatus, newStatus;
    oldStatus = FrfmNarrowDownSupportedStatus(g_frfmDtcStatusByte[i]);

    g_frfmDtcStatusByte[i].s.bTestFailed = 0;
#if defined (FRFM_ENABLE_TFTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    g_frfmDtcStatusByte[i].s.bTestFailedThisOperationCycle = 0;
#endif
#if defined (FRFM_ENABLE_PREFAILED_STATUS)
    g_frfmDtcStatusByte[i].s.bPreFailed = 0;
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    g_frfmDtcStatusByte[i].s.bPendingDTC = 0;
#endif
    g_frfmDtcStatusByte[i].s.bConfirmedDTC = 0;
#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
    g_frfmDtcStatusByte[i].s.bTestNotCompletedSinceLastClear = 1;
#endif
#if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
    g_frfmDtcStatusByte[i].s.bTestFailedSinceLastClear = 0;
#endif
#if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    g_frfmDtcStatusByte[i].s.bTestNotCompletedThisOperationCycle = 1;
#endif
#if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
    g_frfmDtcStatusByte[i].s.bWarningIndicatorRequested = 0;
#endif
    newStatus = FrfmNarrowDownSupportedStatus(g_frfmDtcStatusByte[i]);
    /* check if DTC status changed by last lines of code */
    if ((notifyApplication == frfmTrue) && (oldStatus.c != newStatus.c))
    { /* there is a change - notify application */
      ApplFrfmOnDtcStatusChange(g_frfmDtcNumTable[i], oldStatus, newStatus);
    }
  }

  /* Clear all data in the chronostack by resetting the management data */
  for (i=0; i<(frfmuint)kFrfmChronoStackSize; i++)
  {
    /* g_frfmNVData.chron.chronoStack[i].originalOdometer              = 0; not necessary */
    /* g_frfmNVData.chron.chronoStack[i].mostRecentOdometer            = 0; not necessary */
    /* g_frfmNVData.chron.chronoStack[i].frequencyCounter              = 0; not necessary */
    /* g_frfmNVData.chron.chronoStack[i].ignitionCycleCounter          = 0; not necessary */
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
    g_frfmNVData.chron.chronoStack[i].envDataIndex_firstConfirmed      = 0;
#endif
#if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
    g_frfmNVData.chron.chronoStack[i].envDataIndex_mostRecent          = 0;
#endif
    g_frfmNVData.chron.chronoStackManager[i].ref                       = (t_FrfmDtcChronoRefType)i;
    /* g_frfmNVData.chron.chronoStackManager[i].dtcInternalNumber      = 0; not necessary */
  }
  /* chronoStackAddEnvIndex[kFrfmChronoStackAddEnvSize] not necessary */
  g_frfmNVData.chron.chronoStackCurrentSize        = 0;
  g_frfmNVData.chron.chronoStackAddEnvCurrentIndex = 0;

#if defined (FRFM_ENABLE_DM1_LIGHT)
  if (frfmDM1Transm_Active == g_frfmDM1TransmissionState)
  { /* currently DM1 messages are transmitted frequently */
    /* no more 'failed' DTCs in CS, change state */
    g_frfmDM1TransmissionState = frfmDM1Transm_Final;                 /* DM1State := PASSED_DTCS_ONLY */
  }
#endif
}


/*******************************************************************************
* NAME:              FrfmNvInitChronoStack
*
* CALLED BY:         Application/Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Initialization of (ChronoStack part of) NVRAM mirror memory
*                    after e.g. a firmware update.
*                    No notification about deleting the DTCs (=> status change)
*                    neither towards application nor via ResponseOnEvent.
*                    
*******************************************************************************/
void FrfmNvInitChronoStack(void)
{
  FrfmNvramMirrorIsDirty();
  /* set all data (and the padding bytes inbetween) to zero */
  FrfmMemClear(&g_frfmNVData.chron, (vuint16) sizeof(g_frfmNVData.chron));

#if defined (FRFM_ENABLE_PATTERN_CHECK)
  { /* write the pattern */
    frfmuint i;
    for(i=0; i<(frfmuint)kFrfmPatternSize; ++i)
    {
      g_frfmNVData.chron.chronoConsistencyPattern[i] = originalCSPattern[i];
    }
  }
#endif
  /*g_frfmNVData.chron.permanentFulfillIgnitionEC   = (vbittype) 0u;*/               /* default IgnitionEC Calibration: EC 2 depends on ignition signal, RQMT 7.2.2.1-11 */
  g_frfmNVData.chron.usedMultipleConfigurationIndex = g_frfmCurrConfig;
#if defined (FRFM_ENABLE_ROE_DIAGN_ACTIVATE)
  g_frfmNVData.chron.roelSendCalibration            = (vbittype) 1u;                 /* default RoE Calibration: "Send RoE-light messages", RoE-027 */
#endif

#if defined (FRFM_ENABLE_DTC_RUNTIME_CONFIG)
  { /* initialize runtime configurable values by their static defaultvalues */
    t_FrfmDtcSfnType i;
    for (i=0; i < kFrfmNumDtc; ++i)
    { /* find all DTCs, that default to "suppressed" (==1) in ROM [with the current config]...*/
      if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(i)].dtcSuppressFlag != 0)
      { /* ... and set their suppressed flag in NVRAM */
        FrfmSetBitInArray(i, g_frfmNVData.chron.runtimeConfigurableData.frfmRtDtcSuppressFlag);
      }
    }
  }
#endif

#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER) && defined (FRFM_ENABLE_NVRAM_CHG_TRIGGER)
  /* TriggerOnStatusChange suppression is handled in NVRAM. Default value: don't suppress RoE/DM1 message */ 
  /* nothing to do here: default value 0 is already set by above FrfmMemClear() call */
  /* FrfmMemClear(&g_frfmNVData.chron.suppressTrOnEvFlag, (vuint16) sizeof(g_frfmNVData.chron.suppressTrOnEvFlag)); */
#endif

#if defined (FRFM_ENABLE_DB_TRUCK_FEATURES)
  g_frfmNVData.chron.selfHealingLevel2Cycles        = (vuint8) 100u;                 /* default self healing cycles for 'self_healing_level_2', DM1075 */
  g_frfmNVData.chron.selfHealingLevel3Cycles        = (vuint8) 100u;                 /* default self healing cycles for 'self_healing_level_3', DM1075 */
#endif

  FrfmClearChronoStack(frfmFalse);           /* don't notify application of status changes */
}


/*******************************************************************************
* NAME:              FrfmInitPowerOn
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Initial Init function after PowerOn reset.
*                    This function will clear the NVRAM mirror, so copy the
*                    NVRAM data to g_frfmNVData *after* calling this function
*                    and *before* calling FrfmPowerUp().
*
*******************************************************************************/
#if (kFrfmNumConfigs > 1)
void FrfmInitPowerOn(t_FrfmNumConfigs selectedConfig)
#else
void FrfmInitPowerOn(void)
#endif
{
  g_frfmInitializationStatus      = storageUninitialized;
  g_frfmECx                       = 0x00 |                /* EC 5 := False (0x01) RQMT 7.2.2.1-23 */
                                    0x00 |                /* EC 6 := False  (0x04) RQMT 7.2.2.1-26 */
                                    0x08 |                /* EC 7 := True   (0x08) RQMT 7.2.2.1-28 */
                                    0x10;                 /* EC 8 := True   (0x10) RQMT 7.2.2.1-30 */

  g_frfmFilterType            = kFrfmCSListOfIdentified;
  g_frfmLock.location         = frfmLL_None;
  g_frfmIdxOfFilteredDtc      = 0;
  FrfmMemClear(&g_frfmFilter, (vuint16) sizeof(g_frfmFilter));
  g_frfmCurrentExtendedRecord = 0;
#if defined (FRFM_NVDATA_SIZE_ADJUST)
  FrfmAssert((FRFM_NVDATA_SIZE_ADJUST == sizeof(g_frfmNVData)), kFrfmAssertCompilerBugSizeof);
#endif

  FrfmMemClear(&g_frfmNVData, (vuint16) sizeof(g_frfmNVData));
#if (kFrfmNumConfigs > 1)
  FrfmAssert((selectedConfig <= (t_FrfmNumConfigs)(kFrfmNumConfigs-1)), kFrfmAssertIllegalMultiConfig);
  g_frfmCurrConfig                = selectedConfig;
#endif

#if defined (FRFM_ENABLE_ROE_LIGHT)
  FrfmRoelInitErrFifo();
#endif
#if defined (FRFM_ENABLE_DM1_LIGHT)
  FrfmDM1InitPowerOn();
#endif

#if defined (FRFM_ENABLE_MON_VOLTAGE)
  /* the voltage monitors assume correct voltage range (state:=0) until they will receive the first measured voltage value */ 
  FrfmMemClear(&g_frfmVoltageMonitorSM, (vuint16) sizeof(g_frfmVoltageMonitorSM));
#endif

#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER) && !defined (FRFM_ENABLE_NVRAM_CHG_TRIGGER)
  /* TriggerOnStatusChange suppression is handled in RAM. Default value: don't suppress RoE/DM1 message */ 
  FrfmMemClear(&g_frfmSuppressTrOnEvFlag, (vuint16) sizeof(g_frfmSuppressTrOnEvFlag));
#endif

  FrfmReinitPowerCycle();
}


/*******************************************************************************
* NAME:              FrfmTask
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Periodic function.
*                    
*******************************************************************************/
void FrfmTask(void)
{
  if (g_frfmInitializationStatus == storageInitialized)
  {
    if (g_frfmTimerDeBounceECNwComm > 1)
    { /* de-bounce timer Network Communication is active and running */
      --g_frfmTimerDeBounceECNwComm;
    }
    if (g_frfmTimerDeBounceECPowerDistr > 1)
    { /* de-bounce timer Power Distribution is active and running */
      --g_frfmTimerDeBounceECPowerDistr;
    }
    if (g_frfmTimerIgnitionTimer > 1)
    {
      g_frfmTimerIgnitionTimer--;
      /* decrement only to 1, to not reload this timer until a new ignition cycle has started */
      if (g_frfmTimerIgnitionTimer == 1)
      {
        t_FrfmDtcChronoRefType chronoStackManagerIndex = 0;
        /* start a new ignition cycle */
#if defined (FRFM_ENABLE_IGNCYC_RESETS_TEST)
# if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
        {
          t_FrfmDtcSfnType i;

          FrfmNvramMirrorIsDirty();
          for (i=0; i<kFrfmNumDtc; i++)
          { /* reset 'bTestNotCompletedThisOperationCycle' to 1 at the beginning of a new ignition cycle */
            g_frfmDtcStatusByte[i].s.bTestNotCompletedThisOperationCycle = 1;
          }
        }
# endif
#endif

        while (chronoStackManagerIndex<g_frfmNVData.chron.chronoStackCurrentSize)
        {
          t_FrfmChronoStackManager lCStackManager;
          lCStackManager = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex];

          if ((g_frfmNVData.chron.chronoStack[lCStackManager.ref].ignitionCycleCounter != 0) &&
              (g_frfmNVData.chron.chronoStack[lCStackManager.ref].ignitionCycleCounter < 0xff))   /* RQMT 7.3.5.3-9 */
          {
            FrfmNvramMirrorIsDirty();
            g_frfmNVData.chron.chronoStack[lCStackManager.ref].ignitionCycleCounter++;
            /*check self-healing*/
            {
#if defined (FRFM_ENABLE_DB_TRUCK_FEATURES)
              vuint8 selfHealingLevel   = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(lCStackManager.dtcInternalNumber)].dtcSelfHealingLevel;
              vuint8 selfHealingCounter = 0;
              if (selfHealingLevel == 2)
              {
                selfHealingCounter = g_frfmNVData.chron.selfHealingLevel2Cycles;
              }
              else if (selfHealingLevel == 3)
              {
                selfHealingCounter = g_frfmNVData.chron.selfHealingLevel3Cycles;
              }
              if ((selfHealingLevel > 1)                                                                                /* DM985: don't heal 'self_healing_level_1', heal level_2 and _3 only */
                && (selfHealingCounter <= g_frfmNVData.chron.chronoStack[lCStackManager.ref].ignitionCycleCounter)      /* required cycle count reached ? */
# if defined (FRFM_ENABLE_DTC_PRIORITY_SUPPORT)
                && (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(lCStackManager.dtcInternalNumber)].dtcPriorityValue != 0x01)  /* never heal DTCs with prio 1 */
# endif
                )
#else
              if ((g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(lCStackManager.dtcInternalNumber)].dtcSelfHealingCounter <= g_frfmNVData.chron.chronoStack[lCStackManager.ref].ignitionCycleCounter)
# if defined (FRFM_ENABLE_DTC_PRIORITY_SUPPORT)
                && (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(lCStackManager.dtcInternalNumber)].dtcPriorityValue != 0x01)
# endif
                )
#endif
              { /* DTC has to be self healed*/
                if ((g_frfmLock.location != frfmLL_ChronoStack) || (g_frfmLock.dtcSfn != lCStackManager.dtcInternalNumber))
                {
                  FrfmDeleteDTCinChronoStack(chronoStackManagerIndex, frfmTrue);      /* notify status change to Application, and RoE */
                }
                else
                { /* DTC is currently locked, postpone the selfhealing to next ignition cycle */
                  if (g_frfmNVData.chron.chronoStack[lCStackManager.ref].ignitionCycleCounter == 0xff)
                  { /* value 0xff would skip further tests for selfhealing - for performance, limit healable DTCs to 0xfe here */
                    g_frfmNVData.chron.chronoStack[lCStackManager.ref].ignitionCycleCounter = 0xfe;
                  }
                  chronoStackManagerIndex++;                                          /* check next chrono stack entry */
                }
              }
              else
              {
                chronoStackManagerIndex++;
              }
            }
          }
          else
          {
            chronoStackManagerIndex++;
          }
        } /* while (all ChronoStackEntries) */
        /* new ignition cycle was started */
      }
    }
#if defined (FRFM_ENABLE_ROE_LIGHT)
    if (g_frfmRoelCycleCount > 0)
    {
      --g_frfmRoelCycleCount;
    }
    if (g_frfmRoelCycleCount == 0)
    {
      g_frfmRoelCycleCount = kFrfmRoelCycleTime / (kFrfmCallCycleUs / 1000);
      if (g_frfmRoelErrFifoElmCount > 0)
      {
        FrfmRoelSendErrFifo();
      }
    }
#endif
#if defined (FRFM_ENABLE_DM1_LIGHT)
    if (g_frfmDM1CycleCount > 0)
    { /* DM1 transmission timer is running */
      --g_frfmDM1CycleCount;
      if (g_frfmDM1CycleCount == 0)
      { /* DM1 transmission timer expires now */
        FrfmDM1Task();                                                        /* send DM1 message (and restart timer if necessary) */
      }
    }
#endif
#if defined (FRFM_ENABLE_MON_VOLTAGE)
    {
      vsint8 i;
      for (i=kFrfmNumVoltageMonitor-1; i>=0; --i)
      {
        FrfmVoltageMonitor( g_frfmVoltageMonitorSMParam[i], &g_frfmVoltageMonitorSM[i] );
      }
    }
#endif
  }
}


/*******************************************************************************
* NAME:              FrfmPowerUp
*
* CALLED BY:         Application
* PRECONDITIONS:     g_frfmNVData was filled by data stored in NVRAM
*
* DESCRIPTION:       Start a new power cycle
*                    
*******************************************************************************/
vuint8 FrfmPowerUp(void)
{
  vuint8     returnValue = kFrfmSuccess;        /* everything is fine */

  if (g_frfmInitializationStatus == storageUninitialized)
  {
    /* start the new power cycle */
    vuint8     failures = 0;
#if defined (FRFM_ENABLE_PATTERN_CHECK)
    frfmuint   i;
#endif
#if defined (FRFM_ENABLE_CONSISTENCY_CHECK)
    t_FrfmBool success;
#endif

    /* currently the NVRAM is still synchronized (but next steps might change this) */
    g_frfmNvramMirrorSyncDone = frfmTrue;
    g_frfmNvramMirrorIsDirty  = frfmFalse;


    /*
    ** validate the chronological part of the NVRAM data
    */
    failures = 0;
#if defined (FRFM_ENABLE_PATTERN_CHECK)
    /* check the pattern */
    for(i = 0; i<(frfmuint)kFrfmPatternSize; ++i)
    {
      if (g_frfmNVData.chron.chronoConsistencyPattern[i] != originalCSPattern[i])
      {
        ++failures;
        break;
      }
    }
#endif
#if defined (FRFM_ENABLE_CONSISTENCY_CHECK)
    /* check the checksum */
    success = FrfmCalculateChecksum( (vuint8*) &g_frfmNVData.chron, sizeof(g_frfmNVData.chron), g_frfmNVData.chron.chronoDataChecksum, NULL);
    if (success == frfmFalse)
    {
        ++failures;
    }
#endif
    /* initialize the CS if nvram failures or configuration changed */
    if ((failures > 0) || (g_frfmCurrConfig != g_frfmNVData.chron.usedMultipleConfigurationIndex))
    {
      FrfmNvInitChronoStack();
      /* the NvRam was inconsitent and was re-initialized */
      returnValue = kFrfmNvDataInit;
    }
    else
    {
      /*
      ** restore DTC status from NV to RAM
      */
      FrfmUnpackStatusByte();
    }

    /*
    ** initialize global, power cycle related variables
    */
    FrfmReinitPowerCycle();

    /* activate the DTC storage */
    g_frfmInitializationStatus = storageInitialized;

#if defined (FRFM_ENABLE_DM1_LIGHT)
    /* Restore the DM1 state from the DTCs in the ChronoStack before changing any DTC */
    FrfmDM1PowerUp();
#endif

    /** generate DTC event, if NVRAM was invalid or corrupt **/
#if defined (FRFM_ENABLE_MON_NVRAM_CORRUPT)
    if (returnValue == kFrfmNvDataInit)
    {
      FrfmSetEventStatus(g_frfmErrorMonitor[g_frfmCurrConfig].sfnNvramChecksum, testFailed);
    }
#endif
  }
  else
  { /* storage is already active, ignore this second FrfmPowerUp(..) and return kFrfmFailed */
    /* no new power cycle is started, as the previous didn't end yet */
    returnValue = kFrfmFailed;
  }

  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmReinitPowerCycle
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       This function reinitializes global FRFM data when starting
*                    a new power cycle.
*                    
*******************************************************************************/
static void FrfmReinitPowerCycle(void)
{
  /* reinitialize internal stored measured values */
  g_frfmLocalVoltage              = kFrfmVoltageInvalid;  /* measured */
  g_frfmSystemVoltage             = kFrfmVoltageInvalid;  /* received */
  g_frfmLocalVoltageForEC         = kFrfmVoltageInvalid;  /* RQMT 7.2.2.1-14 */
  g_frfmSystemVoltageForEC        = kFrfmVoltageInvalid;  /* RQMT 7.2.2.1-19 */

  g_frfmIgnitionStatus            = ignitionUnknown;      /* RQMT 7.2.2.1-8 */
  g_frfmIgnitionStatusLocal       = ignitionUnknown;      /* RQMT 7.2.2.1-9 */

  /* reinitialize Enable Conditions */
  g_frfmControlDTCstatus          = storageEnable;        /* RQMT 7.2.2.1-4 */
  /* reinitialize EC5 IOD-Fuse, EC6 Sub-Network Power to false, disable permament EC3 */
  g_frfmECx                       &= (vuint8)( FRFM_NEG_U8(0x01u) );  /* EC 5 := False  RQMT 7.2.2.1-23 */

  /* reset the debounce timers */
  g_frfmTimerIgnitionTimer        = 0;
  g_frfmTimerDeBounceECNwComm     = 0;
  g_frfmTimerDeBounceECPowerDistr = 0;

  /* reinitialize the DTC debounce counters */
#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
  {
    t_FrfmDtcSfnType dtcSfn;
    for (dtcSfn=0; dtcSfn<kFrfmNumDtc; ++dtcSfn)
    {
      g_frfmFaultDetectionCounter[dtcSfn] = 0;
    }
  }
#endif /*FRFM_ENABLE_DTC_DEBOUNCING*/
}


/*******************************************************************************
* NAME:              FrfmUnpackStatusByte
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       
*                    
*******************************************************************************/
static void FrfmUnpackStatusByte(void)
{
  frfmuint currentBitCount = 0;
  frfmuint i;
  for (i=0; i<(frfmuint)kFrfmNumDtc; i++)
  {
    g_frfmDtcStatusByte[i].s.bTestFailed = FrfmGetPackedStatusBit(currentBitCount);
    currentBitCount++;
#if defined (FRFM_ENABLE_TFTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    /* never stored, now set default value: not FailedThisOperationCycle */
    g_frfmDtcStatusByte[i].s.bTestFailedThisOperationCycle = 0;               /* RQMT 7.3.4.2-2 */
#endif
#if defined (FRFM_ENABLE_PREFAILED_STATUS)
    g_frfmDtcStatusByte[i].s.bPreFailed = FrfmGetPackedStatusBit(currentBitCount);
    currentBitCount++;
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    g_frfmDtcStatusByte[i].s.bPendingDTC = FrfmGetPackedStatusBit(currentBitCount);
    currentBitCount++;
#endif
    g_frfmDtcStatusByte[i].s.bConfirmedDTC = FrfmGetPackedStatusBit(currentBitCount);
    currentBitCount++;
#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
    g_frfmDtcStatusByte[i].s.bTestNotCompletedSinceLastClear = FrfmGetPackedStatusBit(currentBitCount);
    currentBitCount++;
#endif
#if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
    g_frfmDtcStatusByte[i].s.bTestFailedSinceLastClear = FrfmGetPackedStatusBit(currentBitCount);
    currentBitCount++;
#endif
# if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    /* never stored, now set default value: NotCompletedThisOperationCycle */
    g_frfmDtcStatusByte[i].s.bTestNotCompletedThisOperationCycle = 1;         /* RQMT 7.3.4.7-1 */
#endif
#if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
    g_frfmDtcStatusByte[i].s.bWarningIndicatorRequested = FrfmGetPackedStatusBit(currentBitCount);
    currentBitCount++;
#endif
  }
}

/*******************************************************************************
* NAME:              FrfmGetPackedStatusBit
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       
*                    
*******************************************************************************/
static vbittype FrfmGetPackedStatusBit(frfmuint currentBitCount)
{
  vbittype result;
  if ((g_frfmNVData.chron.dtcStatusBits[(currentBitCount / 8u)] & (vuint8)(0x01u << (currentBitCount % 8u))) != 0)
  {
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

/*******************************************************************************
* NAME:              FrfmSetPackedStatusBit
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       
*                    
*******************************************************************************/
static void FrfmSetPackedStatusBit(frfmuint currentBitCount, vbittype statusBit)
{
  /* FrfmNvramMirrorIsDirty();  is called in parent function FrfmPackStatusByte */
  g_frfmNVData.chron.dtcStatusBits[(currentBitCount / 8u)] |= (vuint8)(statusBit << (currentBitCount % 8u));
}


/*******************************************************************************
* NAME:              FrfmPackStatusByte
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       
*                    
*******************************************************************************/
static void FrfmPackStatusByte(void)
{
  frfmuint currentBitCount = 0;
  frfmuint i;

  /* FrfmNvramMirrorIsDirty();  is implicitly processed by parent function FrfmSyncNvramMirror */
  /* The container has to be cleared before writing the states */
  for (i=0; i<(frfmuint)kFrfmByteSizeOfStatusBits; i++)
  {
    g_frfmNVData.chron.dtcStatusBits[i] = 0;
  }
  for (i=0; i<(frfmuint)kFrfmNumDtc; i++)
  {
    /* bTestFailed is always stored: */
    FrfmSetPackedStatusBit(currentBitCount, g_frfmDtcStatusByte[i].s.bTestFailed);
    currentBitCount++;
    /*
    ** g_frfmDtcStatusByte[i].s.bTestFailedThisOperationCycle not necessary
    */
#if defined (FRFM_ENABLE_PREFAILED_STATUS)
    FrfmSetPackedStatusBit(currentBitCount, g_frfmDtcStatusByte[i].s.bPreFailed);
    currentBitCount++;
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    FrfmSetPackedStatusBit(currentBitCount, g_frfmDtcStatusByte[i].s.bPendingDTC);
    currentBitCount++;
#endif
    /* bConfirmedDTC is always stored: */
    FrfmSetPackedStatusBit(currentBitCount, g_frfmDtcStatusByte[i].s.bConfirmedDTC);
    currentBitCount++;
#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
    FrfmSetPackedStatusBit(currentBitCount, g_frfmDtcStatusByte[i].s.bTestNotCompletedSinceLastClear);
    currentBitCount++;
#endif
#if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
    FrfmSetPackedStatusBit(currentBitCount, g_frfmDtcStatusByte[i].s.bTestFailedSinceLastClear);
    currentBitCount++;
#endif
    /*
    ** g_frfmDtcStatusByte[i].s.bTestNotCompletedThisOperationCycle not necessary
    */
#if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
    FrfmSetPackedStatusBit(currentBitCount, g_frfmDtcStatusByte[i].s.bWarningIndicatorRequested);
    currentBitCount++;
#endif
  }
}


/*******************************************************************************
* NAME:              FrfmPowerDown
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       End the current power cycle, prepare internal NVRAM mirror
*                    for copying (later) to NVRAM by an external NVRAM-Manager.
*                    
*******************************************************************************/
void FrfmPowerDown(void)
{
  /* de-activate the DTC storage */
  g_frfmInitializationStatus = storageUninitialized;

#if defined (FRFM_ENABLE_PENDINGDTC_STATUS)
  {
    frfmuint i;
    /* reset pending bit after completing an operation cycle during which
    ** the test completed and a malfunction was not detected, RQMT 7.3.4.3-2 */
    for (i=0; i<(frfmuint)kFrfmNumDtc; i++)
    {
      if ( (g_frfmDtcStatusByte[i].s.bTestNotCompletedThisOperationCycle == 0)
        && (g_frfmDtcStatusByte[i].s.bTestFailedThisOperationCycle == 0) )
      {
        g_frfmDtcStatusByte[i].s.bPendingDTC = 0;
      }
    }
  }
#endif

  /* make the nvram mirror consistent */
  (void) FrfmSyncNvramMirror();
}

/*******************************************************************************
* NAME:              FrfmSyncNvramMirror
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Trigger the synchronization of the NVRAM-Mirror by
*                    application. The FRFM stores its internal data in the
*                    global struct g_frfmNVData that is filled by an external
*                    NVRAM handler between calling FrfmInitPowerOn() and 
*                    FrfmPowerUp().
*                    If this function call was successful, the application can
*                    store the NVRAM-Mirror to e.g. flash memory and must call
*                    afterwards FrfmIsNvramMirrorSynchronized() with a
*                    returncode := frfmTrue. With returncode := frfmFalse the
*                    flash memory is most likely inconsistent.
*
*******************************************************************************/
t_FrfmBool FrfmSyncNvramMirror(void)
{
  t_FrfmBool result;

  g_frfmNvramMirrorSyncDone = frfmFalse;
  g_frfmNvramMirrorIsDirty  = frfmFalse;

  /* pack the DTC status */
  FrfmPackStatusByte();

#if defined (FRFM_ENABLE_CONSISTENCY_CHECK)
  (void) FrfmCalculateChecksum((vuint8*)&g_frfmNVData.chron, sizeof(g_frfmNVData.chron), g_frfmNVData.chron.chronoDataChecksum, &g_frfmNVData.chron.chronoDataChecksum);
#endif

  if (g_frfmNvramMirrorIsDirty == frfmFalse)
  {
    g_frfmNvramMirrorSyncDone = frfmTrue;
    result = frfmTrue;    /* success */
  }
  else
  {
    result = frfmFalse;   /* failure during sync, try again later */
  }
  return result;
}

/*******************************************************************************
* NAME:              FrfmIsNvramMirrorSynchronized
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Check, if the NVRAM-Mirror is still synchronized i.e. its
*                    content is unmodified since the last time the function
*                    FrfmSyncNvramMirror() was called.
*                    
*******************************************************************************/
t_FrfmBool FrfmIsNvramMirrorSynchronized(void)
{
  t_FrfmBool result = frfmFalse;
  if (g_frfmNvramMirrorSyncDone == frfmTrue)
  {
    if (g_frfmNvramMirrorIsDirty == frfmFalse)
    {
      result = frfmTrue;
    }
  }
  return result;
}


#if defined (FRFM_ENABLE_CONSISTENCY_CHECK)
/*******************************************************************************
* NAME:              FrfmCalculateChecksum
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Calculate checksum over nv data
*                    
*******************************************************************************/
static t_FrfmBool FrfmCalculateChecksum(vuint8 const * const dataPtr,     /* t_FrfmNonVolatileData const * const dataPtr */
                                        frfmuint const         dataSize,    /* sizeof(t_FrfmNonVolatileData) */
                                        t_checksum const     oldChecksum, /* dataPtr->consistencyCheckValue */
                                        t_checksum *         newChecksum)
{
  frfmuint     iter     = dataSize;
  t_checksum   checksum = 1;
  vuint8 const *data    = dataPtr;
  t_FrfmBool   returnValue = frfmFalse;

  /* nullify the existing checksum (as it's part of the data) */
  checksum = checksum - (t_checksum)FrfmGetHiByte(oldChecksum);
  checksum = checksum - (t_checksum)FrfmGetLoByte(oldChecksum);
  /* build new checksum (incl. field oldChecksum) */
  for ( ; iter > 0u; --iter)
  {
    checksum = checksum + (t_checksum)(*data);
    ++data;
  }
  /* test, if the oldChecksum is correct */
  if (oldChecksum == checksum)
  {
    returnValue = frfmTrue;
  }
  /* write new checksum (if requested) */
  if (newChecksum != NULL)
  {
    *newChecksum = checksum;
  }

  return returnValue;
}
#endif


/*******************************************************************************
*
* NAME:              FrfmRoelInitErrFifo 
*                     
* CALLED BY:         internal (FrfmInitPowerOn)
* PRECONDITIONS:     none
*
* PARAMETER:         none
* RETURN VALUE:      none
* DESCRIPTION:       Initialize all FIFO entries with zero.
*                    Set read, write pointer and element count to zero.
*******************************************************************************/
static void FrfmRoelInitErrFifo(void)
{
  vuint8 loop;

  /* initialize elements */
  for (loop = 0; loop < kFrfmRoelNumFifoElmts; ++loop)
  {
    g_frfmRoelErrFifo[loop].roelDtcSfn = kFrfmInvalidDtc;
  }
  g_frfmRoelErrFifoRdToken  = 0; /* init. read  pointer */
  g_frfmRoelErrFifoWrToken  = 0; /* init. write pointer */
  g_frfmRoelErrFifoElmCount = 0; /* init. element count */

  g_frfmRoelCycleCount = -1;  /* don't start cycle yet */

#if defined (FRFM_ENABLE_ROE_LIGHT_MOST)
  g_frfmRoelRunning = frfmFalse;
#endif
}



/*******************************************************************************
*
* NAME:              FrfmRoelWriteErrFifo 
*                     
* CALLED BY:         internal (FrfmRoelNotifyStatusChange) 
* PRECONDITIONS:     must initialized
*
* PARAMETER:         pointer to one FIFO entry (containing dtcSfn)
* RETURN VALUE:      kFrfmRoelOk         if the entry is successful written to the FIFO.
*                    kFrfmRoelElmExists  if the status of an existing entry is successful
*                                        overwritten.
*                    kFrfmRoelFifoFull   if the FIFO is full and the entry is not written.
* DESCRIPTION:       Write one new fifo entry if possible or update the status 
*                    of an already existing entry with the same DtcNo.
*                    If the sending of RoE-messages is deactivated, no new RoEs are added
*                    to the fifo.
*******************************************************************************/
static vuint8 FrfmRoelWriteErrFifo(t_FrfmRoelErrFifo const * const pRoelErrFifo)
{
  vuint8 loop = 0;
  vuint8 elm  = g_frfmRoelErrFifoRdToken;

#if defined (FRFM_ENABLE_ROE_DIAGN_ACTIVATE)
  if (g_frfmNVData.chron.roelSendCalibration != (vbittype) 0u)
#endif
  { /* Sending of RoE-light messages was NOT deactivated by diagn. request */
    /* Check if element (dtc) already exists in FIFO                */
    /* Start from the actual read position if the FIFO is not empty */
    while (loop < g_frfmRoelErrFifoElmCount) {
      if (g_frfmRoelErrFifo[elm].roelDtcSfn == pRoelErrFifo->roelDtcSfn)
      {
        /* Element already exists */
        return kFrfmRoelElmExists;
      }
      /* next entry position */
      if (elm == (kFrfmRoelNumFifoElmts - 1))
      {
        elm = 0;
      }
      else
      {
        ++elm;
      }
      ++loop; /* next entry */
    }

    if (g_frfmRoelErrFifoElmCount >= kFrfmRoelNumFifoElmts)
    {
      /* write failed -> FIFO is full */
      return kFrfmRoelFifoFull;
    }

    else
    {
      /* write one new entry */
      g_frfmRoelErrFifo[g_frfmRoelErrFifoWrToken].roelDtcSfn = pRoelErrFifo->roelDtcSfn;

      /* set new write token */
      if (g_frfmRoelErrFifoWrToken == (kFrfmRoelNumFifoElmts - 1))
      {
        g_frfmRoelErrFifoWrToken = 0;
      }
      else
      {
        ++g_frfmRoelErrFifoWrToken;
      }
      /* increment number of fifo entries */
      ++g_frfmRoelErrFifoElmCount;
    }
    if ( g_frfmRoelCycleCount < 0 )  /* send immediately, if very first RoE since RoelInitErrFifo */
    {
#if defined (FRFM_ENABLE_ROE_LIGHT_MOST)
      if (frfmTrue == g_frfmRoelRunning)
      { /* send only if MOST notification already arrived */
        g_frfmRoelCycleCount = (kFrfmRoelCycleTime / (kFrfmCallCycleUs / 1000));
        FrfmRoelSendErrFifo();
      }
#else
      g_frfmRoelCycleCount = (kFrfmRoelCycleTime / (kFrfmCallCycleUs / 1000)) + 10;
      FrfmRoelSendErrFifo();
#endif
    }
  }
  /* else: sending of RoE-messages suppressed, don't put new one into FIFO */

  /* new FIFO entry successful written */
  return kFrfmRoelOk;
}



/*******************************************************************************
*
* NAME:              FrfmRoelReadErrFifo 
*                     
* CALLED BY:         internal (FrfmRoelSendErrFifo)
* PRECONDITIONS:     must be initialized
*
* PARAMETER:         pointer to one FIFO entry (containing internal SFN)
* RETURN VALUE:      kFrfmRoelOk         if the entry is successful read from the FIFO.
*                    kFrfmRoelFifoEmpty  if the FIFO is empty.
* DESCRIPTION:       Read the oldest fifo entry if at least one is available.
*******************************************************************************/
static vuint8 FrfmRoelReadErrFifo(t_FrfmRoelErrFifo *pRoelErrFifo)
{
  vuint8 returnValue;

  if (g_frfmRoelErrFifoElmCount == 0)
  {
    /* read failed -> FIFO is empty */
    returnValue = kFrfmRoelFifoEmpty;
  }

  else
  {
    /* read one entry */
    pRoelErrFifo->roelDtcSfn = g_frfmRoelErrFifo[g_frfmRoelErrFifoRdToken].roelDtcSfn;

    /* set new read token */
    if (g_frfmRoelErrFifoRdToken == (kFrfmRoelNumFifoElmts - 1))
    {
      g_frfmRoelErrFifoRdToken = 0;
    }
    else
    {
      ++g_frfmRoelErrFifoRdToken;
    }
    /* decrement number of fifo entries */
    --g_frfmRoelErrFifoElmCount;

    /* FIFO entry successful read */
    returnValue = kFrfmRoelOk;
  }
  return returnValue;
}

#if defined( FRFM_ENABLE_ROE_LIGHT_MOST )
#else
/*******************************************************************************
*
* NAME:              FrfmRoelConfirmation 
*                     
* CALLED BY:         interaction layer
* PRECONDITIONS:     one message successful sent
*
* PARAMETER:         none
* RETURN VALUE:      none
* DESCRIPTION:       Is called after one message is sent successfully to the bus
*                    and tries to send the next message if available. 
*******************************************************************************/
void FrfmRoelConfirmation(void)
{
  /* (re-)sync with dbkom send cycle (offset -50ms)*/
  g_frfmRoelCycleCount = (kFrfmRoelCycleTime / (kFrfmCallCycleUs / 1000)) - 5;
}
#endif

#if defined (FRFM_ENABLE_ROE_DIAGN_ACTIVATE)
/*******************************************************************************
* NAME:              FrfmRoelSetActiveState 
*                     
* CALLED BY:         diagnostic layer or application
* PRECONDITIONS:     
*
* DESCRIPTION:       switch on/off sending of RoE-light messages and clean FIFO
*                    (discard all existing messages in the FIFO for sending RoEs)
*                    
*******************************************************************************/
void FrfmRoelSetActiveState(t_FrfmBool activateRoelMessages)
{
  if (g_frfmInitializationStatus == storageInitialized)
  {
    g_frfmNVData.chron.roelSendCalibration = (vbittype) ((activateRoelMessages == frfmFalse) ? 0u : 1u);
    /* clear the FIFO */
    g_frfmRoelErrFifoRdToken  = 0; /* init. read  pointer */
    g_frfmRoelErrFifoWrToken  = 0; /* init. write pointer */
    g_frfmRoelErrFifoElmCount = 0; /* init. element count */
  }
}


/*******************************************************************************
* NAME:              FrfmRoelGetActiveState 
*                     
* CALLED BY:         diagnostic layer or application
* PRECONDITIONS:     
*
* DESCRIPTION:       get current configuration status of 'send RoE-light messages'
*                    
*******************************************************************************/
t_FrfmBool FrfmRoelGetActiveState(void)
{
  return (t_FrfmBool)((g_frfmNVData.chron.roelSendCalibration == 0u) ? frfmFalse : frfmTrue);
}
#endif /*FRFM_ENABLE_ROE_DIAGN_ACTIVATE*/



/* ******************************************************************************
*
* NAME:              FrfmRoelSendErrFifo 
*
* CALLED BY:         internal (FrfmRoelWriteErrFifo, FrfmTask)
* PRECONDITIONS:     none
*
* PARAMETER:         none
* RETURN VALUE:      none
* DESCRIPTION:       Send the oldest fifo entry, if at least one is available,  to the bus.
****************************************************************************** */
static void FrfmRoelSendErrFifo(void)
{
  t_FrfmRoelMessageBuffer myMsg;
  t_FrfmRoelErrFifo RoelErrFifo;
  vuint8 resultValue;
  resultValue = FrfmRoelReadErrFifo(&RoelErrFifo);
  if(resultValue == kFrfmRoelOk)
  {
    t_FrfmDtcNumType dtcNum;
    dtcNum = FrfmGetDtcNum(RoelErrFifo.roelDtcSfn);
    /* PCI */
    myMsg.c[0] = 0x07;
    /* SID */
    myMsg.c[1] = 0x59;
    /* Report Most Recent Confirmed DTC */
    myMsg.c[2] = 0x0E;
    myMsg.c[3] = FrfmGetDTCStatusAvailab_Mask();
    myMsg.c[4] = FrfmGetHiLoByte(dtcNum);
    myMsg.c[5] = FrfmGetLoHiByte(dtcNum);
    myMsg.c[6] = FrfmGetLoLoByte(dtcNum);
    myMsg.c[7] = FrfmGetStatusByte(RoelErrFifo.roelDtcSfn);
    dbkPutTxSD_RS_EPS(FRFM_ROEL_SEND_BUFFER(myMsg));
  }
}


/*******************************************************************************
* NAME:              FrfmRoelNotifyStatusChange
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       This function notifies a DTC status change to RoE-Light
*                    if the trigger conditions (MBN-10399 2007-03) are fulfilled. (UDS)
*                    
*******************************************************************************/
static void FrfmRoelNotifyStatusChange(t_FrfmDtcSfnType dtcSfn, t_FrfmDtcStatusByte oldStatus, t_FrfmDtcStatusByte newStatus)
{
  /* check for status changes to notify */
  if ((oldStatus.s.bTestFailed   != newStatus.s.bTestFailed)                  /*RoE-054, RoE-055*/
#if defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    ||(oldStatus.s.bPendingDTC   != newStatus.s.bPendingDTC)                  /*RoE-056, RoE-057*/
#endif
    ||(oldStatus.s.bConfirmedDTC != newStatus.s.bConfirmedDTC)                /*RoE-058, RoE-059*/
    )
  {
    t_FrfmRoelErrFifo RoelErrFifoElem;

    RoelErrFifoElem.roelDtcSfn = dtcSfn;
    (void) FrfmRoelWriteErrFifo (&RoelErrFifoElem);                         /* write into FIFO   */
  }
}


/*******************************************************************************
* NAME:              FrfmDebounceEventFailed
*
* CALLED BY:         Application
* REENTRANCY:        Not, yet
*
* DESCRIPTION:       Service for debouncing the "testFailed" Event/Failure status 
*                    to the FRFM. This service shall be used by the application
*                    to report the Failed Status from a monitoring function as 
*                    soon as a new test result is available.
*                    This API is an alternative (and extension) to function call
*                    FrfmSetEventStatus(dtcSfn, monitorPreFailed) by supporting
*                    a user configurable step size.
*                    stepSize:=0 will use the preconfigured step size
*******************************************************************************/
void FrfmDebounceEventFailed(t_FrfmDtcSfnType dtcSfn, vuint8 stepSize)
{
  vsint16 newDetectCtr;
  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);
  
  if (g_frfmInitializationStatus == storageInitialized)
  { /* check enable conditions */
    t_FrfmBool enable = FrfmCheckOfEnableCond(dtcSfn);
    if (enable == frfmTrue)                                                             /* RQMT 7.2.2.2-5  RQMT 7.2.2.3-3 */
    {
      newDetectCtr = g_frfmFaultDetectionCounter[dtcSfn];
#if defined (FRFM_ENABLE_REENTRANCY)
      g_frfmChronoStackConsistency = 0;
#endif

      if (stepSize == 0)
      {
        stepSize = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].dtcMaturationStepSize;
      }
#if defined (FRFM_ENABLE_DTC_MATUR_JUMPZERO)
      if (newDetectCtr < 0)
      { /* jump-to-zero before start the maturing */
        newDetectCtr = 0;
      }
#endif
      /* add the mature step size */
      newDetectCtr = (vsint16)(newDetectCtr + stepSize);
      /* limit the max value of fault detection counter to +127 */
      if (newDetectCtr >= 127)
      { /* and set testFailed to the event if limit is reached/exceeded */
        newDetectCtr = 127;
        FrfmInternalSetEventStatus(dtcSfn, testFailed);
      }

      /* store the current value of the fault detection counter */
      g_frfmFaultDetectionCounter[dtcSfn] = (vsint8) newDetectCtr;

#if defined (FRFM_ENABLE_REENTRANCY)
      if (g_frfmChronoStackConsistency != 0)
      {
        /* Nested FrfmSetEvent */
      }
      else
      {
        g_frfmChronoStackConsistency = 1;
      }
#endif
    }
  }
}


/*******************************************************************************
* NAME:              FrfmDebounceEventPassed
*
* CALLED BY:         Application
* REENTRANCY:        Not, yet
*
* DESCRIPTION:       Service for debouncing the "testPassed" Event/Failure status 
*                    to the FRFM. This service shall be used by the application
*                    to report the Passed Status from a monitoring function as 
*                    soon as a new test result is available.
*                    This API is an alternative (and extension) to function call
*                    FrfmSetEventStatus(dtcSfn, monitorPrePassed) by supporting
*                    a user configurable step size.
*                    stepSize:=0 will use the preconfigured step size
*******************************************************************************/
void FrfmDebounceEventPassed(t_FrfmDtcSfnType dtcSfn, vuint8 stepSize)
{
  vsint16 newDetectCtr;
  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);

  if (g_frfmInitializationStatus == storageInitialized)
  { /* check enable conditions */
    t_FrfmBool enable = FrfmCheckOfEnableCond(dtcSfn);
    if (enable == frfmTrue)                                                             /* RQMT 7.2.2.2-5  RQMT 7.2.2.3-3 */
    {
      newDetectCtr = g_frfmFaultDetectionCounter[dtcSfn];
#if defined (FRFM_ENABLE_REENTRANCY)
      g_frfmChronoStackConsistency = 0;
#endif

      if (stepSize == 0)
      {
        stepSize = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].dtcDematurationStepSize;
      }
#if defined (FRFM_ENABLE_DTC_DEMAT_JUMPZERO)
      if (newDetectCtr > 0)
      { /* jump-to-zero before start the de-maturing */
        newDetectCtr = 0;
      }
#endif
      /* subtract the de-mature step size */
      newDetectCtr = (vsint16)(newDetectCtr - stepSize);
      /* limit the min value of fault detection counter to -127 */
      if (newDetectCtr <= -127)
      { /* and set testPassed to the event if limit is reached/exceeded */
        newDetectCtr = -127;
        FrfmInternalSetEventStatus(dtcSfn, testPassed);
      }

      /* store the current value of the fault detection counter */
      g_frfmFaultDetectionCounter[dtcSfn] = (vsint8) newDetectCtr;

#if defined (FRFM_ENABLE_REENTRANCY)
      if (g_frfmChronoStackConsistency != 0)
      {
        /* Nested FrfmSetEvent */
      }
      else
      {
        g_frfmChronoStackConsistency = 1;
      }
#endif
    }
  }
}


/*******************************************************************************
* NAME:              FrfmInternalEventDebounce
*
* CALLED BY:         FRFM
* REENTRANCY:        Not yet
*
* DESCRIPTION:       Common function for event debouncing implementation (SetEvent).
*                    The eventStatus will (conditionally) be manupulated:
*                       monitorPreFailed =?=> testFailed
*                       monitorPrePassed =?=> testPassed
*                    
*******************************************************************************/
static void FrfmInternalEventDebounce(const t_FrfmDtcSfnType dtcSfn, t_FrfmSetEventStatus *eventStatus)
{
  vsint16 newDetectCtr = g_frfmFaultDetectionCounter[dtcSfn];
  switch (*eventStatus)
  {
  case testFailed:
    newDetectCtr = 127;
    break;
  case testPassed:
    newDetectCtr = -127;
    break;
  case monitorPreFailed:
#if defined (FRFM_ENABLE_DTC_MATUR_JUMPZERO)
    if (newDetectCtr < 0)
    { /* jump-to-zero before start the maturing */
      newDetectCtr = 0;
    }
#endif
    /* add the mature step size */
    newDetectCtr = newDetectCtr + (vsint16) g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].dtcMaturationStepSize;
    /* limit the max value of fault detection counter to +127 ... */
    if (newDetectCtr >= 127)
    { /* .. and modify status: monitorPreFailed =?=> testFailed to set the event */
      *eventStatus = testFailed;
      newDetectCtr = 127;
    }
    break;
  case monitorPrePassed:
#if defined (FRFM_ENABLE_DTC_DEMAT_JUMPZERO)
    if (newDetectCtr > 0)
    { /* jump-to-zero before start the de-maturing */
      newDetectCtr = 0;
    }
#endif
    /* subtract the de-mature step size */
    newDetectCtr = newDetectCtr - (vsint16) g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].dtcDematurationStepSize;
    /* limit the min value of fault detection counter to -127 ... */
    if (newDetectCtr <= -127)
    { /* ... and modify status: monitorPrePassed =?=> testPassed to (re)set the event */
      *eventStatus = testPassed;
      newDetectCtr = -127;
    }
    break;
  default:
    /* ignore other eventStatus, as not relevant for de-bouncing */
    break;
  }

  /* store the current value of the fault detection counter */
  g_frfmFaultDetectionCounter[dtcSfn] = (vsint8) newDetectCtr;
}


/*******************************************************************************
* NAME:              FrfmGetFaultDetectionCounter
*
* CALLED BY:         Application/Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       Service for retrieving the DTC specific fault detection
*                    counter, that is used to debounce events.
*                    
*******************************************************************************/
vsint8 FrfmGetFaultDetectionCounter(t_FrfmDtcSfnType dtcSfn)
{
  vsint8 counter;

  FrfmAssert((g_frfmInitializationStatus == storageInitialized), kFrfmAssertZeroNonVolatileDatPtr);
  FrfmAssert((dtcSfn<kFrfmNumDtc), kFrfmAssertIllegalSfn);
  FrfmAssert((FrfmIsValidMultiConfigSfn(dtcSfn)), kFrfmAssertIllegalSfnInMultiCfg);

  counter = g_frfmFaultDetectionCounter[dtcSfn];
  return counter;
}



/*******************************************************************************
* NAME:              FrfmIsDtcBlockedByMutExclMatrix
*
* CALLED BY:         FRFM
* REENTRANCY:        Not, yet
*
* DESCRIPTION:       Internal function for checking the mutual exclusion matrix
*                    result:  frfmTrue  if one DTC in the mutual exclusion list
*                                       is in status "testFailed"
*                             frfmFalse if none is "testFailed"
*******************************************************************************/
static t_FrfmBool FrfmIsDtcBlockedByMutExclMatrix(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmBool returnValue = frfmFalse;
  t_FrfmDtcMutualExclusionRef listStart;
  t_FrfmMutualListLength      listSize;

  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);
  FrfmAssert((FrfmIsValidMultiConfigSfn(dtcSfn)), kFrfmAssertIllegalSfnInMultiCfg);

  /* Get first element and size of the list */
  listStart = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].mutualDtcListIndex;
  listSize  = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].mutualDtcListLength;

  /* iterate over all DTCs in the list */
  for ( ; listSize > 0; --listSize, ++listStart)
  { /* 'listStart' always addresses the DTC-to-check */
    t_FrfmDtcSfnType mutualDtcSfn = g_frfmMutualExclusionMatrix[listStart];
    /* if that DTC is "testFailed" we have found a blocking entry */
    if (g_frfmDtcStatusByte[mutualDtcSfn].s.bTestFailed == 1)
    { /* DTC 'mutualDtcSfn' is "testFailed", one blocking point found */
      returnValue = frfmTrue;
      break;                                /* abort further scan */
    }
  }

  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmSetEventStatus
*
* CALLED BY:         Application
* REENTRANCY:        Not, yet
*
* DESCRIPTION:       Service for reporting the Event/Failure status to the FRFM. 
*                    This service shall be used by the application to report 
*                    the Event Status from a monitoring function as soon as 
*                    a new test result is available.
*                    
*******************************************************************************/
void FrfmSetEventStatus(t_FrfmDtcSfnType dtcSfn, t_FrfmSetEventStatus eventStatus)
{
#if defined (FRFM_ENABLE_REENTRANCY)
  g_frfmChronoStackConsistency = 0;
#endif
  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);

  if ((g_frfmInitializationStatus == storageInitialized)
    && FrfmIsValidMultiConfigSfn(dtcSfn))
  {
    /* check enable conditions */
    t_FrfmBool enable = FrfmCheckOfEnableCond(dtcSfn);
    if (enable == frfmTrue)                                         /* RQMT 7.2.2.2-5  RQMT 7.2.2.3-3 */
    {
#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
      FrfmInternalEventDebounce(dtcSfn, &eventStatus);
      /* the eventStatus is modified, if debouncing leads to active/non-active event */
#endif

      FrfmInternalSetEventStatus(dtcSfn, eventStatus);
    }

#if defined (FRFM_ENABLE_REENTRANCY)
    if (g_frfmChronoStackConsistency != 0)
    {
      /* Nested FrfmSetEvent */
    }
    else
    {
      g_frfmChronoStackConsistency = 1;
    }
#endif
  }
}


/*******************************************************************************
* NAME:              FrfmInternalSetEventStatus
*
* CALLED BY:         FRFM
* REENTRANCY:        Not, yet
*
* DESCRIPTION:       Internal function for status change implementation (SetEvent)
*                    
*******************************************************************************/
static void FrfmInternalSetEventStatus(t_FrfmDtcSfnType dtcSfn, t_FrfmSetEventStatus eventStatus)
{
  /* make a local copy of current status byte */
  t_FrfmDtcStatusByte oldStatus;
  oldStatus = FrfmNarrowDownSupportedStatus(g_frfmDtcStatusByte[dtcSfn]);
  CDD_DemIdSnapshot_Cnt_G_u8 = dtcSfn;
  switch (eventStatus)
  {
  case testFailed:
#if defined (FRFM_ENABLE_DTC_MUTUALEXCLUSION)
    /* skip DTCs that are contained in the mutual exclusion list */
    if (FrfmIsDtcBlockedByMutExclMatrix(dtcSfn) == frfmFalse)
#endif
    {
      /* is the DTC already stored? */
      if (g_frfmDtcStatusByte[dtcSfn].s.bConfirmedDTC == 0)
      { /* DTC is not stored - can the DTC be stored in the Chrono-stack (not suppressed)? */
        if (FrfmIsSfnNotSuppressed(dtcSfn))
        {
          FrfmAddNewDTCtoChronoStack(dtcSfn);
#if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
          g_frfmDtcStatusByte[dtcSfn].s.bTestFailedSinceLastClear = 1;
#endif
        }
      }
      else
      { /* DTC is already stored - is it still active? */
        if (g_frfmDtcStatusByte[dtcSfn].s.bTestFailed == 0)
        { /* stored - not active */
          FrfmUpdateDTCinCS_NotActiveToActive(dtcSfn);
        }
      }
      g_frfmDtcStatusByte[dtcSfn].s.bTestFailed = 1;
#if defined (FRFM_ENABLE_TFTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
      g_frfmDtcStatusByte[dtcSfn].s.bTestFailedThisOperationCycle = 1;
#endif
#if defined (FRFM_ENABLE_PREFAILED_STATUS)
      g_frfmDtcStatusByte[dtcSfn].s.bPreFailed = 0;
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
      g_frfmDtcStatusByte[dtcSfn].s.bPendingDTC = 1;
#endif
#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
      g_frfmDtcStatusByte[dtcSfn].s.bTestNotCompletedSinceLastClear = 0;
#endif
#if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
      g_frfmDtcStatusByte[dtcSfn].s.bTestNotCompletedThisOperationCycle = 0;
#endif
    }
    break;

  case testPassed:
    if ((g_frfmDtcStatusByte[dtcSfn].s.bConfirmedDTC == 1) &&
      (g_frfmDtcStatusByte[dtcSfn].s.bTestFailed == 1))
    {
      FrfmUpdateDTCinCS_ActiveToNotActive(dtcSfn);
    }
    g_frfmDtcStatusByte[dtcSfn].s.bTestFailed = 0;
#if defined (FRFM_ENABLE_PREFAILED_STATUS)
    g_frfmDtcStatusByte[dtcSfn].s.bPreFailed = 0;
#endif
#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
    g_frfmDtcStatusByte[dtcSfn].s.bTestNotCompletedSinceLastClear = 0;
#endif
#if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
    g_frfmDtcStatusByte[dtcSfn].s.bTestNotCompletedThisOperationCycle = 0;
#endif
    break;

#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
  case monitorPreFailed:
  case monitorPrePassed:
    /* NOOP for debounced status */
    break;
#endif /*FRFM_ENABLE_DTC_DEBOUNCING*/

  default:
    break;
  }
  
  /* check if DTC status changed since last lines of code */
  if (oldStatus.c !=  g_frfmDtcStatusByte[dtcSfn].c)
  { /* there is a change - notify application */
    t_FrfmDtcStatusByte newStatus;
    FrfmNvramMirrorIsDirty();

#if defined (FRFM_ENABLE_ROE_LIGHT)
# if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
    if ( ! FrfmIsTriggerOnEventSuppressed(dtcSfn) )
# endif
    {
      FrfmRoelNotifyStatusChange(dtcSfn, oldStatus, g_frfmDtcStatusByte[dtcSfn]);
    }
#endif
#if defined (FRFM_ENABLE_DM1_LIGHT)
# if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
    if ( ! FrfmIsTriggerOnEventSuppressed(dtcSfn) )
# endif
    {
      FrfmDM1NotifyStatusChange(dtcSfn, g_frfmDtcStatusByte[dtcSfn]);
    }
#endif

    newStatus = FrfmNarrowDownSupportedStatus(g_frfmDtcStatusByte[dtcSfn]);
    if (oldStatus.c != newStatus.c)
    { /* the change is with user configured status bits (and not with only internally required bits) */
      ApplFrfmOnDtcStatusChange(g_frfmDtcNumTable[dtcSfn], oldStatus, newStatus);
    }
  }
}



/*******************************************************************************
* NAME:              FrfmAddNewDTCtoChronoStack
*
* CALLED BY:         Internal
* REENTRANCY:        Not
*
* DESCRIPTION:       will add a DTC to the Chrono-stack
*                    
*******************************************************************************/
static void FrfmAddNewDTCtoChronoStack(t_FrfmDtcSfnType dtcSfn)
{
  /* Use always 16bit for the case stackSize > 127 entries */
  t_FrfmDtcChronoRefType chronoStackManagerIndex;
  t_FrfmOdometer l_frfmOdometer;
  t_FrfmDtcChronoRefType chronoStackIndexRef;
#if defined (FRFM_ENABLE_DTC_PRIORITY_SUPPORT)
  vuint8  ldtcPriorityValue;
#endif
#if (defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA) || defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA))
  vuint8  returnValue;
#endif
  t_FrfmBool success = frfmTrue;

  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);

  /* Set index to the last/oldest element of the stack */
  chronoStackManagerIndex = 0;
  if (g_frfmNVData.chron.chronoStackCurrentSize == kFrfmChronoStackSize)
  { /* Chrono-stack is full */
    t_FrfmDtcSfnType sfn;
#if defined (FRFM_ENABLE_DTC_PRIORITY_SUPPORT)
    vuint8 storedPriority;
    /* If priority support is active, search a element which fits the filter criteria */
    ldtcPriorityValue = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].dtcPriorityValue;
    /* Start searching the lower(equal) prio beginning at the oldest entry */
    for ( ; chronoStackManagerIndex < kFrfmChronoStackSize; ++chronoStackManagerIndex)
    {
      sfn = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].dtcInternalNumber;
      storedPriority = g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(sfn)].dtcPriorityValue;
      if ((storedPriority != 1) && (storedPriority >= ldtcPriorityValue))
      { /* prio in chronostack is same or lower (=higher number) than prio of new entry */
        if ( ((storedPriority > ldtcPriorityValue) ||                                   /* lower prio */
              (g_frfmDtcStatusByte[sfn].s.bTestFailed == 0) )                           /* same prio, stored not active */
          && ((g_frfmLock.location != frfmLL_ChronoStack) || (g_frfmLock.dtcSfn != sfn)))  /* no current read access */
        { break; }           /* found DTC according RQMT 7.4.1.2.C-1 */
      }
      /* else: don't overwrite prio 1 DTCs in chronostack RQMT 7.4.1.1-6
         and don't overwrite higher prio DTCs in chronostack RQMT 7.4.1.2.C-1 */
    }
#else
    /* Start searching the non-active DTC beginning at the oldest entry */
    for ( ; chronoStackManagerIndex < kFrfmChronoStackSize; ++chronoStackManagerIndex)
    {
      sfn = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].dtcInternalNumber;
      if (  (g_frfmDtcStatusByte[sfn].s.bTestFailed == 0)                               /* stored not active */
        && ((g_frfmLock.location != frfmLL_ChronoStack) || (g_frfmLock.dtcSfn != sfn))) /* no current read access */
      { break; }           /* found DTC according RQMT 7.4.1.2.C-1 */
    }
#endif
    /* check if a DTC is found */
    if (chronoStackManagerIndex < kFrfmChronoStackSize)
    { /* a deletable DTC is found */
      FrfmDeleteDTCinChronoStack(chronoStackManagerIndex, frfmTrue);                    /* notify status change to Application, and RoE */
    }
    else
    {
      success = frfmFalse;
    }
  }
  else
  { /* Chrono-stack is not full */
    /* nothing to do */
  }

  if ((success == frfmTrue)
#if defined (FRFM_ENABLE_DTC_PRIORITY_SUPPORT)
  /* Due to MISRA a second check is necessary */
     && (chronoStackManagerIndex < kFrfmChronoStackSize)
#endif
     )
  {
    FrfmNvramMirrorIsDirty();
    /* get the current odometer value */
    l_frfmOdometer = ApplFrfmGetOdometerValue();
    /* set chronoStackManagerIndex to the first free element */
    chronoStackManagerIndex = g_frfmNVData.chron.chronoStackCurrentSize;

    /* store for later - to keep the reference into chronoStack consistent */
    chronoStackIndexRef = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].ref;
    /* Write new DTC number */
    g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].dtcInternalNumber = dtcSfn;

    g_frfmNVData.chron.chronoStack[chronoStackIndexRef].originalOdometer      = l_frfmOdometer; /* RQMT 7.4.1.2.A-3 */
    g_frfmNVData.chron.chronoStack[chronoStackIndexRef].mostRecentOdometer    = l_frfmOdometer; /* RQMT 7.4.1.2.A-4 */
    g_frfmNVData.chron.chronoStack[chronoStackIndexRef].frequencyCounter      = 1; /* RQMT 7.4.1.2.A-5 */
    g_frfmNVData.chron.chronoStack[chronoStackIndexRef].ignitionCycleCounter  = 0; /* RQMT 7.4.1.2.A-6 */
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
    /* add environmental data to the heap */
    /* check if environmental data exist */
    if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm != 0)
    { /* we have additional environmental data */
      /* store index into heap */
      g_frfmNVData.chron.chronoStack[chronoStackIndexRef].envDataIndex_firstConfirmed = g_frfmNVData.chron.chronoStackAddEnvCurrentIndex;
      g_frfmNVData.chron.chronoStackAddEnvCurrentIndex = (t_FrfmAddEnvIndexType)(
        g_frfmNVData.chron.chronoStackAddEnvCurrentIndex + g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm);
      /* get the environmental data from the application */
      returnValue = ApplFrfmGetAddEnvData(g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordNumber_firstConfirm,
        &(g_frfmNVData.chron.chronoStackAddEnvData[g_frfmNVData.chron.chronoStack[chronoStackIndexRef].envDataIndex_firstConfirmed]),
        g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm);
      if (returnValue == kFrfmFailed)
      {
        frfmuint i = 0;
        while (i < (frfmuint)g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm)
        {
          g_frfmNVData.chron.chronoStackAddEnvData[g_frfmNVData.chron.chronoStack[chronoStackIndexRef].envDataIndex_firstConfirmed + i] = 0xff;
          i++;
        }
      }
    }
#endif
#if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
    /* add environmental data to the heap */
    /* check if environmental data exist */
    if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent != 0)
    { /* we have additional environmental data */
      /* store index into heap */
      g_frfmNVData.chron.chronoStack[chronoStackIndexRef].envDataIndex_mostRecent = g_frfmNVData.chron.chronoStackAddEnvCurrentIndex;
      g_frfmNVData.chron.chronoStackAddEnvCurrentIndex = (t_FrfmAddEnvIndexType)(
        g_frfmNVData.chron.chronoStackAddEnvCurrentIndex + g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent);
      /* get the environmental data from the application */
      returnValue = ApplFrfmGetAddEnvData(g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordNumber_mostRecent,
        &(g_frfmNVData.chron.chronoStackAddEnvData[g_frfmNVData.chron.chronoStack[chronoStackIndexRef].envDataIndex_mostRecent]),
        g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent);
      if (returnValue == kFrfmFailed)
      {
        frfmuint i = 0;
        while (i < (frfmuint)g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent)
        {
          g_frfmNVData.chron.chronoStackAddEnvData[g_frfmNVData.chron.chronoStack[chronoStackIndexRef].envDataIndex_mostRecent + i] = 0xff;
          i++;
        }
      }
    }
#endif
    FrfmAssert((g_frfmNVData.chron.chronoStackCurrentSize < kFrfmChronoStackSize), kFrfmAssertIllegalCStackSize);
    g_frfmDtcStatusByte[dtcSfn].s.bConfirmedDTC = 1;
#if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
    /* is Warning Indicator associated with DTC */
    if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].dtcWarningIndFlag == 1)
    { /* set Warning Indicator active */
      g_frfmDtcStatusByte[dtcSfn].s.bWarningIndicatorRequested = 1;
    }
#endif
    g_frfmNVData.chron.chronoStackCurrentSize++;
  }
}



/*******************************************************************************
* NAME:              FrfmUpdateDTCinCS_NotActiveToActive
*
* CALLED BY:         Internal
* PRECONDITIONS:     The DTC must exist in the Chrono-stack
* REENTRANCY:        Not
*
* DESCRIPTION:       The DTC will be updated in the ChronoStack from the 
*                    NotActive to the Active state
*******************************************************************************/
static void FrfmUpdateDTCinCS_NotActiveToActive(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmDtcChronoRefType chronoStackManagerIndex;
  t_FrfmChronoStackManager chronoStackIndex;
#if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
  vuint8 getEnvData;
#endif
  t_FrfmOdometer l_frfmOdometer;

  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);

  if ((g_frfmLock.location != frfmLL_ChronoStack) || (g_frfmLock.dtcSfn != dtcSfn))
  {
    FrfmNvramMirrorIsDirty();
    /* search for the right element */
    chronoStackManagerIndex = FrfmGetChronoStackMgrIndex(dtcSfn);

    FrfmAssert ((chronoStackManagerIndex < g_frfmNVData.chron.chronoStackCurrentSize), kFrfmAssertDtcNotFound);

    /* we found the right element */
    chronoStackIndex = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex];

    /* go ahead in the stack and move down all entries to set this DTC on the top */
    for (; chronoStackManagerIndex < (t_FrfmDtcChronoRefType)(g_frfmNVData.chron.chronoStackCurrentSize-1); chronoStackManagerIndex++)
    {
      g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex] = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex+1];
    }
    /* store back the current DTC*/
    g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex] = chronoStackIndex;

    /* update the dynamic data */
    /* get the current odometer value */
    l_frfmOdometer = ApplFrfmGetOdometerValue();

    /* g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].originalOdometer   =;                    RQMT 7.4.1.3.A-6 */
    g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].mostRecentOdometer    = l_frfmOdometer;  /* RQMT 7.4.1.3.A-7 */
    /* latch the frequency counter (i.e. number of occurrences) at the max value */
    if (g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].frequencyCounter < 
#if defined (FRFM_ENABLE_DM1_LIGHT)
      0x7f                                                                                        /* DM307/DM1079: J1939-73 uses 7bit Occurrence Count */
#else
      0xff                                                                                        /* RQMT 7.3.5.2-4 */
#endif
      )
    {
      g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].frequencyCounter++;                    /* RQMT 7.4.1.3.A-8 */
    }
    g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].ignitionCycleCounter = 0;                /* RQMT 7.4.1.3.A-9 */
#if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
    /* update the most recent snapshot datas */
    /* check if environmental data exist */
    if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent != 0)
    { /* we have additional environmental data */
      /* get the environmental data from the application */
      getEnvData = ApplFrfmGetAddEnvData(g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordNumber_mostRecent,
        &(g_frfmNVData.chron.chronoStackAddEnvData[g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].envDataIndex_mostRecent]),
        g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent);
      if (getEnvData == kFrfmFailed)
      {
        frfmuint i = 0;
        while (i < (frfmuint)g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent)
        {
          g_frfmNVData.chron.chronoStackAddEnvData[g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].envDataIndex_mostRecent + i] = 0xff;
          i++;
        }
      }
    }
#endif
  }
  /* else: dtcSfn is locked in ChronoStack: We cannot update its chrono stack data */
}


/*******************************************************************************
* NAME:              FrfmUpdateDTCinCS_ActiveToNotActive
*
* CALLED BY:         Internal
* PRECONDITIONS:     The DTC must exist in the Chrono-stack
* REENTRANCY:        Not
*
* DESCRIPTION:       The DTC will be updated in the ChronoStack from the
*                    Active to the NotActive state
*******************************************************************************/
static void FrfmUpdateDTCinCS_ActiveToNotActive(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmDtcChronoRefType chronoStackManagerIndex;

  if ((g_frfmLock.location != frfmLL_ChronoStack) || (g_frfmLock.dtcSfn != dtcSfn))
  {
    FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);

    FrfmNvramMirrorIsDirty();

    /* search for the right element */
    chronoStackManagerIndex = FrfmGetChronoStackMgrIndex(dtcSfn);

    FrfmAssert ((chronoStackManagerIndex < g_frfmNVData.chron.chronoStackCurrentSize), kFrfmAssertDtcNotFound);
    /* we found the right element */
    /* update the dynamic data */
    /* g_frfmNVData.chron.chronoStack[g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].ref].originalOdometer      =;   RQMT 7.4.1.3.B-3 */
    /* g_frfmNVData.chron.chronoStack[g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].ref].mostRecentOdometer    =;   RQMT 7.4.1.3.B-4 */
    /* g_frfmNVData.chron.chronoStack[g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].ref].frequencyCounter      =;   RQMT 7.4.1.3.B-5 */
    g_frfmNVData.chron.chronoStack[g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].ref].ignitionCycleCounter = 1;  /* RQMT 7.4.1.3.B-6 */
  }
  /* else: dtcSfn is locked in ChronoStack: We cannot update its chrono stack data */
}


/*******************************************************************************
* NAME:              FrfmDeleteDTCinChronoStack
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       An Chrono-Stack element will be removed from the Chrono-Stack
*                    
*******************************************************************************/
static void FrfmDeleteDTCinChronoStack(t_FrfmDtcChronoRefType chronoStackManagerIndex, t_FrfmBool triggerRoe)
{
  frfmuint i;

  t_FrfmChronoStackManager chronoStackIndex;
  t_FrfmDtcSfnType dtcSfn;
  t_FrfmDtcStatusByte oldStatus, newStatus;

  FrfmAssert((chronoStackManagerIndex < g_frfmNVData.chron.chronoStackCurrentSize), kFrfmAssertIllegalCStackReference);
  FrfmAssert((g_frfmNVData.chron.chronoStackCurrentSize > 0), kFrfmAssertErasingEmptyCStack);                         /* at least one entry must exist */
  FrfmAssert((g_frfmNVData.chron.chronoStackCurrentSize <= kFrfmChronoStackSize), kFrfmAssertIllegalCStackReference);

  FrfmNvramMirrorIsDirty();

  dtcSfn = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].dtcInternalNumber;
  /* make a local copy of current status byte */
  oldStatus = g_frfmDtcStatusByte[dtcSfn];
  /* Copy the information from the given reference */
  chronoStackIndex = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex];

  /* reset the storage bit and the warning indicator */
  g_frfmDtcStatusByte[dtcSfn].s.bConfirmedDTC = 0;
#if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
  g_frfmDtcStatusByte[dtcSfn].s.bWarningIndicatorRequested = 0;
#endif
  /* compact the stack and close the hole */
  for (i = chronoStackManagerIndex; i < (frfmuint)(g_frfmNVData.chron.chronoStackCurrentSize-1); i++)                 /* Harmless cast since the assertion checks for non zero size */
  {
    g_frfmNVData.chron.chronoStackManager[i] = g_frfmNVData.chron.chronoStackManager[i+1u];
  }
  /* store back the index - to keep the reference into chronoStack consistent */
  g_frfmNVData.chron.chronoStackManager[i] = chronoStackIndex;

#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA) || defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
  {
    vuint16 recordSize = 0;                                                                                           /* total size of FC and MR record-to-delete */
    vuint16 startOffset = 0;                                                                                          /* index into chronoStackAddEnvData[], where current record begins */
# if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
    /* check if environmental data exist */
    if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent != 0)
    { /* there is additional environmental data */
      recordSize = recordSize + g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_mostRecent;          /* size of MC record-to-delete */
      startOffset = g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].envDataIndex_mostRecent;                     /* start of current MC record */
      /* startOffset shall contain lowest address, so first check MostRecent (higher address) and then overwrite by FirstConfirmed if required */
    }
# endif
# if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
    /* check if environmental data exist */
    if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm != 0)
    { /* there is additional environmental data */
      recordSize = recordSize + g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].envDataRecordSize_firstConfirm;        /* size of FC record-to-delete */
      startOffset = g_frfmNVData.chron.chronoStack[chronoStackIndex.ref].envDataIndex_firstConfirmed;                 /* start of current FC record */
      /* startOffset shall contain lowest address, so overwrite by FirstConfirmed if required */
    }
# endif
    if (recordSize != 0)
    { /* there is additional environmental data */
      FrfmAssert((g_frfmNVData.chron.chronoStackAddEnvCurrentIndex >= recordSize), kFrfmAssertIllegalCStackReference); /* current <= total records size */
      /* delete the environmental heap */
      for (i=startOffset;                                                                                             /* copy destination starts at current record */
        i<=(frfmuint)(g_frfmNVData.chron.chronoStackAddEnvCurrentIndex - recordSize);                                 /* destination ends at last filled pos minus this record's size */
        i++)
      {
        g_frfmNVData.chron.chronoStackAddEnvData[i] = g_frfmNVData.chron.chronoStackAddEnvData[ i + recordSize ];
      }
      /* update the references of used elements in the stack, last stack element (the one being deleted) needs no update */
      for (chronoStackManagerIndex=0;
        chronoStackManagerIndex < (t_FrfmDtcChronoRefType)(g_frfmNVData.chron.chronoStackCurrentSize-1);
        ++chronoStackManagerIndex)
      {
        i = g_frfmNVData.chron.chronoStackManager[chronoStackManagerIndex].ref;                                       /* resolve indirection: chronoStackManager -> chronoStack */
# if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
        /* check for a higher index than the deleted */
        if (g_frfmNVData.chron.chronoStack[i].envDataIndex_firstConfirmed >= startOffset)
        { /* subtract the length of the deleted to all found references */
          g_frfmNVData.chron.chronoStack[i].envDataIndex_firstConfirmed =
            g_frfmNVData.chron.chronoStack[i].envDataIndex_firstConfirmed - (vuint16)recordSize;
        }
# endif
# if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
        if (g_frfmNVData.chron.chronoStack[i].envDataIndex_mostRecent >= startOffset)
        { /* subtract the length of the deleted to all found references */
          g_frfmNVData.chron.chronoStack[i].envDataIndex_mostRecent =
            g_frfmNVData.chron.chronoStack[i].envDataIndex_mostRecent - (vuint16)recordSize;
        }
# endif
      }
      /* adjust current heap size */
      g_frfmNVData.chron.chronoStackAddEnvCurrentIndex = (t_FrfmAddEnvIndexType)(g_frfmNVData.chron.chronoStackAddEnvCurrentIndex - recordSize);
    }
  }
#endif  /*defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA) || defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)*/

  g_frfmNVData.chron.chronoStackCurrentSize--;

  /* sending RoE is not required when e.g. DTCs are deleted from diagnostic request */
  if (triggerRoe != frfmFalse)
  {
#if defined (FRFM_ENABLE_ROE_LIGHT)
# if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
    if ( ! FrfmIsTriggerOnEventSuppressed(dtcSfn) )
# endif
    {
      FrfmRoelNotifyStatusChange(dtcSfn, oldStatus, g_frfmDtcStatusByte[dtcSfn]);
    }
#endif
  }
#if defined (FRFM_ENABLE_DM1_LIGHT)
# if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
  if ( ! FrfmIsTriggerOnEventSuppressed(dtcSfn) )
# endif
  {
    FrfmDM1NotifyStatusChange(dtcSfn, g_frfmDtcStatusByte[dtcSfn]);
  }
#endif
  oldStatus = FrfmNarrowDownSupportedStatus(oldStatus);
  newStatus = FrfmNarrowDownSupportedStatus(g_frfmDtcStatusByte[dtcSfn]);
  /* there is a change in the status byte - notify application */
  ApplFrfmOnDtcStatusChange(g_frfmDtcNumTable[dtcSfn], oldStatus, newStatus);
}


/*******************************************************************************
* NAME:              FrfmGetEventStatus
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Service for retrieving the status of a specific event/failure 
*                    from the FRFM. This function can be used by the application 
*                    to get the current state of a specific failure and then perform 
*                    the required limp-home operation.
*                    
*******************************************************************************/
t_FrfmGetEventStatus FrfmGetEventStatus(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmGetEventStatus returnCode;

  FrfmAssert((g_frfmInitializationStatus == storageInitialized), kFrfmAssertZeroNonVolatileDatPtr);
  FrfmAssert((dtcSfn<kFrfmNumDtc), kFrfmAssertIllegalSfn);
  FrfmAssert((FrfmIsValidMultiConfigSfn(dtcSfn)), kFrfmAssertIllegalSfnInMultiCfg);

  returnCode = g_frfmDtcStatusByte[dtcSfn].s;
  return returnCode;
}


#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
/*******************************************************************************
* NAME:              FrfmSuppressTriggerOnStatusChg
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The sending of RoE/DM1 message can be suppressed for a given DTC
*                    by this function. Dependent on the GENy setting, the status is
*                    either stored in RAM (reinitialized to "don't suppress" with next
*                    FrfmInitPowerOn() call) or in NVRAM (default "don't suppress" is
*                    set with corrupted NVRAM via FrfmNvInitChronoStack() call).
*                    If the adjustment is stored in NVRAM, the function will
*                    fail before FrfmPowerUp() and after FrfmPowerDown() and
*                    return in this case the value frfmFalse.
*                    The adjustable DTCs/SFNs are NOT limited to the current config
*                    but changing the config will invalidate the NVRAM, thus reset the
*                    defaults.
*                    Note: if the suppression is switched 'off' (0), a DTC typically will
*                    need an additional status transition 'passed'->'failed', before its
*                    RoE/DM1 message will be transmitted again.
*******************************************************************************/
t_FrfmBool FrfmSuppressTriggerOnStatusChg(const t_FrfmDtcSfnType dtcSfn, const vuint8 newSuppressFlag)
{
  t_FrfmBool returnValue = frfmFalse;

# if defined (FRFM_ENABLE_NVRAM_CHG_TRIGGER)
  /* reject change in NVRAM, if the FRFM is de-activated */
  if ( (g_frfmInitializationStatus == storageInitialized)
    && (dtcSfn < kFrfmNumDtc) )
  {
    if (newSuppressFlag == 0)
    { /* new setting: don't suppress (0) the trigger on status change */
      if ( FrfmIsBitSetInArray(dtcSfn, g_frfmNVData.chron.suppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag) )
      { /* old state differs from new setting: change bit 1->0 */
        FrfmNvramMirrorIsDirty();
        FrfmClearBitInArray(dtcSfn, g_frfmNVData.chron.suppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag);
      }
    }
    else
    { /* new setting: suppress (1) the trigger on status change */
      if ( FrfmIsBitClearedInArray(dtcSfn, g_frfmNVData.chron.suppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag) )
      { /* old state differs from new setting: change bit 0->1 */
        FrfmNvramMirrorIsDirty();
        FrfmSetBitInArray(dtcSfn, g_frfmNVData.chron.suppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag);
      }
    }

    returnValue = frfmTrue;
  }
# else  /*FRFM_ENABLE_NVRAM_CHG_TRIGGER*/
  if (dtcSfn < kFrfmNumDtc)
  {
    if (newSuppressFlag == 0)
    {
      FrfmClearBitInArray(dtcSfn, g_frfmSuppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag);
    }
    else
    {
      FrfmSetBitInArray(dtcSfn, g_frfmSuppressTrOnEvFlag.frfmRtSuppressTrOnEvFlag);
    }

    returnValue = frfmTrue;
  }
# endif  /*FRFM_ENABLE_NVRAM_CHG_TRIGGER*/

  return returnValue;
}
#endif  /*FRFM_ENABLE_NO_STAT_CHG_TRIGGER*/


/*******************************************************************************
* NAME:              FrfmServiceSetDtcSuppressFlag
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The DTC suppressed flags can be adjusted by this function.
*                    As the adjustment is stored in NVRAM, the function will
*                    fail before FrfmPowerUp() and after FrfmPowerDown() and
*                    return in this case the value frfmFalse.
*                    The adjustable DTCs are NOT limited to the current config
*                    but changing the config will reset the flags to their 
*                    ROM default.
*******************************************************************************/
t_FrfmBool FrfmServiceSetDtcSuppressFlag(const t_FrfmDtcNumType reqDtc, const vuint8 newSuppressFlag)
{
  t_FrfmBool returnValue = frfmFalse;

#if defined (FRFM_ENABLE_DTC_RUNTIME_CONFIG)
  /* reject calibration change if the DTC storage is de-activated */
  if (g_frfmInitializationStatus == storageInitialized)
  {
    if (reqDtc == (t_FrfmDtcNumType) 0xFFFFFFu)
    { /* all DTCs */
      frfmuint  i;
      FrfmNvramMirrorIsDirty();
      for (i=0; i<sizeof(g_frfmNVData.chron.runtimeConfigurableData.frfmRtDtcSuppressFlag); ++i)
      {
        g_frfmNVData.chron.runtimeConfigurableData.frfmRtDtcSuppressFlag[i] = (vuint8) ((newSuppressFlag==0) ? 0x00u : 0xFFu);
      }
      returnValue = frfmTrue;
    }
    else
    { /* one single DTC */
      t_FrfmDtcSfnType dtcSfn;
      dtcSfn = FrfmGetSfn(reqDtc);        /* get sfn number independent of current config */
      if (dtcSfn != kFrfmInvalidDtc)
      {
        FrfmNvramMirrorIsDirty();
        if (newSuppressFlag == 0)
        {
          FrfmClearBitInArray(dtcSfn, g_frfmNVData.chron.runtimeConfigurableData.frfmRtDtcSuppressFlag);
        }
        else
        {
          FrfmSetBitInArray(dtcSfn, g_frfmNVData.chron.runtimeConfigurableData.frfmRtDtcSuppressFlag);
        }
        returnValue = frfmTrue;
      }
    }
  }
#endif /* FRFM_ENABLE_DTC_RUNTIME_CONFIG */

  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmSetIgnitionStatus
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application has to set the current ignition state
*                    
*******************************************************************************/
void FrfmSetIgnitionStatus(t_FrfmIgnitionState ignitionState)
{
  /* memorize previous state */
  t_FrfmIgnitionState oldIgnitionState = g_frfmIgnitionStatus;
  g_frfmIgnitionStatus = ignitionState;                                                 /* set the new state */

  /* debouncing of ignition cycle */
  switch(ignitionState)
  {
  case ignitionOff:
    /* reset ignition cycle timer counter, to recognize a new ignition cycle */
    g_frfmTimerIgnitionTimer = 0;
    break;
  case ignitionAccessory:
    break;
  case ignitionRun:
    if (g_frfmTimerIgnitionTimer == 0)
    { /* load ignition cycle de-bounce timer, new ignition cycle starts when timer expires */
      g_frfmTimerIgnitionTimer = (kFrfmIgnitionCycleDelay / (kFrfmCallCycleUs / 1000)) + 1;
    }
    break;
  case engineStart:
    break;
  default:
    break;
  }

  /* debouncing of enable condition "Ignition Status" EC 2 */
  if (oldIgnitionState != ignitionState)
  { /* do de-bounce checks on value change only */
    FrfmEvalNWCommDebounceTimer();
    FrfmEvalPowerDistrDebounceTimer();
  }
}

/*******************************************************************************
* NAME:              FrfmSetLocalIgnitionStatus
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Notify the FRFM with the locally measured ignition state
*                    
*******************************************************************************/
void FrfmSetLocalIgnitionStatus(t_FrfmIgnitionState ignitionState)
{
  /* preserve local measured value */
  g_frfmIgnitionStatusLocal = ignitionState;

  if ((g_frfmIgnitionStatus == ignitionUnknown)                                         /* RQMT 7.2.2.1-6 no bus measured ignition available */
    || ((g_frfmECx & 0x08) == 0))                                                       /* RQMT 7.2.2.1-7 Bus Physical status failed (EC 7) */
  {                                           
    FrfmSetIgnitionStatus(ignitionState);
  }
}

/*******************************************************************************
* NAME:              FrfmSetBusReceivedIgnitionStatus
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Notify the FRFM with the bus received ignition state
*                    'ignitionUnknown' signals an received invalid status
*
*******************************************************************************/
void FrfmSetBusReceivedIgnitionStatus(t_FrfmIgnitionState ignitionState)
{
  if (ignitionState == ignitionUnknown)
  { /* no valid bus measured value available */ 
    if (g_frfmIgnitionStatusLocal != ignitionUnknown)
    { /* local measured value available, use instead */                                 /* RQMT 7.2.2.1-7 */
      FrfmSetIgnitionStatus(g_frfmIgnitionStatusLocal);
    }
    /* else: keep previous setting */                                                   /* RQMT 7.2.2.1-8 */
  }
  else
  { /* valid bus received ignition status */
    FrfmSetIgnitionStatus(ignitionState);                                               /* RQMT 7.2.2.1-6 */
  }
}


/*******************************************************************************
* NAME:              FrfmPermanentFulfullIgnitionEC
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The enable condition  EC 2 Ignition Status
*                    can be adjusted by this function for battery powered ECUs.
*
*                    With parameter 'permanent:=frfmFalse' the EC 2 depends on
*                    the actual ignition state. This is the default.
*                    With parameter 'permanent:=frfmTrue' the EC 2 is always
*                    fulfilled and no more dependent of the ignition state
*                    (see FrfmSetIgnitionStatus() and CS-11736/RQMT 7.2.2.1-11).
*
*                    The setting is stored in non-volatile memory.
*                    
*******************************************************************************/
t_FrfmBool FrfmPermanentFulfullIgnitionEC(t_FrfmBool permanent)
{
  t_FrfmBool result = frfmFalse;
  if (g_frfmInitializationStatus == storageInitialized)
  {
    vbittype  permanentFulfill;
    permanentFulfill = (vbittype)((permanent == frfmFalse) ? 0 : 1);

    if (g_frfmNVData.chron.permanentFulfillIgnitionEC != permanentFulfill)
    {
      g_frfmNVData.chron.permanentFulfillIgnitionEC = permanentFulfill;
      FrfmEvalNWCommDebounceTimer();
      FrfmEvalPowerDistrDebounceTimer();

      result = frfmTrue;
    }
  }
  /* else:
  * the FRFM is in non-operable state (after FrfmInitPowerOn or after FrfmPowerDown and 
  * before FrfmPowerUp). Changing the StorageState would always be successful, but of
  * course in this case we neither start the debounce timers nor is the setting kept 
  * after the next FrfmPowerUp(), so changing it here is meaningless. We return 'unsuccessful'.
  */
  return result;
}


/*******************************************************************************
* NAME:              FrfmSetLocalVoltage
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application notifies the FRFM about local voltage 
*                    change.
*******************************************************************************/
void FrfmSetLocalVoltage(t_FrfmVoltage localMeasuredVoltage)
{
  if (kFrfmVoltageInvalid != localMeasuredVoltage)
  {
    g_frfmLocalVoltage = localMeasuredVoltage;                                          /* RQMT 7.2.2.1-12, preserve measured valid voltage for monitors */
  }
  else
  { /* find a substitution for invalid measured voltage */
    if (kFrfmVoltageInvalid != g_frfmSystemVoltage)
    {
      localMeasuredVoltage = g_frfmSystemVoltage;                                       /* RQMT 7.2.2.1-13 use received valid SysVoltg as replacement */
    }
    else if (kFrfmVoltageInvalid != g_frfmLocalVoltage)
    {
      localMeasuredVoltage = g_frfmLocalVoltage;                                        /* RQMT 7.2.2.1-14 use last measured valid LocVoltg as replacement */
    }
    /* else: no substitution found, use kFrfmVoltageInvalid as value */
  }

  /* no de-bounce check as no EC 9 timer depends on local voltage (any more) */

  g_frfmLocalVoltageForEC = localMeasuredVoltage;                                       /* store new local voltage (used for EnableConditions) */
}

/*******************************************************************************
* NAME:              FrfmSetSystemVoltage
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application notifies the FRFM about system voltage 
*                    change.
*******************************************************************************/
void FrfmSetSystemVoltage(t_FrfmVoltage busReceivedVoltage)
{
  if (kFrfmVoltageInvalid != busReceivedVoltage)
  {
    g_frfmSystemVoltage = busReceivedVoltage;                                           /* RQMT 7.2.2.1-17, preserve received valid voltage for monitors */
  }
  else
  { /* find a substitution for invalid received voltage */
    if (kFrfmVoltageInvalid != g_frfmLocalVoltage)
    {
      busReceivedVoltage = g_frfmLocalVoltage;                                          /* RQMT 7.2.2.1-18 use measured valid LocVoltg as replacement */
    }
    else if (kFrfmVoltageInvalid != g_frfmSystemVoltage)
    {
      busReceivedVoltage = g_frfmSystemVoltage;                                         /* RQMT 7.2.2.1-19 use last received valid SysVoltg as replacement */
    }
    /* else: no substitution found, use kFrfmVoltageInvalid as value */
  }

  if (g_frfmSystemVoltageForEC != busReceivedVoltage)
  {
    g_frfmSystemVoltageForEC = busReceivedVoltage;                                      /* store new system voltage (used for EnableConditions) */
    /* do de-bounce check on value change only */
    FrfmEvalNWCommDebounceTimer();
  }
}

/*******************************************************************************
* NAME:              FrfmSetIodFuseState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application notifies the FRFM about the current IOD
*                    fuse state
*                    valid states: frfmIODFuseStateIn
*                                  frfmIODFuseStateOut
*                                  frfmIODFuseStateUnknown
*******************************************************************************/
void FrfmSetIodFuseState(t_FrfmIODFuseState newState)
{
  if (newState == frfmIODFuseStateIn)
  {
    FrfmSetIodFuseEnableCond(frfmTrue);
  }
  else if (newState == frfmIODFuseStateOut)
  {
    FrfmSetIodFuseEnableCond(frfmFalse);
  }
  else
  {
    /* MISRA Rule 60 needs this empty statement */
  }
}

/*******************************************************************************
* NAME:              FrfmSetIodFuseEnableCond
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application notifies the FRFM about enable condition 
*                    change (EC 5)
*******************************************************************************/
void FrfmSetIodFuseEnableCond(t_FrfmBool newState)
{
  t_FrfmBool oldState = (t_FrfmBool)( ((g_frfmECx & 0x01)!=0) ? frfmTrue : frfmFalse ); /* Memorize old state */
  if (newState == frfmTrue)
  {
    g_frfmECx |= 0x01;                                                                  /* RQMT 7.2.2.1-22  fuse state is "in" */
  }
  else
  {
    g_frfmECx &= (vuint8) FRFM_NEG_U8(0x01u);                                           /* RQMT 7.2.2.1-22  fuse state is "out" */
  }

  /* do de-bounce check on value change only */
  if (oldState != newState)
  {
    FrfmEvalNWCommDebounceTimer();
  }
}

/*******************************************************************************
* NAME:              FrfmSetNwConfigEnableCond
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application notifies the FRFM about enable condition change
*                    (EC 6)
*******************************************************************************/
void FrfmSetNwConfigEnableCond(t_FrfmBool newState)
{
  t_FrfmBool oldState = (t_FrfmBool)( ((g_frfmECx & 0x04)!=0) ? frfmTrue : frfmFalse ); /* Memorize old state */
  if (newState == frfmTrue)
  {
    g_frfmECx |= 0x04;                                                                  /* RQMT 7.2.2.1-26 */
  }
  else
  {
    g_frfmECx &= (vuint8) FRFM_NEG_U8(0x04u);
  }

  /* do de-bounce check on value change only */
  if (oldState != newState)
  {
    FrfmEvalNWCommDebounceTimer();
  }
}

/*******************************************************************************
* NAME:              FrfmSetBusPhysicEnableCond
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application notifies the FRFM about enable condition change
*                    (EC 7)
*******************************************************************************/
void FrfmSetBusPhysicEnableCond(t_FrfmBool newState)
{
  t_FrfmBool oldState = (t_FrfmBool)( ((g_frfmECx & 0x08)!=0) ? frfmTrue : frfmFalse ); /* Memorize old state */
  if (newState == frfmTrue)
  {
    g_frfmECx |= 0x08;                                                                  /* RQMT 7.2.2.1-28 */
  }
  else
  {
    g_frfmECx &= (vuint8) FRFM_NEG_U8(0x08u);
  }

  /* do de-bounce check on value change only */
  if (oldState != newState)
  {
    FrfmEvalNWCommDebounceTimer();
  }
}

/*******************************************************************************
* NAME:              FrfmSetIODevConfEnableCond
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The application notifies the FRFM about enable condition change
*                    (EC 8)
*******************************************************************************/
void FrfmSetIODevConfEnableCond(t_FrfmBool newState)
{
  if (newState == frfmTrue)
  {
    g_frfmECx |= 0x10;                                                                  /* RQMT 7.2.2.1-29 */
  }
  else
  {
    g_frfmECx &= (vuint8) FRFM_NEG_U8(0x10u);
  }
}


/*******************************************************************************
* NAME:              FrfmEvalNWCommDebounceTimer
*
* CALLED BY:         internal
* PRECONDITIONS:     
*
* DESCRIPTION:       check the Network Communication conditions and restart 
*                    de-bounce timer if necessary
*                    
*******************************************************************************/
static void FrfmEvalNWCommDebounceTimer(void)
{
  t_FrfmBool returnValue;
  returnValue = FrfmCheckECGroupNwCommunication();

  if (returnValue == frfmTrue)
  { /* ALL combined level specific ECs are met  RQMT 7.2.2.1-34 */
    if (g_frfmTimerDeBounceECNwComm > 0)
    { /* Timer is already running or finished: nothing to do */
    }
    else
    { /* Timer was stopped: Restart de-bounce timer */
      g_frfmTimerDeBounceECNwComm = (kFrfmDebounceNetworkComDelay / (kFrfmCallCycleUs / 1000) ) + 1;
    }
  }
  else
  { /* Any enable condition is not fulfilled: stop de-bounce timer (and disable storage)  RQMT 7.2.2.1-32 */
    g_frfmTimerDeBounceECNwComm = 0;
  }
}

/*******************************************************************************
* NAME:              FrfmEvalPowerDistrDebounceTimer
*
* CALLED BY:         internal
* PRECONDITIONS:     
*
* DESCRIPTION:       check the Power Distribution conditions and restart 
*                    de-bounce timer if necessary
*                    
*******************************************************************************/
static void FrfmEvalPowerDistrDebounceTimer(void)
{
  t_FrfmBool returnValue;
  returnValue = FrfmCheckECGroupPowerDistrib();

  if (returnValue == frfmTrue)
  { /* ALL combined level specific ECs are met  RQMT 7.2.2.1-34 */
    if (g_frfmTimerDeBounceECPowerDistr > 0)
    { /* Timer is already running or finished: nothing to do */
    }
    else
    { /* Timer was stopped: Restart de-bounce timer */
      g_frfmTimerDeBounceECPowerDistr = (kFrfmDebouncePowerDistrDelay / (kFrfmCallCycleUs / 1000) ) + 1;
    }
  }
  else
  { /* Any enable condition is not fulfilled: stop de-bounce timer (and disable storage)  RQMT 7.2.2.1-32 */
    g_frfmTimerDeBounceECPowerDistr = 0;
  }
}


/*******************************************************************************
* NAME:              FrfmCheckOfEnableCond
*
* CALLED BY:         Internal 
* PRECONDITIONS:     
*
* DESCRIPTION:       Checks enable conditions for specified DTC (dtcSfn)
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfEnableCond(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmBool returnValue = frfmFalse;

  switch (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(dtcSfn)].dtcEnableConditionGroup)
  {
    case 0u:         /*EnableConditionGroup: ECU Level*/
      returnValue  = FrfmCheckECGroupEcuLevel();          /* EC 1,3,8 */
      break;
    case 1u:         /*EnableConditionGroup: Network Commmunication*/
      returnValue  = FrfmCheckECGroupNwCommunication();   /* EC 1,2,4,5,6,7 */
      returnValue &= FrfmCheckOfNWDebounceEnableCond();   /* EC 9-NW */    
      break;
    case 2u:         /*EnableConditionGroup: Power Distribution*/
      returnValue  = FrfmCheckECGroupPowerDistrib();      /* EC 1,2  */
      returnValue &= FrfmCheckOfPDDebounceEnableCond();   /* EC 9-PD */    
      break;
    case 6u:         /*EnableConditionGroup: No Check*/
      returnValue  = FrfmCheckECGroupNone();              /* EC 1 */
      break;
    default:
      /* this line should never be reached */
      FrfmAssertUnconditional(kFrfmAssertIllegalEnablCondGroup);
  }

#if defined (FRFM_ENABLE_APPL_ENABLECOND)
  returnValue &= ApplFrfmCheckOfApplEnableCond(dtcSfn);                     
#endif

  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmGetEnableConditions
*
* CALLED BY:         Application
* PRECONDITIONS:     Limit SFN to valid range 0..(kFrfmNumDtc-1)
*                    The SFN is restricted to the current config.
*
* DESCRIPTION:       Returns current state of EnableConditions for a given SFN.
*                    
* RETURN VALUE:      frfmTrue:  configured EnableConditions permit the storing of event.
*                    frfmFalse: EnableConditions forbid the storing of event or the
*                               requested SFN is nor available in current configuration.
*******************************************************************************/
t_FrfmBool FrfmGetEnableConditions(t_FrfmDtcSfnType dtcSfn)
{
  t_FrfmBool returnValue = frfmFalse;

  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);
  if (FrfmIsValidMultiConfigSfn(dtcSfn))
  {
    returnValue = FrfmCheckOfEnableCond(dtcSfn);
  }

  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmCheckOfStorageEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 1 DTC Setting"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfStorageEnableCond(void)
{
  t_FrfmBool returnValue = frfmFalse;

  if(g_frfmControlDTCstatus == storageEnable)
  {
    returnValue = frfmTrue;
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckOfIgnitionEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 2 Ignition Status"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfIgnitionEnableCond(void)
{
  t_FrfmBool returnValue = frfmFalse;

  /* EC IgnitionStatus will be fulfilled, if current state is "Run", or EC shall be permanently fulfilled */
  if ( (g_frfmIgnitionStatus == ignitionRun)                                            /* RQMT 7.2.2.1-10 */
    || (g_frfmNVData.chron.permanentFulfillIgnitionEC != 0) )                           /* RQMT 7.2.2.1-11 */
  {
    returnValue = frfmTrue;
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckOfLocVoltageEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 3 Local Voltage"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfLocVoltageEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;

  if ((g_frfmLocalVoltageForEC == kFrfmVoltageInvalid)                                  /* RQMT 7.2.2.1-15 */
    ||(g_frfmLocalVoltageForEC > kFrfmLocalVoltageUpperLimit)                           /* RQMT 7.2.2.1-17 */
    ||(g_frfmLocalVoltageForEC < kFrfmLocalVoltageLowerLimit))                          /* RQMT 7.2.2.1-17 */
  { /* invalid voltage or value out of range */
    returnValue = frfmFalse;
  }

  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckOfSysVoltageEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 4 System Voltage"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfSysVoltageEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;

  if ((g_frfmSystemVoltageForEC == kFrfmVoltageInvalid)                                 /* RQMT 7.2.2.1-20 */
    ||(g_frfmSystemVoltageForEC > kFrfmSystemVoltageUpperLimit)                         /* RQMT 7.2.2.1-21 */
    ||(g_frfmSystemVoltageForEC < kFrfmSystemVoltageLowerLimit))                        /* RQMT 7.2.2.1-21 */
  {
    returnValue = frfmFalse;
  }

  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckOfIodFuseEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     If the current odometer value is greater than 80km and valid
*                    (i.e. odometer > 5), the check is always fulfilled
*
* DESCRIPTION:       Check of enable condition "EC 5 IOD-Fuse Status"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfIodFuseEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;
  if ((g_frfmECx & 0x01) == 0)                                                          /* RQMT 7.2.2.1-22  RQMT 7.2.2.1-24 */
  {
    /* IOD-Fuse Status == "false" (out) */
    t_FrfmOdometer odometer = ApplFrfmGetOdometerValue();
    if (odometer <= FrfmConvertKilometer(kFrfmOdometerLimitIodFuse))
    {
      returnValue = frfmFalse;
    }
    /* else: odometer > 80km, so EC is fulfiled  RQMT 7.2.2.1-25 */
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckOfNwConfigEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 6 Network Configuration Status"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfNwConfigEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;
  if ((g_frfmECx & 0x04) == 0)                                                          /* RQMT 7.2.2.1-26 */
  {
    returnValue = frfmFalse;
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckOfBusPhysicEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 7 Bus Physical Status"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfBusPhysicEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;
  if ((g_frfmECx & 0x08) == 0)                                                          /* RQMT 7.2.2.1-28 */
  {
    returnValue = frfmFalse;
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckOfIODevConfEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 8 I/O Device Configuration Status"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfIODevConfEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;
  if ((g_frfmECx & 0x10) == 0)
  {
    returnValue = frfmFalse;
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmCheckOfNWDebounceEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 9-Debounce NW Communication Level"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfNWDebounceEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;                                                    /* RQMT 7.2.2.1-36 */

  /* g_frfmTimerDeBounceECNwComm:
   *  0: Timer stopped, storage disabled
   *  1: Timer elapsed (stopped), storage enabled
   * >1: Timer running, storage disabled
   */
  if (g_frfmTimerDeBounceECNwComm != 1)
  { /* de-bounce timer off or still running */
      returnValue = frfmFalse;                                                          /* RQMT 7.2.2.1-35 */
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmCheckOfPDDebounceEnableCond
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition "EC 9-Debounce Power Distribution Level"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckOfPDDebounceEnableCond(void)
{
  t_FrfmBool returnValue = frfmTrue;                                                    /* RQMT 7.2.2.1-36 */

  /* g_frfmTimerDeBounceECPowerDistr:
   *  0: Timer stopped, storage disabled
   *  1: Timer elapsed (stopped), storage enabled
   * >1: Timer running, storage disabled
   */
  if (g_frfmTimerDeBounceECPowerDistr != 1)
  { /* de-bounce timer off or still running */
      returnValue = frfmFalse;                                                          /* RQMT 7.2.2.1-35 */
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              FrfmCheckECGroupEcuLevel
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition category "ECU Level"
*                    
*******************************************************************************/
static t_FrfmBool FrfmCheckECGroupEcuLevel(void)
{
  t_FrfmBool returnValue;
  returnValue  = FrfmCheckOfStorageEnableCond();      /* EC 1 */
  returnValue &= FrfmCheckOfLocVoltageEnableCond();   /* EC 3 */
  returnValue &= FrfmCheckOfIODevConfEnableCond();    /* EC 8 */
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckECGroupNwCommunication
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition category "Network Communication"
*                    except for debounce timer (EC 9-NW)
*******************************************************************************/
static t_FrfmBool FrfmCheckECGroupNwCommunication(void)
{
  t_FrfmBool returnValue;
  returnValue  = FrfmCheckOfStorageEnableCond();      /* EC 1 */
  returnValue &= FrfmCheckOfIgnitionEnableCond();     /* EC 2 */
  returnValue &= FrfmCheckOfSysVoltageEnableCond();   /* EC 4 */
  returnValue &= FrfmCheckOfIodFuseEnableCond();      /* EC 5 */
  returnValue &= FrfmCheckOfNwConfigEnableCond();     /* EC 6 */
  returnValue &= FrfmCheckOfBusPhysicEnableCond();    /* EC 7 */
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckECGroupPowerDistrib
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition category "Power Distribution"
*                    except for debounce timer (EC 9-PD)
*******************************************************************************/
static t_FrfmBool FrfmCheckECGroupPowerDistrib(void)
{
  t_FrfmBool returnValue;
  returnValue  = FrfmCheckOfStorageEnableCond();      /* EC 1 */
  returnValue &= FrfmCheckOfIgnitionEnableCond();     /* EC 2 */
  return returnValue;
}

/*******************************************************************************
* NAME:              FrfmCheckECGroupNone
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       Check of enable condition category "None"
*******************************************************************************/
static t_FrfmBool FrfmCheckECGroupNone(void)
{
  return FrfmCheckOfStorageEnableCond();      /* EC 1 */
}

/*******************************************************************************
* NAME:              FrfmGetStatusByte
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       The DTC internal status byte will be converted into KWP/UDS status
*                    
*******************************************************************************/
static vuint8 FrfmGetStatusByte(t_FrfmDtcSfnType dtcSfn)
{
  vuint8 statusByte;

  FrfmAssert(dtcSfn<kFrfmNumDtc, kFrfmAssertIllegalSfn);

  statusByte = FrfmMapStatusByteIntToExt(g_frfmDtcStatusByte[dtcSfn]);

  return statusByte;
}

#if defined (FRFM_ENABLE_READINESS_GROUPS)
/*******************************************************************************
* NAME:              FrfmTestedThisOperationCycle
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reset the readiness bits of a group of DTCs
*                    If one DTC of the readiness group is locked its status
*                    is still updated.
*******************************************************************************/
void FrfmTestedThisOperationCycle(vuint8 readinessGroup)
{
  t_FrfmDtcSfnType i;

  if (g_frfmInitializationStatus == storageInitialized)
  {
    for (i=0; i<kFrfmNumDtc; i++)
    {
      if (g_frfmDtcInfoTable[FRFM_INFOTABLE_IDX(i)].dtcReadinessGroup == readinessGroup)
      {
#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
        g_frfmDtcStatusByte[i].s.bTestNotCompletedSinceLastClear     = 0;
#endif
#if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS) || defined (FRFM_ENABLE_PENDINGDTC_STATUS)
        g_frfmDtcStatusByte[i].s.bTestNotCompletedThisOperationCycle = 0;
#endif
      }
    }
  }
}
#endif

/*******************************************************************************
* NAME:              FrfmServiceSetStorageState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       The storage state can be adjusted by this function  (ControlDtcSetting)
*                    
*******************************************************************************/
t_FrfmBool FrfmServiceSetStorageState(t_FrfmStorageState storageState)
{
  t_FrfmBool result = frfmFalse;
  if (g_frfmInitializationStatus == storageInitialized)
  {
    result = frfmTrue;
    if (g_frfmControlDTCstatus != storageState)
    {
      g_frfmControlDTCstatus = storageState;
      FrfmEvalNWCommDebounceTimer();
      FrfmEvalPowerDistrDebounceTimer();
    }
  }
  /* else:
  * the FRFM is in non-operable state (after FrfmInitPowerOn or after FrfmPowerDown and 
  * before FrfmPowerUp). Changing the StorageState would always be successful, but of
  * course in this case we neither start the debounce timers nor is the setting kept 
  * after the next FrfmPowerUp(), so changing it here is meaningless. We return 'unsuccessful'.
  */
  return result;
}


/*******************************************************************************
* NAME:              FrfmMapStatusByteIntToExt
*
* CALLED BY:         FRFM/Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Convert the internal used status byte to the external form.
*                    Here: convert into UDS status byte
*                    
*******************************************************************************/
vuint8 FrfmMapStatusByteIntToExt(t_FrfmDtcStatusByte internalStatus)
{
  vuint8 statusByte;
  statusByte = internalStatus.c & FrfmGetDTCStatusAvailab_Mask();
  return statusByte;
}




