/* -----------------------------------------------------------------------------
  Filename:    desc.c
  Description: Implementation of CANdesc.
                
                Manufacturer: chrysler
                EcuDocFile:   C:\cmsynergy\My_ePWM_LWR\Chrysler_LWR_EPS_TMS570\Tools\AsrProject\GENy\EPS_PN_41_02_002_E_VV5887.65.cdd
                Variant:      Common_Diagnostics

  Generated by CANdelaGen, Mon Apr 15 13:13:44 2013
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2012 by Vctr Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vctr Informatik 
  GmbH.
  
  Vctr Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* Physical layer specific API */
#include "v_inc.h"
/* -- V_NULL Definition -- */
#if !defined(V_NULL)
# define V_NULL                                                      0
#endif

#include "desc.h"
#include "appdesc.h"

/*lint -function(exit,ApplDescFatalError)*/

#if defined(VGEN_ENABLE_DPM)
# include "dpm.h"
#endif

#if defined (DESC_ENABLE_DOBT_SUPPORT)
/* include of DOBT (Diagnostic Onboard Tester) prototypes */
# include "dobt.h"
#endif

#include "frfm.h"
#include "CDD_Data.h"


/* -----------------------------------------------------------------------------
    &&&~ Configuration switches
 ----------------------------------------------------------------------------- */

/* Default settings */
#if !defined(DESC_ENABLE_EXTERNAL_CHECK_TA) && \
    !defined(DESC_DISABLE_EXTERNAL_CHECK_TA)
# define DESC_DISABLE_EXTERNAL_CHECK_TA
#endif

#define DESC_DISABLE_MULTI_TP_CHANNEL_SUPPORT
/* By default there is need of this switch */
#if !(defined (DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION) || \
    defined (DESC_DISABLE_OEM_MH_MULTI_CALL_PROTECTION))
# define DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION
#endif

#if defined (DESC_ENABLE_PID_LIST_MODE) || \
    defined (DESC_ENABLE_SIM_PID_LIST_MODE) || \
    defined (DESC_ENABLE_PERIODIC_MODE) || \
    defined (DESC_ENABLE_ROUTINE_CONTROL_MODE) || \
    defined (DESC_ENABLE_MEMORY_BY_ADDRESS_MODE)
# define DESC_ENABLE_PROCESSING_DONE_REDIRECTOR
#else
# define DESC_DISABLE_PROCESSING_DONE_REDIRECTOR
#endif

#if (DIAG_FAULTMEMORY_VERSION < 0x0300)
# error "Available version of FRFM is too old! Required minimum version of Diag_FaultMemory (FRFM): 3.00.00"
#endif


#if ! defined (FRFM_ENABLE_REPORT_ALLSUPPORTED)
# error "To use service $19 0A you must activate the feature \"Support diagnostic service 'ReadSupportedDtc'\" in GENy component Diag_FaultMemory (FRFM)"
#endif

#if ! defined (FRFM_ENABLE_ROE_DIAGN_ACTIVATE)
# error "To use service $22 0107 you must activate the feature \"Support run-time ResponseOnEvent-Light activation\" in GENy component Diag_FaultMemory (FRFM)"
#endif

#if ! defined (FRFM_ENABLE_ROE_DIAGN_ACTIVATE)
# error "To use service $2e 0107 you must activate the feature \"Support run-time ResponseOnEvent-Light activation\" in GENy component Diag_FaultMemory (FRFM)"
#endif



/* -----------------------------------------------------------------------------
    &&&~ Preprocessor constants (defines)
 ----------------------------------------------------------------------------- */

#define DESC_MAIN_VERSION                                            0x06
#define DESC_SUB_VERSION                                             0x11
#define DESC_BUGFIX_VERSION                                          0x02
/* Compatibility for older versions */
#if !defined(VSTDLIB__COREHLL_VERSION)
# define VSTDLIB__COREHLL_VERSION                                    0x00
#endif

#if (VSTDLIB__COREHLL_VERSION >= 0x216) && \
    defined (VSTD_ENABLE_INTCTRL_HANDLING)
/* VStdLib will be used */
# define DescInterruptDisable()                                      VStdSuspendAllInterrupts()
# define DescInterruptRestore()                                      VStdResumeAllInterrupts()
#else
# define DescInterruptDisable()                                      (CanGlobalInterruptDisable())
# define DescInterruptRestore()                                      (CanGlobalInterruptRestore())
#endif

#ifndef V_BOOL_EXPR
# define V_BOOL_EXPR(exp)                                            ((DescBool)((exp)?kDescTrue:kDescFalse))
#endif

/* This magic number provides inter CANdesc generation process consistency check.All CANdesc files must have the same one. */
#define DESC_IMPLEMENTATION_MAGIC_NUMBER                             31611

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define kDescDebugPatternLen                                        2
#else
# define kDescDebugPatternLen                                        0
#endif

/* patterns for owerwrite tests */
#define kDescAssertBufferLenPattern0                                 (vuint8)0xbe
#define kDescAssertBufferLenPattern1                                 (vuint8)0xda

/* Generation consitency check */
#if (DESC_PUBLIC_INTERFACE_MAGIC_NUMBER != DESC_IMPLEMENTATION_MAGIC_NUMBER)
# error "Desc.h doesn't match the Desc.c generation time!"
#endif

#if (DESC_APPLICATION_INTERFACE_MAGIC_NUMBER != DESC_IMPLEMENTATION_MAGIC_NUMBER)
# error "AppDesc.h doesn't match the Desc.c generation time!"
#endif

#if defined(VGEN_ENABLE_VSTDLIB) || defined(V_ENABLE_VSTDLIB)
/* VStdLib is available */
#else
# error "Error in File v_cfg.h: V_ENABLE_VSTDLIB (VGEN_ENABLE_VSTDLIB) must be defined!"
#endif

#if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION) && \
    !defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION)
# error "Required switch DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION not set!"
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescTpNumContexts                                          2
#else
# define kDescTpNumContexts                                          1
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define DESC_TPCONTEXT_PARAM_TYPE_ONLY                              vuint8
# define DESC_TPCONTEXT_PARAM_TYPE_FIRST                             vuint8,
# define DESC_TPCONTEXT_PARAM_VALUE                                  tpContext
# define DESC_TPCONTEXT_PARAM_ONLY                                   tpContext
# define DESC_TPCONTEXT_PARAM_FIRST                                  tpContext,
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY                        DESC_TPCONTEXT_PARAM_TYPE_ONLY DESC_TPCONTEXT_PARAM_ONLY
# define DESC_TPCONTEXT_PARAM_DEF_LOCAL                              DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY;
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_FIRST                       DESC_TPCONTEXT_PARAM_TYPE_ONLY DESC_TPCONTEXT_PARAM_ONLY,
# define DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(contextConst)             contextConst
# define DESC_TPCONTEXT_PARAM_WRAPPER_FIRST(contextConst)            contextConst,
# define DESC_TPCONTEXT_PARAM_WRAPPER_INDEX(contextConst)            contextConst
# define DESC_TPCONTEXT_PARAM_DUMMY_USE                              DESC_IGNORE_UNREF_PARAM(DESC_TPCONTEXT_PARAM_ONLY)
#else
# define DESC_TPCONTEXT_PARAM_TYPE_ONLY                              void
# define DESC_TPCONTEXT_PARAM_TYPE_FIRST
# define DESC_TPCONTEXT_PARAM_VALUE                                  ((vuint8)0)
# define DESC_TPCONTEXT_PARAM_ONLY
# define DESC_TPCONTEXT_PARAM_FIRST
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY                        void
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_FIRST
# define DESC_TPCONTEXT_PARAM_DEF_LOCAL
# define DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(contextConst)
# define DESC_TPCONTEXT_PARAM_WRAPPER_FIRST(contextConst)
# define DESC_TPCONTEXT_PARAM_WRAPPER_INDEX(contextConst)            0
# define DESC_TPCONTEXT_PARAM_DUMMY_USE
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
# define kDescDebugNeedTpRxChannel_BusyRepReq                        1
# define kDescDebugNeedTpTxChannel_BusyRepReq                        1
#else
# define kDescDebugNeedTpRxChannel_BusyRepReq                        0
# define kDescDebugNeedTpTxChannel_BusyRepReq                        0
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescDebugNeedTpRxChannel_ParallelObd                       1
# define kDescDebugNeedTpTxChannel_ParallelObd                       1
#else
# define kDescDebugNeedTpRxChannel_ParallelObd                       0
# define kDescDebugNeedTpTxChannel_ParallelObd                       0
#endif

/* Check if TP has enough communication channels */
#define kDescNeededRxTpChannels                                      (kDescDebugNeedTpRxChannel_BusyRepReq + kDescDebugNeedTpRxChannel_ParallelObd + 1)
#define kDescNeededTxTpChannels                                      (kDescDebugNeedTpTxChannel_BusyRepReq + kDescDebugNeedTpTxChannel_ParallelObd + 1)

/* Use defaults */
/* CAN channel to TP-channel mapping */
#if !defined(kDescCan2TpChannel_0)
# define kDescCan2TpChannel_0                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_1)
# define kDescCan2TpChannel_1                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_2)
# define kDescCan2TpChannel_2                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_3)
# define kDescCan2TpChannel_3                                        kTpNoChannel
#endif

#if defined (TP_ECU_NUMBER)
# define kDescEcuNumber                                              TP_ECU_NUMBER /* Use the simple macro */
#else
# define kDescEcuNumber                                              (TP_RX_ECU_NR(0))
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescUsdtNetFuncInfPoolRef                                  (vuintx)(kTpRxChannelCount)
#else
# define kDescUsdtNetFuncInfPoolRef                                  kDescPrimContext
#endif
#define kDescUsdtNetSecInfoPool                                      (vuintx)(kDescNumContexts - 1)

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define DescGetConnectionOfContext(tpContext)                       (g_descDescConnections[tpContext])
#else
# define DescGetConnectionOfContext(tpContext)                       kDescDiagConnection
#endif

#if defined (DESC_ENABLE_DOBT_SUPPORT)
# define DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_NAME, dataPtr, dataLen) (DOBTTransmit(TP_CHANNEL_TX_PARAM_FIRST (dataPtr), (dataLen)))
#else
# define DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_NAME, dataPtr, dataLen) (TpTransmit(TP_CHANNEL_TX_PARAM_FIRST (dataPtr), (dataLen)))
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# define TP_CHANNEL_RX_PARAM_VALUE                                   TP_CHANNEL_RX_PARAM_NAME
# define TP_CHANNEL_RX_PARAM_ONLY                                    TP_CHANNEL_RX_PARAM_NAME
# define TP_CHANNEL_RX_PARAM_FIRST                                   TP_CHANNEL_RX_PARAM_NAME,

# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
#  define TP_CHANNEL_TX_PARAM_VALUE                                  TP_CHANNEL_TX_PARAM_NAME
#  define TP_CHANNEL_TX_PARAM_ONLY                                   TP_CHANNEL_TX_PARAM_NAME
#  define TP_CHANNEL_TX_PARAM_FIRST                                  TP_CHANNEL_TX_PARAM_NAME,
# else
#  if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
#   define TP_CHANNEL_TX_PARAM_VALUE                                 TP_CHANNEL_TX_PARAM_NAME
#  else
#   define TP_CHANNEL_TX_PARAM_VALUE                                 0
#  endif
#  define TP_CHANNEL_TX_PARAM_ONLY                                   TP_CHANNEL_TX_PARAM_VALUE
#  define TP_CHANNEL_TX_PARAM_FIRST                                  TP_CHANNEL_TX_PARAM_VALUE,
# endif
#else
# define TP_CHANNEL_RX_PARAM_VALUE                                   0
# define TP_CHANNEL_RX_PARAM_ONLY
# define TP_CHANNEL_RX_PARAM_FIRST
# define TP_CHANNEL_TX_PARAM_VALUE                                   0
# define TP_CHANNEL_TX_PARAM_ONLY
# define TP_CHANNEL_TX_PARAM_FIRST
# define tpTxChannel                                                 0
# define tpRxChannel                                                 0
#endif
/* check TPMC settings */
#if defined (VGEN_ENABLE_TP_ISO_MC)
# if (kTpRxChannelCount < kDescNeededRxTpChannels)
#  error "Not enough TP channels, please increase the number of Rx channels under TP Options!"
# endif

# if (kTpTxChannelCount < kDescNeededTxTpChannels)
#  error "Not enough TP channels, please increase the number of Tx channels under TP Options!"
# endif
#endif

#if defined (TP_ENABLE_EXTENDED_ADDRESSING) && !defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
# error "Extended Addressing requires the a newer version of TPMC in combination with a newer GenTool"
#endif

#if defined( DESC_ENABLE_OVERRIDE_TP_MA_CHECK)
#else
# if defined(TP_ENABLE_MULTIPLE_ADDRESSING)
#  if(defined(TP_ENABLE_MIXED_11_ADDRESSING) && \
     defined(TP_ENABLE_NORMAL_ADDRESSING))  || \
     (defined(TP_ENABLE_EXTENDED_ADDRESSING) && \
     defined(TP_ENABLE_NORMAL_ADDRESSING))
/* OK */
#  else
#   error "Not supported yet!"
#  endif
# endif
#endif

#if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) && defined (DESC_ENABLE_PARALLEL_OBD)
# error "Multi CAN workaround can not be used together with parallel OBD feature!"
#endif

/* All functions are internal - generate the static declarator. */
#define DESCNET_USDT_STATIC                                          static
/* Used for additional information about each network */
#define kDescUsdtNetInvalidDescContext                               (t_descHandle)(0xFF)

/* Current diagnostic connection status */
#define kDescDescConnectionStateIdle                                 ((vuint8)0x00)
#define kDescDescConnectionStateActive                               ((vuint8)0x01)

#if !defined (kDescNrcResponsePending)
# define kDescNrcResponsePending                                     0x78
#endif

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE)
# define kDescReadDynPidConnStateActive                              ((vuint8)(kDescDescConnectionStateActive<<kDescReadDynPidContext))
#else
# define kDescReadDynPidConnStateActive                              ((vuint8)(0))
#endif
#if defined (DESC_ENABLE_ROE_SUPPORT)
# define kDescRoeConnStateActive                                     ((vuint8)((kDescDescConnectionStateActive<<kDescRoeHelperContext) | \
                                                                     (kDescDescConnectionStateActive<<kDescRoeProcessorContext)))
#else
# define kDescRoeConnStateActive                                     ((vuint8)(0))
#endif

/* Default setting for "response on request" (phys - yes, func - no) */
#define kDescDefaultResOnReq                                         0x01

/* TP wrapper states */
#define kDescMainReception                                           0x01
#define kDescMainTransmission                                        0x02
#define kDescAddReception                                            0x03
#define kDescAddTransmission                                         0x04


/* Current transfer mode */
#define kDescTxModeIdle                                              0x00
#define kDescTxModeRegularRes                                        0x01
#define kDescTxModeSpecialRes                                        0x02
#define kDescTxModeRcrRpRes                                          0x04
#define kDescTxModePeriodicRes                                       0x08
#define kDescTxModeRoeResponder                                      0x10

/* RCR-RP response descriptor */
#define kDescForcedRcrRpIdle                                         0x00
#define kDescForcedRcrRpCharged                                      0x01

/* Use the worst case for the first frame length (nromal addressing with 6Byte payload) */
#define kDescFirstFrameDataLength                                    6

/* Single frame length calculation (needed for the CopyToCan assertion check)*/
/* The FF has one byte for TP usage more, 
* so the data for SF are with one byte more */
#define kDescSingleFrameDataLength                                   ((vuint8)(kDescFirstFrameDataLength + 1))

#define kDescNumPhysReqParallel                                      1
#define kDescNumFuncReqContexts                                      0
#define kDescNumPhysReqContexts                                      1
/* Transport layer abstract transmission statuses */
#define kDescTxSuccess                                               ((vuint8)kDescUsdtNetworkOk)

/* Table offsets */
#define kDescTimingRefP2                                             0
#define kDescTimingRefP2Star                                         1

#define kDescNrcRejectStateSession                                   kDescNrcSubfunctionNotSupportedInActiveSession
#define kDescStateGroupNumTransition                                  5
#define kDescStateNoTransition                                       ((DescSetStateIndex)kDescStateGroupNumTransition)

/* SecuredDataTransmission negative response code start number */
#define kDescNrcSecuredDataTransNrcOffset                            0x38

#define kDescNumSvcHeadConstGapBits                                  1
#define kDescNumSvcHeadSessionGapBits                                4
/* The biggest hexadecimal digit as a SID configured for this ECU. */
#define kDescMaxReqSid                                               0x85
/* The size of the index search table. */
#define kDescSvcIdMapSize                                            70
/* SvcHead table size. */
#define kDescSvcHeadNumItems                                         15
/* SvcInst table size. */
#define kDescSvcInstNumItems                                         89
/* SvcInstHeadEx table size. */
#define kDescSvcInstHeadExtNumItems                                  153
/* Context modes */
#define kDescContextModeNormal                                       0x00
#define kDescContextModePidList                                      0x01
#define kDescContextModePeriodic                                     0x02
#define kDescContextModeRoutineControl                               0x03
#define kDescContextModeMemByAddr                                    0x04


#define kDescInvalidSvcHandle                                        (DescSvcHeadIndex)kDescSvcHeadNumItems
#define kDescInvalidSvcInstHandle                                    (DescSvcInstIndex)kDescSvcInstNumItems

/*  Negative response service ID */
#define kDescNegResSId                                               0x7F

/* Default settings for the bit structure */
#if defined(kDescNumStateSession)
#else
# define kDescNumStateSession                                        0
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# define DescExtractReqExtHeadLen(reqExtHeadLen)                     (reqExtHeadLen)
# define DescExtractResExtHeadLen(resExtHeadLen)                     (resExtHeadLen)
#else
# define DescExtractReqExtHeadLen(reqExtHeadLen)                     0
# define DescExtractResExtHeadLen(resExtHeadLen)                     0
#endif

#if !defined (kDescOemNrcParamIdNotSupportedInSession)
# define kDescOemNrcParamIdNotSupportedInSession                     kDescNrcRequestOutOfRange
#endif

#if !defined (kDescOemNrcParamIdNotSupportedInSecurityState)
# define kDescOemNrcParamIdNotSupportedInSecurityState               kDescNrcAccessDenied
#endif


/*  Length of negative response message */
#define kDescNegResLen                                               ((DescMsgLen)3)
/*  Positive response service ID offset */
#define kDescPosResIdOffset                                          ((vuint8)0x40)

#define kDescNumPostHandlers                                         9
/* Stores the reference of the SvcInstTable entry for the service which stops sessions (starts default session). */
#define kDescDefaultSessionSvcInstEntry                              0
/* The first entry of the SessionControl service is to be found at this position (g_descSvcHead table). */
#define kDescSvcHeadOffsetSDS                                        0
/* The first entry of the SessionControl service is to be found at this position (g_descSvcInst table). */
#define kDescSvcInstOffsetSDS                                        0
/* No NRCs additionally suppressed */
#define DESC_OEM_SUPPRESSED_FUNC_NRC                                 /* Fall through */
#define kDescOemNrcInvalidAddrMethod                                 kDescNrcConditionsNotCorrect

#define kDescNumPids                                                 83
/* Invalid handle after PID lookup */
#define kDescInvalidPidHandle                                        ((DescMemPidInstIndex)kDescNumPids)

#define kDescNumRids                                                 17
#define kDescNumRidInst                                              26
#define kDescNumRidControlTypes                                      3
/* Invalid handle after RID lookup */
#define kDescInvalidRidHandle                                        ((DescMemRidLookUpIndex)kDescNumRids)
/* Invalid routine instance handle */
#define kDescInvalidRidInstHandle                                    ((DescMemRidInstIndex)kDescNumRidInst)

/* Multiple PIDs processing specific NRC on too many PID in single request. */
#define kDescOemNrcTooManyPIDs                                       kDescNrcRequestOutOfRange
/* Multiple PIDs processing specific NRC on too long response. */
#define kDescOemNrcResponseTooLong                                   kDescNrcResponseTooLong


/* -----------------------------------------------------------------------------
    &&&~ Datatype definitions
 ----------------------------------------------------------------------------- */

/*-- TP information types  --*/
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
typedef struct
{
  vuint8 resBuffer[3];
  vuint8 tpRxChannel;
} DescAddResBuffer;

typedef union
{
  vuint8           reqBuffer[7];
  DescAddResBuffer res;
} DescAddBuffer;

typedef struct
{
  vuint8        status;
  DescAddBuffer buffers;
} DescAddChannel;

typedef struct
{
  vuint8         count;
  DescAddChannel channel[kDescNumAddRequestChannels];
} DescAddChannelCtrl;

#endif /* defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)*/

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
typedef struct
{
  DescBitType type:4;
  DescBitType info:4;
} DescTpMemberCtrl;

typedef struct
{
  DescTpMemberCtrl rxPath[kTpRxChannelCount];
  DescTpMemberCtrl txPath[kTpTxChannelCount];
} DescTpCtrl;
#endif /* defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER) */

/* forward declaration of t_descUsdtNetInfoPool */
typedef struct t_descUsdtNetInfoPoolTag t_descUsdtNetInfoPool;
typedef struct t_descUsdtNetInfoPoolTag* t_descUsdtNetInfoPoolPtr;
/* Network dependent data type */
struct t_descUsdtNetInfoPoolTag
{
  t_descUsdtNetBus        busInfo;
  t_descUsdtNetReqType    reqType;
  t_descUsdtNetResType    resType;
  t_descUsdtNetBusHandle  busHandle;
  t_descHandle            descHandle;
  vuint16                 dataLength;

  DescUsdtNetMsg          reqDataPtr;
  DescUsdtNetMsg          resDataPtr;
};

/* ---- Context management state machine ---- */
typedef struct
{
  t_descUsdtNetResult txState;/* Tp ErrorCode */
  DescBitType         contextMode                :3;/* 0x00 - Normal, 0x01 - PIDListProcess */
  DescBitType         isApplError                :1;/* 0x00 - CANdesc NR, 0x01 - APPL NR */
  DescBitType         dummy                      :4;
} DescContextCtrl;

/* ---- Interrupt context management state machine ---- */
typedef struct
{
  t_descUsdtNetInfoPoolPtr infoPoolPtr;
  vuint8             activity                 ;/* 0x00 - Idle, 0x01 - ActiveRx, 0x02 - ActiveProcess, 0x04 - ActiveTxSingleResponse ,0x08 - ActiveTxPeriodicRes, 0x10 - ActiveTxRoeResponder */
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  DescBitType        forcedRcrRpState       :2;/* 0x00 - Idle, 0x01 - Charged, 0x02 - WaitConfirmation */
#endif
  DescBitType        isContextLocked        :1;
} DescInterruptContextCtrl;

/* ---  Timer definitions with 8 Bit CPU optimization  --- */
/* Time T2: */
/* if at least 16 bit CPU - use always 16 bit variables */
/* Time S1: */
typedef vuint16 DescS1Timer;
/* Time T2: */
typedef vuint16 DescT2Timer;

#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
/* type definition for Response pending limit timer */
typedef vuint16 DescRcrrpLimitTimer;
#endif

typedef struct DescStateInfoTag
{
  DescStateGroup stateSession : 4;
  DescStateGroup stateGap_0 : 4;
} DescStateInfo;
#if (kDescStateGroupNumTransition > 255)
  typedef vuint16    DescSetStateIndex;
#else
  typedef vuint8     DescSetStateIndex;
#endif

typedef vuint8 DescSvcHeadIndex; /* Typedef for the SvcHead table indexes- 8/16Bit depeding on its size. */
typedef vuint8_least DescSvcInstIndex; /* Type definition for the SvcInstTable indexes, depending on the SvcInstTable size. */
typedef vuint8 DescMemSvcInstIndex; /* Type definition for the DescMemSvcInstIndex indexes, depending on the SvcInstTable size. */
typedef vuint8 DescPostHandlerIndex; /* Type definition for the Post-handler reference table, depending on its size. */
typedef vuint8_least DescSvcInstHeadExtIndex; /* Type definition for the SvcInstHeadExtTable indexes, depending on the SvcInstTable size. */
typedef vuint8 DescMemSvcInstHeadExtIndex; /* Type definition for the DescMemSvcInstHeadExtIndex indexes, depending on the SvcInstTable size. */
/* Application callbacks (main handler is already defiend in  the desc.h (because of MSCall)) */
typedef void DESC_API_CALL_TYPE (*DescPreHandler)      (DESC_CONTEXT_PARAM_TYPE_ONLY);
typedef void DESC_API_CALL_TYPE (*DescPostHandler)     (DESC_CONTEXT_PARAM_TYPE_FIRST vuint8);

typedef struct
{
  DescBitType                reqHeadByteSpec   :8; /* Each bit represents sub-function/identifier - 0: identifier; 1: any subfunction */
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
  DescBitType                reqHeadExLen      :4; /* Request HeadEx length up to 7 Byte  */
  DescBitType                resHeadExLen      :4; /* Response HeadEx length up to 7 Byte */
#endif
  DescBitType                reqType           :2; /* 0x01: Phys 0x02: Func */
  DescBitType                resOnReq          :2; /* 0x01: Phys 0x02: Func */
  DescBitType                suppPosRes        :1; /* 0x00: No   0x01: Yes  */
  DescBitType                isReqHeadExtEchoed:1; /* 0x00: No   0x01: Yes  */
  DescBitType                hasSubFunction    :1; /* 0x00: No   0x01: Yes  */
#if (kDescNumSvcHeadConstGapBits > 0)
  DescBitType                svcHeadPlaceHolder:kDescNumSvcHeadConstGapBits; /* Gap holder  */
#endif
#if (kDescNumStateSession > 0)
  DescStateGroup             checkSessionState :kDescNumStateSession;/* State group Session on SId level */
#endif
#if (kDescNumSvcHeadSessionGapBits > 0)
  DescBitType                sessionPlaceHolder:kDescNumSvcHeadSessionGapBits; /* Gap holder  */
#endif
#if defined (DESC_ENABLE_MIN_REQ_LEN_CHECK)
  vuint8                  minReqLength;
#endif
#if defined (DESC_ENABLE_MULTI_VARIANT)
  DescVariantMask         variantMask;
#endif
/* First item in Service Instance table */
  DescMemSvcInstIndex        svcInstFirstItem;
  DescMemSvcInstHeadExtIndex svcInstHeadExtFirstItem;
} DescSvcHead;

typedef struct
{
  DescMsgLen             reqLen;
  DescMsgAddInfo         msgAddInfo;
#if defined (DESC_ENABLE_AUTO_STATES)
  DescStateInfo          checkState;
# if (kDescStateGroupNumTransition > 0)
  DescSetStateIndex      setStateIndex;
# endif
#endif /* DESC_ENABLE_AUTO_STATES */
#if defined (DESC_ENABLE_MULTI_VARIANT)
  DescVariantMask        variantMask;
#endif
#if defined (DESC_ENABLE_PREHANDLER_USAGE)
  DescPreHandlerIndex    preHandlerRef;
#endif
#if defined (DESC_ENABLE_POSTHANDLER_USAGE)
  DescPostHandlerIndex   postHandlerRef;
#endif
  DescMainHandler        mainHandler;
} DescSvcInst;

typedef vuint8_least DescPidInstIndex;
typedef vuint8 DescMemPidInstIndex;
typedef enum
{
  pmAnalyseReasonNone = 0,
  pmAnalyseReasonSession,
  pmAnalyseReasonSecurityState,
  pmAnalyseReasonOther
}DescPidAnalyseFailureReason;

typedef enum
{
  pmClientReadOnce = 0,
  pmClientReadCycle,
  pmClientDynDefine
}DescPidClient;

typedef struct
{
#if defined (DESC_ENABLE_AUTO_STATES)
  DescStateInfo        checkState;
#endif /* DESC_ENABLE_AUTO_STATES */
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE)
  DescPreHandlerIndex  preHandlerRef;
#endif
  DescMsgAddInfo       msgAddInfo;
#if defined (DESC_ENABLE_MULTI_VARIANT)
  DescVariantMask      variantMask;
#endif
}DescPidTinyInfo;

typedef struct
{
  DescMemPidInstIndex  pidHandle;
  DescPidTinyInfo      tinyInfo;
}DescPidClientInfo;

typedef struct
{
  vuint16              reqPid;
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
  DescMsgLen           resDataLen;
#endif
  DescPidTinyInfo      tinyInfo;
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  DescPostHandlerIndex postHandlerRef;
#endif
  DescMainHandler      mainHandler;
} DescPidInst;

typedef vuint8_least DescRidLookUpIndex;
typedef vuint8 DescMemRidLookUpIndex;
typedef vuint8_least DescRidInstIndex;
typedef vuint8 DescMemRidInstIndex;
typedef vuint8_least  DescRidControlType;
typedef struct
{
#if defined (DESC_ENABLE_AUTO_STATES)
  DescStateInfo        checkState;
#endif /* DESC_ENABLE_AUTO_STATES */
#if defined (DESC_ENABLE_RID_PREHANDLER_USAGE)
  DescPreHandlerIndex  preHandlerRef;
#endif
  DescMsgAddInfo       msgAddInfo;
#if defined (DESC_ENABLE_MULTI_VARIANT)
  DescVariantMask      variantMask;
#endif
}DescRidTinyInfo;

typedef struct
{
  DescMsgLen           reqDataLen; /* contains the RID and the request parameters' length only*/
  DescRidTinyInfo      tinyInfo;
#if defined (DESC_ENABLE_RID_POSTHANDLER_USAGE)
  DescPostHandlerIndex postHandlerRef;
#endif
  DescMainHandler      mainHandler;
} DescRidInst;

/* ---- RingBuffer state machine ---- */
typedef struct
{
  DescMsgLen    txReadIndex;                /* Ring buffer current read position. */
  DescMsgLen    txWriteIndex;               /* Ring buffer current write position. */
  DescMsgLen    bytesWritten;               /* Current amount of bytes written. */
  DescBitType   protocolDataLen         :4; /* The protocol data length is used for the FF check length (to start the transmission or not) */
  DescBitType   isRingBufferActive      :1; /* The current context uses ring buffer or not. */
  DescBitType   isRingBufferTxActive    :1; /* The ring buffer transmission has been activated or not.*/
  DescBitType   isRingBufferReactivated :1; /* Once activated this flag will indicate if it was reactivated (list mode requests)*/
  DescBitType   dummy                   :1; /* Dummy for 8boudnary. */
} DescRingBufferCtrl;



/* -----------------------------------------------------------------------------
    &&&~ Function prototypes
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
static void CheckTableConsistency(void);
#endif
#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
static void DescDebugIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

DESCNET_USDT_STATIC void DescUsdtNetIsoTpInitPowerOn(void);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInit(void);

DESCNET_USDT_STATIC void DescUsdtNetIsoTpStateTask(void);

DESCNET_USDT_STATIC void DescUsdtNetIsoTpPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool);

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC vuint16 DescUsdtNetIsoTpGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool);
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
static void DescBusyResponseHandler(void);
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
static vuint8 DescDispatchServiceContext(vuint8 sid);
#endif
static void DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescUsdtNetIsoTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct);

#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
DESCNET_USDT_STATIC void                DescUsdtNetLSFinishReception         (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC void                DescUsdtNetLSFinishTransmission      (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetLSStartReception          (t_descUsdtNetInfoPoolPtr infoPool);
/* Copy data from ringbuffer into network layer */
# if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetLSRingBufferCopyRoutine   (t_descUsdtNetInfoPoolPtr infoPool, DescUsdtNetMsg pDestination, vuint8 dataLength);
# endif
#endif
/* Call backs */
DESCNET_USDT_STATIC void                DescUsdtNetAbsFinishReception         (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC void                DescUsdtNetAbsFinishTransmission      (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsStartReception          (t_descUsdtNetInfoPoolPtr infoPool);
/* Copy data from ringbuffer into network layer */
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsRingBufferCopyRoutine   (t_descUsdtNetInfoPoolPtr infoPool, DescUsdtNetMsg pDestination, vuint8 dataLength);
#endif

static void DescNetworkIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
# define DescIsTesterPresent(infoPool)                               kDescFalse
#else
static DescBool DescIsTesterPresent(t_descUsdtNetInfoPoolPtr infoPool);
#endif

static void DescNetworkInitPowerOn(void);
static void DescNetworkInit(void);

static void DescTransmitRcrRp(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescReleaseContext(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescTimingOnceInit(void);
static void DescTimingIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
static void DescOemNpmTimer(void);
# endif
static void DescNpmProcessQueue(void);
static void DescNpmSetSleepInd(void);
#endif

#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
static void DescOemResPendingOverrun(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

#if defined(DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
static vuint8_least DescGetSessionStateBitPosition(DescStateGroup sessionState);
#endif
/* Internal interface of session transition 
 * shall be before the generated code which defines the macro to nothing if
 * if it doesn't exist.
 */
#if defined(DESC_ENABLE_AUTO_STATES)
static void DescOnTransitionStateSession(DescStateGroup newState, DescStateGroup currentState);
#endif

static void DescStateOnceInit(void);

/* ---- Providing interface between subcomponents Dispatch and Network ---- */
static void DescDoPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status);
/* Internal API for INIT */
static void DescDispatcherIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask);
#endif
static DescSvcHeadIndex DescFindSvc(DescMsgItem reqSvcId);

static void DescDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
static vuint8_least DescGetSvcInstHeadExtEntrySize(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead);
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
# endif
#endif

#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
static void DescFinalProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

static void DescContextStateTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescResponseTimeoutTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DESC_API_CALLBACK_TYPE DescOemStartSessionDefault(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemStartSessionProgramming(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemStartSessionExtended(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemStartSessionNxtrMode(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemClearDiagInfo(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemReadDtcRDTCBSM(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemReadDtcRDTCEDRBDN(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemReadDtcRSUPDTC(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDataByIdentifier(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemCommCtrlEnableRxEnableTx(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemCommCtrlEnableRxDisableTx(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemWriteDidROElightActivationState(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescRoutineControlByIdentifier(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemProcessTesterPresent(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlDtcSettingEnable(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlDtcSettingDisable(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionDefault(vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionProgramming(vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionExtended(vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionNxtrMode(vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostReadDtcInfo(vuint8 status);
static void DESC_API_CALLBACK_TYPE DescPostReadDataByIdentifier(vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostCommonCommCtrlProcess(vuint8 status);
#if defined (DESC_ENABLE_ANY_PREHANDLER_USAGE)
static void DESC_API_CALL_TYPE DescDummyPreHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif
#if defined (DESC_ENABLE_ANY_POSTHANDLER_USAGE)
static void DESC_API_CALL_TYPE DescDummyPostHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status);
#endif

static void DescOemCommonCommCtrlProcess(vuint8 reqInfo, DescMsgContext *pMsgContext);
static void DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ONLY);
#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
static DescBool DescOemCheckAndExtractCommTypeParam(DescOemCommControlInfo * pCommControlInfo, DescMsgItem comType);
#endif

/* Function prototypes */
static void DescOemPrepareSessionControl(DescMsgContext *pMsgContext, DescStateGroup targetSession);
#if defined (DESC_ENABLE_COMMON_OEM_POST_HANDLER)
static void DescOemCommonSessionPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status, DescStateGroup newSession);
#endif

/* internal functions used with FRFM */
static void DescFaultMemoryOnceInitPowerOn(void);

static void DescFrfmFillRbByDtcAndValue(DescMsgContext* pMsgContext);

static void DescFrfmFillRbDTCExtRecByDTCNum(DescMsgContext* pMsgContext);

static void DescPidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DESC_API_CALLBACK_TYPE DescOemReadDidROElightActivationState(DescMsgContext* pMsgContext);
static DescPidInstIndex DescPmGetPidPoolHandle   (vuint16 pid);
static DescPidInstIndex DescPmGetAvailablePidHandle(vuint16 pid);
#if defined(DESC_ENABLE_PERIODIC_MODE)
static DescPidInstIndex DescPmGetSupportedPidClientHandle(vuint16 pid, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable);
#endif
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || defined(DESC_ENABLE_PERIODIC_MODE)
static DescPidInstIndex DescPmGetPidClientHandle (DescPidInstIndex pidInfoHandle, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable);
#endif
static DescPidAnalyseFailureReason DescPmAnalysePid(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescPidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo);
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
static DescMsgLen       DescPmGetPidResponseLen  (DescPidInstIndex pidHandle);
#endif

static DescRidLookUpIndex DescRidFindRoutineId(vuint16 rid);
static DescRidInstIndex   DescRidFindSubFunction(vuint8 subFuncId, DescRidInstIndex ridRef);
static void DescRidAnalyseRoutine(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescRidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo, DescBool isOnRid);
static void DescRidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescRingBufferIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescRingBufferStateReset(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescRingBufferCheckStartEndCondition(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

#if defined(DESC_ENABLE_RING_BUFFER_WRITE_NO_DATA)
static void DescRingBufferWriteNoData(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMsgLen dataLen);
#endif
#if defined(DESC_ENABLE_RING_BUFFER_GET_WRITE_PTR)
static DescMsg DescRingBufferGetCurrWritePointer(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

#if defined (DESC_ENABLE_RING_BUFFER_WRITE_NO_DATA) || \
    defined (DESC_ENABLE_PID_LIST_MODE)
static void DescRingBufferIndexAddition(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMsgLen* pIndex, DescMsgLen incValue);
#endif

#if defined (DESC_ENABLE_PID_LIST_MODE)
static void DescLinearResponseProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif



/* -----------------------------------------------------------------------------
    &&&~ RAM definitions
 ----------------------------------------------------------------------------- */

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
static vuint8 g_descUsdtNetTpTxChannel[kDescTpNumContexts];
# endif
#endif
static t_descUsdtNetInfoPool  g_descUsdtNetInfoPoolIsoTp[kDescNumContexts];
#if defined (DESC_ENABLE_PARALLEL_OBD)
static t_descUsdtNetInfoPoolPtr g_busInfoPoolRxRef[kTpRxChannelCount + 1]; /* rx channels + one functional */
#endif
static t_descUsdtNetInfoPoolPtr g_busInfoPoolTxRef[kTpTxChannelCount];

DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descBuffer[kDescTpNumContexts][kDescPrimBufferLen];

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/* Tp state controller  */
static DescTpCtrl g_descTpCtrl;
#endif
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/* Parallel request responder state controller 
 use memory model specific define, since there are embedded Rx and Tx Buffers insider.
*/
DESC_USDTNET_PRVT_DEF_VAR_FAR(DescAddChannelCtrl) g_descAddChannelCtrl;
#endif

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descCopyToCanData[7];
# endif
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
/* In:
* - single channel system - flag for already activated DPM user.
* - multi  channel system - bit mapped register for already activated DPM users (channel specific).
*/
static vuint8_least  g_descCanChannelMap;
/* The same meaning of the above bit-map, but used for DPM manipulation at task level */
static vuint8_least  g_descCanChannelMapQueue;
#endif
/* Global storage of the user response information */
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
static t_descUsdtNetInfoPool  g_descUsdtNetSpontanResInfoPool;
#endif
/* Extra buffer for the "response pending" negative response */
DESC_PRVT_DEF_VAR_FAR(DescMsgItem) g_descRcrrpBuffer[kDescNumContexts][3];

#if (kDescNumContexts > 1)
/* Each bit represents a diagnostic connection activity (maximum n parallel (n = 8)):
* Bit[  0]: Physical_0
* ..........
* Bit[n-2]: Physical_0
* Bit[n-1]: Functional
*/
static vuint8 g_descActiveRequestsMask;
#endif

DESC_PRVT_DEF_VAR_FAR(vuint8) g_descFblPosRes[6];

/* State machine of each received request */
static DescContextCtrl          g_descContextCtrl[kDescNumContexts];
static DescInterruptContextCtrl g_descInterruptContextCtrl[kDescNumContexts];
#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
static vuint8                   g_descTesterAddress[kDescNumContexts];
#endif

#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
/* Limitation timer/counter for maximal time window for "response pending" 
* negative responses that will be sent. */
static DescRcrrpLimitTimer g_descRcrrpLimitCounter[kDescNumContexts];
#endif

/* T2 timer for response pending support */
static DescT2Timer  g_descT2Timer[kDescNumContexts];
/* "Tester present" timer */
static DescS1Timer  g_descS1Timer;

#if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
# define kDescP2InitValue                                            (g_descP2TicksTable[g_descCurrSessionNumber][kDescTimingRefP2])
# define kDescP2ReloadValue                                          (g_descP2TicksTable[g_descCurrSessionNumber][kDescTimingRefP2Star])
#else
# define kDescP2InitValue                                            kDescP2Ticks
# define kDescP2ReloadValue                                          kDescP2StarTicks
#endif

#if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
/* Global variable to store the converted session number value */
static vuint8 g_descCurrSessionNumber;
#endif

/* Timer reload event flag */
static DescBool g_descDoReloadS1Timer;

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
static vuint16 g_descNpmTimer;
#endif

/* State machine of CANdesc described by CANdelaStudio */
static DescStateInfo g_descCurState;

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL) && \
    defined (DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION)
static DescBool g_descIsOemMainHdlrAlreadyCalled;
#endif

/* Store the service entry index for the current request */
static DescSvcHeadIndex      g_descCurReqSvc[kDescNumContexts];

/* Store the instance entry index for the current request */
static DescMemSvcInstIndex   g_descCurReqSvcInst[kDescNumContexts];

/* Context information to accompany the complete request processing */
static DescMsgContext     g_descMsgContext[kDescNumContexts];

/* Store detected diagnostic error */
static DescNegResCode     g_descNegResCode[kDescNumContexts];

#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/* Pointer of main handlers */
static DescMainHandler    g_descRecallHandler[kDescNumContexts];
#endif

#if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
/* Store the SID byte for the application if the post-handler is used */
static DescMsgItem        g_descUserSIdBackup[kDescNumContexts];
#endif


/* Shared communication control info */
static DescOemCommControlInfo  g_descCommControlInfo;

static volatile vuint16 g_descFrfmRequestedCount;
static vuint8  *g_descFrfmSrcBuffer;


#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
/* Currenlty processed handle */
static DescMemPidInstIndex g_descRdbiPidHandle[kDescNumContexts];
#endif

#if defined (DESC_ENABLE_RID_POSTHANDLER_USAGE)
static DescMemRidInstIndex  g_descRidCurrInstRef;
#endif

/* Ring buffer control center */
static DescRingBufferCtrl       g_descRingBufferCtrl[kDescNumContexts];



/* -----------------------------------------------------------------------------
    &&&~ ROM definitions
 ----------------------------------------------------------------------------- */

/* Version information */
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descMainVersion     = (vuint8) DESC_MAIN_VERSION;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descSubVersion      = (vuint8) DESC_SUB_VERSION;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descBugFixVersion   = (vuint8) DESC_BUGFIX_VERSION;

#if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descCan2TpChannelMap[kDescNumCommChannels] =
{
# if (kDescNumCommChannels >= 1)
  kDescCan2TpChannel_0
# endif
# if (kDescNumCommChannels >= 2)
  ,kDescCan2TpChannel_1
# endif
# if (kDescNumCommChannels >= 3)
  ,kDescCan2TpChannel_2
# endif
# if (kDescNumCommChannels == 4)
  ,kDescCan2TpChannel_3
# endif
# if (kDescNumCommChannels > 4)
#  error "Too many CAN-channels!!!"
# endif
};
#endif

#if defined(DESC_ENABLE_PARALLEL_OBD)
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descDescConnections[kDescTpNumContexts] =
{
   kDescDiagConnection
  ,kDescDiagObdConnection
};
#endif

/* Each entry represents a session specific (P2,P2Ex) pair as DescTask call cycles. */
V_MEMROM0 static V_MEMROM1 vuint16 V_MEMROM2 g_descP2TicksTable[kDescNumStateSession][2] = 
{
  {    3,  199 }, 
  {    3,  199 }, 
  {    3,  199 }, /*Manual Edit - Does not generate correctly with Geny - DO NOT REPLACE*/
  {    3,  199 } /*Manual Edit - Does not generate correctly with Geny - DO NOT REPLACE*/
};
V_MEMROM0 static V_MEMROM1 vuint16 V_MEMROM2 g_descP2TimingsTable[kDescNumStateSession][2] = 
{
  {   40,  200 },
  {   40,  200 }, 
  {   40,  200 }, /*Manual Edit - Does not generate correctly with Geny - DO NOT REPLACE*/
  {   40,  200 } /*Manual Edit - Does not generate correctly with Geny - DO NOT REPLACE*/
};
/* Table of all state transitions defined by CANdelaStudio. */
V_MEMROM0 static V_MEMROM1 DescStateInfo V_MEMROM2 g_descStateGroupTransition[kDescStateGroupNumTransition][2] = 
{
  { { 0x07, 0x00 }, { 0x01, 0x00 } }, 
  { { 0x07, 0x00 }, { 0x02, 0x00 } }, 
  { { 0x05, 0x00 }, { 0x04, 0x00 } }, 
  { { 0x0F, 0x00 }, { 0x08, 0x00 } }, 
  { { 0x07, 0x00 }, { 0x01, 0x00 } }
};
/* &~MsgTables */
/* Table of reference indexes for fast SID look-up. */
V_MEMROM0 static V_MEMROM1 DescMsgItem V_MEMROM2 g_descSidMap[kDescSvcIdMapSize] = 
{
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0x01, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 
  0xFF, 0x08, 0xFF, 0xFF, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0D
};
/* Table of service ID relevant information. */
V_MEMROM0 static V_MEMROM1 DescSvcHead V_MEMROM2 g_descSvcHead[kDescSvcHeadNumItems] = 
{
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 0x00, 0x0F, 0x00,  2,  0,  0 } /* $10 */, 
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 0x00, 0x0F, 0x00,  2,  4,  4 } /* $11 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 0x0D, 0x00,  1,  7,  7 } /* $14 */, 
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 0x00, 0x0D, 0x00,  2,  8,  7 } /* $19 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 0x0F, 0x00,  1, 11, 10 } /* $22 */, 
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 0x00, 0x0C, 0x00,  2, 12, 10 } /* $28 */, 
  { 0x07, 2, 2, 0x03, 0x03, 0, 1, 0, 0x00, 0x0F, 0x00,  4, 14, 12 } /* $2E */, 
  { 0x0F, 3, 3, 0x03, 0x03, 0, 1, 0, 0x00, 0x08, 0x00,  4, 77, 138 } /* $2F */, 

  { 0x01, 0, 0, 0x03, 0x03, 1, 1, 1, 0x00, 0x0E, 0x00,  1, 81, 150 } /* $31 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 0x02, 0x00,  1, 82, 150 } /* $34 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 0x02, 0x00,  1, 83, 150 } /* $36 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 0x02, 0x00,  1, 84, 150 } /* $37 */, 
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 0x00, 0x0F, 0x00,  2, 85, 150 } /* $3E */, 
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 0x00, 0x0C, 0x00,  2, 86, 151 } /* $85 */, 
  { 0x00, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 0x0F, 0x00,  1, 88, 153 } /* $FF */
};
/* Table of all configured (effectively used) post-handlers. */
V_MEMROM0 static V_MEMROM1 DescPostHandler V_MEMROM2 g_descPostHandlerTable[kDescNumPostHandlers] = 
{
  DescDummyPostHandler, 
  DescOemPostStartSessionDefault, 
  DescOemPostStartSessionProgramming, 
  DescOemPostStartSessionExtended, 
  DescOemPostStartSessionNxtrMode, 
  DescOemPostCommonCommCtrlProcess, 
  DescPostReadDataByIdentifier, 
  DescOemPostReadDtcInfo, 
  ApplDescPostUserServiceHandler
};
/* Table of service (instance) relevant information. */
V_MEMROM0 static V_MEMROM1 DescSvcInst V_MEMROM2 g_descSvcInst[kDescSvcInstNumItems] = 
{
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x00 },                      0,    1, DescOemStartSessionDefault } /* $10 $1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x00 },                      1,    2, DescOemStartSessionProgramming } /* $10 $2 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0D, 0x00 },                      2,    3, DescOemStartSessionExtended } /* $10 $3 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x00 },                      3,    4, DescOemStartSessionNxtrMode } /* $10 $7E */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x00 },                      4,    0, ApplDescEcuResetHard } /* $11 $1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescEcuResetSoft } /* $11 $3 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescEcuResetNxtr_ECU_Reset } /* $11 $60 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0D, 0x00 }, kDescStateNoTransition,    0, DescOemClearDiagInfo } /* $14 */, 

  {   3, { 0x03, 0x03, 0 }, { 0x0D, 0x00 }, kDescStateNoTransition,    7, DescOemReadDtcRDTCBSM } /* $19 $2 */, 
  {   6, { 0x03, 0x03, 0 }, { 0x0D, 0x00 }, kDescStateNoTransition,    7, DescOemReadDtcRDTCEDRBDN } /* $19 $6 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0D, 0x00 }, kDescStateNoTransition,    7, DescOemReadDtcRSUPDTC } /* $19 $A */, 
  {   0, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    6, DescReadDataByIdentifier } /* $22 */, 
  {   3, { 0x03, 0x03, 0 }, { 0x0C, 0x00 }, kDescStateNoTransition,    5, DescOemCommCtrlEnableRxEnableTx } /* $28 $0 */, 
  {   3, { 0x03, 0x03, 0 }, { 0x0C, 0x00 }, kDescStateNoTransition,    5, DescOemCommCtrlEnableRxDisableTx } /* $28 $1 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0D, 0x00 }, kDescStateNoTransition,    0, DescOemWriteDidROElightActivationState } /* $2E $1 $7 */, 
  {  16, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidPPPA_signals } /* $2E $A0 $2 */, 

  {   8, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidHaLF_Signals } /* $2E $A0 $3 */, 
  {   6, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidDST_Signals } /* $2E $A0 $4 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidDID_D100_Active_Diagnostic_Session } /* $2E $D1 $0 */, 
  {  27, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidDID_F110_On_line_Diagnostic_Database_Reference_Number } /* $2E $F1 $10 */, 
  {  27, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidDID_F111_ECU_Core_Assembly_Number } /* $2E $F1 $11 */, 
  {  13, { 0x03, 0x03, 0 }, { 0x0D, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDid_22F112_Hardware_Part_Number } /* $2E $F1 $12 */, 
  {  27, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidDID_F113_ECU_Delivery_Assembly_Number } /* $2E $F1 $13 */, 
  {   6, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDid_22F150_Hardware_Version_Information } /* $2E $F1 $50 */, 

  {  13, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDid_2EF15A_Write_Software_Fingerprint } /* $2E $F1 $5A */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidDID_F162_Software_Download_Specification_Version } /* $2E $F1 $62 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidDID_F163_Diagnostic_Specification_Version } /* $2E $F1 $63 */, 
  {  15, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDid_22F18C_ECU_Serial_Number } /* $2E $F1 $8C */, 
  { 325, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD01_Internal_Software_Id } /* $2E $FD $1 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD02_Serial_Comm_Service_Active } /* $2E $FD $2 */, 
  { 325, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD04_EOL_Sin_Cos_Motor_Param } /* $2E $FD $4 */, 
  {  16, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD05_EOL_Torque_Sensor_Analog } /* $2E $FD $5 */, 

  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD07_EOL_Polarity } /* $2E $FD $7 */, 
  {   8, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD08_EOL_Torque_Sensor_Scaling_Analog } /* $2E $FD $8 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD09_Learned_Ke } /* $2E $FD $9 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD0A_Learned_R } /* $2E $FD $A */, 
  {   5, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD0B_EOL_Wheel_Imbalance_Select } /* $2E $FD $B */, 
  {   9, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD0C_Analog_Ke_R_and_L } /* $2E $FD $C */, 
  {  11, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD0E_Motor_Stiffness_Check } /* $2E $FD $E */, 
  {  39, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD0F_ECU_Hardware_Description_Table } /* $2E $FD $F */, 

  {  13, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD10_Nxtr_CCP_XCP_Transmit_and_Receive_IDs } /* $2E $FD $10 */, 
  {  31, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD12_Current_Mode_Offset_and_Gain } /* $2E $FD $12 */, 
  {  63, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD13_Read_Nxtr_DTCs } /* $2E $FD $13 */, 
  {   5, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD14_Turns_Counter_Vehicle_System_Status } /* $2E $FD $14 */, 
  {  16, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD15_EOL_Torque_Sensor_Digital } /* $2E $FD $15 */, 
  {   8, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD16_EOL_Torque_Sensor_Scaling_Digital } /* $2E $FD $16 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD19_Nxtr_Manufacturing_Enable_Counter_MEC } /* $2E $FD $19 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD1A_System_State } /* $2E $FD $1A */, 

  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD1B_Manual_Vehicle_Speed_Override } /* $2E $FD $1B */, 
  {   6, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD1C_Manufacturing_Services_Version } /* $2E $FD $1C */, 
  {   5, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD1D_EPS_Return_Command } /* $2E $FD $1D */, 
  {   5, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD1E_Torque_Sensor_Diagnostic_Defeat } /* $2E $FD $1E */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD1F_Serial_Comm_Handwheel_Position_Defeat } /* $2E $FD $1F */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD21_Vehicle_Tuning_Select } /* $2E $FD $21 */, 
  {   5, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD25_Motor_Torque_Scale_Factor } /* $2E $FD $25 */, 
  {   6, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD26_Average_Friction_Learning_Select } /* $2E $FD $26 */, 

  {   4, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD27_Friction_Offset_Output_Defeat } /* $2E $FD $27 */, 
  {   5, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD29_Set_EOL_Friction_Learned } /* $2E $FD $29 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FD41_Torque_Sensor_1_and_2 } /* $2E $FD $41 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDA1_ECU_Serial_Number } /* $2E $FD $A1 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDA2_EPS_Serial_Number } /* $2E $FD $A2 */, 
  {  15, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDA3_ECU_Hardware_Part_Number } /* $2E $FD $A3 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDA5_Shunt_Current_and_Offset_Gain } /* $2E $FD $A5 */, 
  {  67, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDAC_Nxtr_Manufacturing_Scratch_Pad } /* $2E $FD $AC */, 

  {  10, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDAD_Active_Pull_Compensation } /* $2E $FD $AD */, 
  {   5, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDAE_Ignition_Counter } /* $2E $FD $AE */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDAF_Nxtr_Fault_Information_Black_Box } /* $2E $FD $AF */, 
  { 259, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDB0_IPM_Cogging_Tbl_1 } /* $2E $FD $B0 */, 
  { 259, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDB1_IPM_Cogging_Tbl_2 } /* $2E $FD $B1 */, 
  { 259, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDB2_IPM_Cogging_Tbl_3 } /* $2E $FD $B2 */, 
  { 259, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDB3_IPM_Cogging_Tbl_4 } /* $2E $FD $B3 */, 
  {  11, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDB4_Current_Mode_Analog_Ke_R_Ld_and_Lq } /* $2E $FD $B4 */, 

  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDB5_Active_Pull_Set_Short_Term_Comp } /* $2E $FD $B5 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDB6_Active_Pull_Set_Long_Term_Comp } /* $2E $FD $B6 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDE1_WIR_Disable } /* $2E $FD $E1 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDE2_Torque_Overlay_Feature_Disable } /* $2E $FD $E2 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteDidNxtr_FDE4_Drift_Pull_Disable } /* $2E $FD $E4 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x08, 0x00 }, kDescStateNoTransition,    0, ApplDescIoCtrlRetCtrlToEcuNxtr_FD0D_Control_Motor_Torque_Command } /* $2F $FD $D $0 */, 
  {   6, { 0x03, 0x03, 0 }, { 0x08, 0x00 }, kDescStateNoTransition,    0, ApplDescIoCtrlShortTermAdjNxtr_FD0D_Control_Motor_Torque_Command } /* $2F $FD $D $3 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x08, 0x00 }, kDescStateNoTransition,    0, ApplDescIoCtrlRetCtrlToEcuNxtr_FD11_Assist_Gain_Command } /* $2F $FD $11 $0 */, 

  {   6, { 0x03, 0x03, 0 }, { 0x08, 0x00 }, kDescStateNoTransition,    0, ApplDescIoCtrlShortTermAdjNxtr_FD11_Assist_Gain_Command } /* $2F $FD $11 $3 */, 
  {   0, { 0x03, 0x03, 0 }, { 0x0E, 0x00 }, kDescStateNoTransition,    0, DescRoutineControlByIdentifier } /* $31 */, 
  {   0, { 0x03, 0x03, 0 }, { 0x02, 0x00 }, kDescStateNoTransition,    0, ApplDescRequestDownload } /* $34 */, 
  {   0, { 0x03, 0x03, 0 }, { 0x02, 0x00 }, kDescStateNoTransition,    0, ApplDescTransferData } /* $36 */, 
  {   0, { 0x03, 0x03, 0 }, { 0x02, 0x00 }, kDescStateNoTransition,    0, ApplDescRequestTransferExit } /* $37 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    0, DescOemProcessTesterPresent } /* $3E $0 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0C, 0x00 }, kDescStateNoTransition,    0, DescOemControlDtcSettingEnable } /* $85 $1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0C, 0x00 }, kDescStateNoTransition,    0, DescOemControlDtcSettingDisable } /* $85 $2 */, 

  {   0, { 0x03, 0x03, 0 }, { 0x0F, 0x00 }, kDescStateNoTransition,    8, ApplDescUserServiceHandler } /* $FF */
};
/* Table of sub-service protocol information. */
V_MEMROM0 static V_MEMROM1 DescMsgItem V_MEMROM2 g_descSvcInstHeadExt[kDescSvcInstHeadExtNumItems] = 
{
  0x01, 0x02, 0x03, 0x7E /* $10 */, 
  0x01, 0x03, 0x60 /* $11 */, 
  0x02, 0x06, 0x0A /* $19 */, 
  0x00, 0x01 /* $28 */, 
  0x01, 0x07, 0xA0, 0x02, 0xA0, 0x03, 0xA0, 0x04, 0xD1, 0x00, 0xF1, 0x10, 0xF1, 0x11, 0xF1, 0x12 /* $2E */, 
  0xF1, 0x13, 0xF1, 0x50, 0xF1, 0x5A, 0xF1, 0x62, 0xF1, 0x63, 0xF1, 0x8C, 0xFD, 0x01, 0xFD, 0x02 /* $2E */, 
  0xFD, 0x04, 0xFD, 0x05, 0xFD, 0x07, 0xFD, 0x08, 0xFD, 0x09, 0xFD, 0x0A, 0xFD, 0x0B, 0xFD, 0x0C /* $2E */, 
  0xFD, 0x0E, 0xFD, 0x0F, 0xFD, 0x10, 0xFD, 0x12, 0xFD, 0x13, 0xFD, 0x14, 0xFD, 0x15, 0xFD, 0x16 /* $2E */, 

  0xFD, 0x19, 0xFD, 0x1A, 0xFD, 0x1B, 0xFD, 0x1C, 0xFD, 0x1D, 0xFD, 0x1E, 0xFD, 0x1F, 0xFD, 0x21 /* $2E */, 
  0xFD, 0x25, 0xFD, 0x26, 0xFD, 0x27, 0xFD, 0x29, 0xFD, 0x41, 0xFD, 0xA1, 0xFD, 0xA2, 0xFD, 0xA3 /* $2E */, 
  0xFD, 0xA5, 0xFD, 0xAC, 0xFD, 0xAD, 0xFD, 0xAE, 0xFD, 0xAF, 0xFD, 0xB0, 0xFD, 0xB1, 0xFD, 0xB2 /* $2E */, 
  0xFD, 0xB3, 0xFD, 0xB4, 0xFD, 0xB5, 0xFD, 0xB6, 0xFD, 0xE1, 0xFD, 0xE2, 0xFD, 0xE4 /* $2E */, 
  0xFD, 0x0D, 0x00, 0xFD, 0x0D, 0x03, 0xFD, 0x11, 0x00, 0xFD, 0x11, 0x03 /* $2F */, 
  0x00 /* $3E */, 
  0x01, 0x02 /* $85 */
};

#if defined ( C_ENABLE_MULTI_ECU_CONFIG )
# if (C_VERSION_REF_IMPLEMENTATION >= 0x150)
V_MEMROM0 extern V_MEMROM1 tVIdentityMsk V_MEMROM2 CanChannelIdentityAssignment[kCanNumberOfChannels];
# endif
#endif

/* Table of all PIDs' instances which can be read using SIMD procedure. */
V_MEMROM0 static V_MEMROM1 DescPidInst V_MEMROM2 g_descPIDInfo[kDescNumPids] = 
{
  { 0x0100, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_220100_Reprogramming_Attempt_Counter }, 
  { 0x0103, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_220103_VIN_Odometer_Counter }, 
  { 0x0107, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, DescOemReadDidROElightActivationState }, 
  { 0x010B, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22010B_Adjust_Block_Size_and_STMin_Parameter }, 
  { 0xA001, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22A001_EPS_Internal_and_Bussed_signals }, 
  { 0xA002, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidPPPA_signals }, 
  { 0xA003, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidHaLF_Signals }, 
  { 0xA004, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidDST_Signals }, 

  { 0xD100, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidDID_D100_Active_Diagnostic_Session }, 
  { 0xF100, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F100_Active_Diagnostic_Information }, 
  { 0xF10B, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F10B_ECU_Qualification }, 
  { 0xF10D, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F10D_Diagnostic_Specification_Information }, 
  { 0xF110, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidDID_F110_On_line_Diagnostic_Database_Reference_Number }, 
  { 0xF111, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidDID_F111_ECU_Core_Assembly_Number }, 
  { 0xF112, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F112_Hardware_Part_Number }, 
  { 0xF113, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidDID_F113_ECU_Delivery_Assembly_Number }, 

  { 0xF132, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F132_ECU_Part_Number }, 
  { 0xF150, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F150_Hardware_Version_Information }, 
  { 0xF151, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F151_Software_Version_Information }, 
  { 0xF153, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F153_Boot_Software_Version_Information }, 
  { 0xF154, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F154_Hardware_Supplier_Identification }, 
  { 0xF155, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F155_Software_Supplier_Identification }, 
  { 0xF158, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F158_Vehicle_Information }, 
  { 0xF15B, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F15B_Read_Software_Fingerprints }, 

  { 0xF160, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F160_Software_Module_Information }, 
  { 0xF162, { { 0x0A, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidDID_F162_Software_Download_Specification_Version }, 
  { 0xF163, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidDID_F163_Diagnostic_Specification_Version }, 
  { 0xF18C, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F18C_ECU_Serial_Number }, 
  { 0xF190, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F190_VIN_Original }, 
  { 0xF1A0, { { 0x0D, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDid_22F1A0_VIN_Current }, 
  { 0xFD01, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD01_Internal_Software_Id }, 
  { 0xFD02, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD02_Serial_Comm_Service_Active }, 

  { 0xFD04, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD04_EOL_Sin_Cos_Motor_Param }, 
  { 0xFD05, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD05_EOL_Torque_Sensor_Analog }, 
  { 0xFD07, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD07_EOL_Polarity }, 
  { 0xFD08, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD08_EOL_Torque_Sensor_Scaling_Analog }, 
  { 0xFD09, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD09_Learned_Ke }, 
  { 0xFD0A, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD0A_Learned_R }, 
  { 0xFD0B, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD0B_EOL_Wheel_Imbalance_Select }, 
  { 0xFD0C, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD0C_Analog_Ke_R_and_L }, 

  { 0xFD0E, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD0E_Motor_Stiffness_Check }, 
  { 0xFD0F, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD0F_ECU_Hardware_Description_Table }, 
  { 0xFD10, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD10_Nxtr_CCP_XCP_Transmit_and_Receive_IDs }, 
  { 0xFD12, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD12_Current_Mode_Offset_and_Gain }, 
  { 0xFD13, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD13_Read_Nxtr_DTCs }, 
  { 0xFD14, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD14_Turns_Counter_Vehicle_System_Status }, 
  { 0xFD15, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD15_EOL_Torque_Sensor_Digital }, 
  { 0xFD16, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD16_EOL_Torque_Sensor_Scaling_Digital }, 

  { 0xFD17, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD17_TMS570_Flash_Memory_Size }, 
  { 0xFD19, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD19_Nxtr_Manufacturing_Enable_Counter_MEC }, 
  { 0xFD1A, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD1A_System_State }, 
  { 0xFD1B, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD1B_Manual_Vehicle_Speed_Override }, 
  { 0xFD1C, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD1C_Manufacturing_Services_Version }, 
  { 0xFD1D, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD1D_EPS_Return_Command }, 
  { 0xFD1E, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD1E_Torque_Sensor_Diagnostic_Defeat }, 
  { 0xFD1F, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD1F_Serial_Comm_Handwheel_Position_Defeat }, 
  { 0xFD20, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD20_Read_Transient_Overvoltage_Data }, 

  { 0xFD21, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD21_Vehicle_Tuning_Select }, 
  { 0xFD25, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD25_Motor_Torque_Scale_Factor }, 
  { 0xFD26, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD26_Average_Friction_Learning_Select }, 
  { 0xFD27, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD27_Friction_Offset_Output_Defeat }, 
  { 0xFD29, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD29_Set_EOL_Friction_Learned }, 
  { 0xFD41, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FD41_Torque_Sensor_1_and_2 }, 
  { 0xFDA1, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDA1_ECU_Serial_Number }, 
  { 0xFDA2, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDA2_EPS_Serial_Number }, 

  { 0xFDA3, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDA3_ECU_Hardware_Part_Number }, 
  { 0xFDA5, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDA5_Shunt_Current_and_Offset_Gain }, 
  { 0xFDAC, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDAC_Nxtr_Manufacturing_Scratch_Pad }, 
  { 0xFDAD, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDAD_Active_Pull_Compensation }, 
  { 0xFDAE, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDAE_Ignition_Counter }, 
  { 0xFDAF, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDAF_Nxtr_Fault_Information_Black_Box }, 
  { 0xFDB0, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDB0_IPM_Cogging_Tbl_1 }, 
  { 0xFDB1, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDB1_IPM_Cogging_Tbl_2 }, 

  { 0xFDB2, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDB2_IPM_Cogging_Tbl_3 }, 
  { 0xFDB3, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDB3_IPM_Cogging_Tbl_4 }, 
  { 0xFDB4, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDB4_Current_Mode_Analog_Ke_R_Ld_and_Lq }, 
  { 0xFDB5, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDB5_Active_Pull_Set_Short_Term_Comp }, 
  { 0xFDB6, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDB6_Active_Pull_Set_Long_Term_Comp }, 
  { 0xFDE0, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDE0_Steering_Wheel_Active_Pull_Compensation }, 
  { 0xFDE1, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDE1_WIR_Disable }, 
  { 0xFDE2, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDE2_Torque_Overlay_Feature_Disable }, 

  { 0xFDE3, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidFDE2_NTC_for_CTC }, 
  { 0xFDE4, { { 0x0F, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadDidNxtr_FDE4_Drift_Pull_Disable }
};
/* Table of all RIDs' */
V_MEMROM0 static V_MEMROM1 vuint16 V_MEMROM2 g_descRidLookUpTable[kDescNumRids] = 
{
  0x0202, 0x0300, 0x0301, 0x0304, 0xF000, 0xF001, 0xF002, 
  0xF004, 0xF005, 0xF006, 0xF007, 0xF008, 0xF009, 0xF00D, 
  0xF00E, 0xFF03, 0xFF05
};
/* Table of RIDs' sub-function to control type mapping. */
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descRidSubFuncToCtrlTypeMap[4] = 
{
  26, 
  0, 
  1, 
  2
};
/* Table of RIDs' sub-function access types. */
V_MEMROM0 static V_MEMROM1 DescMemRidInstIndex V_MEMROM2 g_descRidControlTypeInfo[kDescNumRids][kDescNumRidControlTypes] = 
{
  {    0,    1,    2 } /* $0202 */, 
  {    3,   26,    4 } /* $0300 */, 
  {    5,    6,    7 } /* $0301 */, 
  {    8,   26,   26 } /* $0304 */, 
  {    9,   26,   26 } /* $f000 */, 
  {   10,   26,   26 } /* $f001 */, 
  {   11,   26,   26 } /* $f002 */, 
  {   12,   26,   26 } /* $f004 */, 

  {   13,   26,   26 } /* $f005 */, 
  {   14,   26,   26 } /* $f006 */, 
  {   15,   26,   26 } /* $f007 */, 
  {   16,   26,   26 } /* $f008 */, 
  {   17,   18,   19 } /* $f009 */, 
  {   20,   26,   26 } /* $f00d */, 
  {   21,   26,   26 } /* $f00e */, 
  {   22,   26,   26 } /* $ff03 */, 

  {   23,   24,   25 } /* $ff05 */
};
/* Table of all RIDs' properties. */
V_MEMROM0 static V_MEMROM1 DescRidTinyInfo V_MEMROM2 g_descRIDInfo[kDescNumRids] = 
{
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $0202 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $0300 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $0301 */, 
  { { 0x0A, 0x00 }, { 0x03, 0x03, 0 } } /* $0304 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f000 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f001 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f002 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f004 */, 

  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f005 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f006 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f007 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f008 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f009 */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f00d */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $f00e */, 
  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $ff03 */, 

  { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } } /* $ff05 */
};
/* Table of all RIDs' instances. */
V_MEMROM0 static V_MEMROM1 DescRidInst V_MEMROM2 g_descRIDInstInfo[kDescNumRidInst] = 
{
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartRTN_0202_On_Demand_Self_Test } /* $31 $1 $2 $2 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStopRTN_0202_On_Demand_Self_Test } /* $31 $2 $2 $2 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlReqResRTN_0202_On_Demand_Self_Test } /* $31 $3 $2 $2 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStart_31010300_Clear_Steering_Pull_Compensation } /* $31 $1 $3 $0 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlReqRes_31010300_Clear_Steering_Pull_Compensation } /* $31 $3 $3 $0 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartEngine_Defeat } /* $31 $1 $3 $1 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStopEngine_Defeat } /* $31 $2 $3 $1 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlReqResEngine_Defeat } /* $31 $3 $3 $1 */, 

  {   3, { { 0x0A, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartRTN_0304_Check_Valid_Application } /* $31 $1 $3 $4 */, 
  {   6, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F000_Manufacturing_Service_Reset } /* $31 $1 $F0 $0 */, 
  {   5, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F001_Clear_DTCs } /* $31 $1 $F0 $1 */, 
  {   4, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F002_Torque_Sensor_End_of_Line_Calibration_Analog } /* $31 $1 $F0 $2 */, 
  {   4, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F004_Torque_Sensor_End_of_Line_Calibration_Digital } /* $31 $1 $F0 $4 */, 
  {   5, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F005_DTC_Status_by_Number } /* $31 $1 $F0 $5 */, 
  {   4, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F006_Turns_Counter_Flash_Programming } /* $31 $1 $F0 $6 */, 
  {   0, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F007_Turns_Counter_Position_EOL_Calibraiton } /* $31 $1 $F0 $7 */, 

  {   4, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F008_Current_Mode_Current_Gain_Calc } /* $31 $1 $F0 $8 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F009_Current_Mode_Current_Offset_Calc } /* $31 $1 $F0 $9 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStopNxtr_F009_Current_Mode_Current_Offset_Calc } /* $31 $2 $F0 $9 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlReqResNxtr_F009_Current_Mode_Current_Offset_Calc } /* $31 $3 $F0 $9 */, 
  {   4, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F00D_Calculate_Current_Gain } /* $31 $1 $F0 $D */, 
  {   4, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStartNxtr_F00E_Calculate_Current_Offset } /* $31 $1 $F0 $E */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStart_3101FF03_Check_Programming_Preconditions } /* $31 $1 $FF $3 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStart_3101FF05_Deactivation_of_Fail_Safe_Reactions } /* $31 $1 $FF $5 */, 

  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlStop_3101FF05_Deactivation_of_Fail_Safe_Reactions } /* $31 $2 $FF $5 */, 
  {   3, { { 0x0E, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRtnCtrlReqRes_3101FF05_Deactivation_of_Fail_Safe_Reactions } /* $31 $3 $FF $5 */
};


/* -----------------------------------------------------------------------------
    &&&~ Macro definitions
 ----------------------------------------------------------------------------- */

#define DescGetTicksOfMs(timeMs)                                     (vuint16)((timeMs)/(kDescCallCycleUs/1000))

#if (kDescNumContexts > 1)
# if defined (DESC_ENABLE_DEBUG_USER )
#  define DescAssertContext(p,e)                                     if (!(p)) {ApplDescFatalError(e, (vuint16)__LINE__);}
# else
#  define DescAssertContext(p,e)
# endif
#else
# define DescAssertContext(p,e)
#endif

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define DescAssertCommon(p,e)                                       if (!(p)) {ApplDescFatalError(e, (vuint16)__LINE__);}
# define DescAssertCommonAlways(e)                                   (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertCommon(p,e)
# define DescAssertCommonAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescAssertInternal(p,e)                                     if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescAssertInternalAlways(e)                                 (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertInternal(p,e)
# define DescAssertInternalAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_USER )
# define DescAssertUser(p,e)                                         if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescAssertUserAlways(e)                                     (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertUser(p,e)
# define DescAssertUserAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescSubcompOnceInitPowerOnDebug()                           (CheckTableConsistency())
#endif

  /* Save too many else cases :) */
#if !defined (DescSubcompOnceInitPowerOnDebug)
# define DescSubcompOnceInitPowerOnDebug()                           /* Not used */
#endif

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define DescSubcompOnceInitDebug()                                  /* Not used */
# define DescSubcompIterInitDebug(iContext)                          (DescDebugIterInit(DESC_CONTEXT_PARAM_ONLY))
#else
# define DescSubcompOnceInitDebug()                                  /* Not used */
# define DescSubcompIterInitDebug(iContext)                          /* Not used */
#endif

#if defined (DESC_ENABLE_DEBUG_USER )
# define DescUsdtNetIsoTpAssertUser(p,e)                             if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescUsdtNetIsoTpAssertUserAlways(e)                         do {ApplDescFatalError((e), (vuint16)__LINE__);}while(0)
#else
# define DescUsdtNetIsoTpAssertUser(p,e)                             /* Not used */
# define DescUsdtNetIsoTpAssertUserAlways(e)                         /* Not used */
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# define DescUsdtNetIsoTpAssertChannel(p,e)                          DescUsdtNetIsoTpAssertUser((p), (e))
#else
# define DescUsdtNetIsoTpAssertChannel(p,e)                          /* Not used */
#endif

/* Accept always */
#define DescOemCheckPhysTargetAddress(srcAddress)                    kDescTrue
#define DescOemCheckFuncTargetAddress(srcAddress)                    kDescTrue

/* Accept always */
#define DescOemCheckPhysSourceAddress(srcAddress)                    kDescTrue
#define DescOemCheckFuncSourceAddress(srcAddress)                    kDescTrue

#define DescUsdtNetInitPowerOn()                                     (DescUsdtNetIsoTpInitPowerOn())
#define DescUsdtNetInit()                                            (DescUsdtNetIsoTpInit())
#define DescUsdtNetStateTask()                                       (DescUsdtNetIsoTpStateTask())
#define DescUsdtNetTimerTask()
#define DescUsdtNetPrepareResponse(infoPool)                         (DescUsdtNetIsoTpPrepareResponse(infoPool))
#define DescUsdtNetTransmitResponse(infoPool)                        (DescUsdtNetIsoTpTransmitResponse(infoPool))
#define DescUsdtNetReleaseInfoPool(infoPool)                         (DescUsdtNetIsoTpReleaseInfoPool(infoPool))
#define DescUsdtNetGetRingBuffTxMinLen(infoPool)                     (DescUsdtNetIsoTpGetRingBuffTxMinLen(infoPool))
#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
# define DescUsdtNetFinishReception(infoPool, status)                (DescUsdtNetLSFinishReception((infoPool),(status)))
# define DescUsdtNetFinishTransmission(infoPool, status)             (DescUsdtNetLSFinishTransmission((infoPool),(status)))
# define DescUsdtNetStartReception(infoPool)                         (DescUsdtNetLSStartReception((infoPool)))
# define DescUsdtNetRingBufferCopyRoutine(infoPool, pDestination, dataLength) (DescUsdtNetLSRingBufferCopyRoutine((infoPool),(pDestination),(dataLength)))
#else
# define DescUsdtNetFinishReception(infoPool, status)                (DescUsdtNetAbsFinishReception((infoPool),(status)))
# define DescUsdtNetFinishTransmission(infoPool, status)             (DescUsdtNetAbsFinishTransmission((infoPool),(status)))
# define DescUsdtNetStartReception(infoPool)                         (DescUsdtNetAbsStartReception((infoPool)))
# define DescUsdtNetRingBufferCopyRoutine(infoPool, pDestination, dataLength) (DescUsdtNetAbsRingBufferCopyRoutine((infoPool),(pDestination),(dataLength)))
#endif

#define DescUudtNetInitPowerOn()                                     /* Not used */
#define DescUudtNetInit()                                            /* Not used */
#define DescUudtNetTimerTask()                                       /* Not used */
#define DescUudtNetStateTask()                                       /* Not used */

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnNetwork()                          (DescNetworkInitPowerOn())

#if defined(DESC_ENABLE_NODE_POWER_CONTROL) || (kDescNumContexts > 1)|| defined(DESC_ENABLE_SPONTANEOUS_RES)
static void DescNetworkOnceInit(void);
# define DescSubcompOnceInitNetwork()                                (DescNetworkOnceInit())
#else
# define DescSubcompOnceInitNetwork()                                (DescNetworkInit())
#endif
#define DescSubcompIterInitNetwork(iContext)                         (DescNetworkIterInit(DESC_CONTEXT_PARAM_ONLY))

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
# define DescIntToBitMap(integer)                                    (0x01 << (integer))
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
#  define DescNpmSetSleepReady(channel)                              (__DescNpmSetSleepReady(channel))
#  define DescNpmSetKeepAwake(channel)                               (__DescNpmSetKeepAwake(channel))
#  define DescIsNpmOnCanChannelActive(canChannel, canMap)            ((vuint8)(DescIntToBitMap(canChannel) & (canMap)) != kDescFalse)
#  define DescSetNpmOnCanChannelActive(canChannel, canMap)           ((canMap) |= DescIntToBitMap(canChannel))
#  define DescResetNpmOnCanChannelActive(canChannel, canMap)         ((canMap) &= (vuintx)(~DescIntToBitMap(canChannel)))
# else
#  define DescNpmSetSleepReady(channel)                              (__DescNpmSetSleepReady(0))
#  define DescNpmSetKeepAwake(channel)                               (__DescNpmSetKeepAwake(0))
#  define DescIsNpmOnCanChannelActive(canChannel, canMap)            ((canMap) != 0)
#  define DescSetNpmOnCanChannelActive(canChannel, canMap)           ((canMap) =  1)
#  define DescResetNpmOnCanChannelActive(canChannel, canMap)         ((canMap) =  0)
# endif
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
#  define DescGetMirroredQueue(canMap, canMapMirror)                 (canMapMirror)
# else
#  define DescGetMirroredQueue(canMap, canMapMirror)                 (canMap)
# endif
#endif
/* S1 timer decrementation mask */
#if (kDescNumContexts > 1)
# define DescSetConnectionActive(iContext)                           (g_descActiveRequestsMask |= ((vuint8)(kDescDescConnectionStateActive<<iContext)))
/* No interrutp lock, because it is already used (see DescDoPostProcessing) */
# define DescResetConnectionActive(iContext)                         (DescInterruptDisable(),(g_descActiveRequestsMask &= (vuint8)~(vuint8)(kDescDescConnectionStateActive<<iContext)),DescInterruptRestore())
# define DescIsNoExtConnectionActive()                               ((g_descActiveRequestsMask & (vuint8)(~(vuint8)(kDescReadDynPidConnStateActive | kDescRoeConnStateActive))) == 0)
# define DescIsNoConnectionActive()                                  (g_descActiveRequestsMask == 0)
#else
# define DescSetConnectionActive(iContext)                           /* not used */
# define DescResetConnectionActive(iContext)                         /* not used */
# define DescIsNoExtConnectionActive()                               /* not used */
/* Check if the diagnostic layer is in Idle Mode (ignore the periodic responses - they must not avoid S1 timer decrementation) */
# define DescIsNoConnectionActive()                                  (g_descInterruptContextCtrl[kDescPrimContext].isContextLocked == 0)
#endif

#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
# define DescUsdtNetAbsReleaseInfoPool(infoPool)                     (DescUsdtNetLSReleaseInfoPool((infoPool)))
# define DescUsdtNetAbsInitPowerOn()                                 (DescUsdtNetLSInitPowerOn())
# define DescUsdtNetAbsInit()                                        (DescUsdtNetLSInit())
# define DescUsdtNetAbsStateTask()                                   (DescUsdtNetLSStateTask())
# define DescUsdtNetAbsTimerTask()                                   (DescUsdtNetLSTimerTask())
# define DescUsdtNetAbsTransmitResponse(infoPool)                    (DescUsdtNetLSTransmitResponse((infoPool)))
# define DescUsdtNetAbsPrepareResponse(infoPool)                     (DescUsdtNetLSPrepareResponse((infoPool)))
#else
# define DescUsdtNetAbsReleaseInfoPool(infoPool)                     (DescUsdtNetReleaseInfoPool((infoPool)))
# define DescUsdtNetAbsInitPowerOn()                                 (DescUsdtNetInitPowerOn())
# define DescUsdtNetAbsInit()                                        (DescUsdtNetInit())
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsStateTask()                                   DescUsdtNetStateTask()
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsTimerTask()                                   DescUsdtNetTimerTask()
# define DescUsdtNetAbsTransmitResponse(infoPool)                    (DescUsdtNetTransmitResponse((infoPool)))
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsPrepareResponse(infoPool)                     DescUsdtNetPrepareResponse((infoPool))
#endif

#if defined(ApplDescOnBeginOfProcExt)
/* ok - some one needs it */
#else
# define ApplDescOnBeginOfProcExt()                                  /* Not used */
#endif

#if defined(ApplDescOnEndOfProcExt)
/* ok - some one needs it */
#else
# define ApplDescOnEndOfProcExt()                                    /* Not used */
#endif
#if defined (DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
# define DescGetAvailBufferLenByMsgContext(pMsgContext)              ((pMsgContext)->busInfo.availBufferLength)
# define DescGetAvailBufferLenByInfoPool(infoPool)                   ((infoPool)->busInfo.availBufferLength)
#else
# define DescGetAvailBufferLenByMsgContext(iContext)                 kDescPrimBufferLen
# define DescGetAvailBufferLenByInfoPool(infoPool)                   kDescPrimBufferLen
#endif
#define DescNetGetAvailBufferLenByIContext(iContext)                 (DescGetAvailBufferLenByInfoPool(g_descInterruptContextCtrl[(iContext)].infoPoolPtr))

/* Remap the node power function to the DPM API */
#define __DescNpmSetSleepReady(channel)                              (DpmDiagSleepReq((t_DpmUserNumber)(channel)))
#define __DescNpmSetKeepAwake(channel)                               (DpmDiagExtReq((t_DpmUserNumber)(channel)))
#define DescOemOnTxFrame()                                           /* Not used */
#define DescOemOnRxErrorInd(status)                                  /* Not used */
#define DescOemOnTxErrorInd(status)                                  /* Not used */
#define DescOemOnRxStart(infoPool)                                   /* Not used */
#define DescOemOnReqInd(iContext)                                    /* Not used */
/* Activate the S1 timer if necessary (Not in default session) */
#define DescOemOnConfirmation(iContext,status)                       /* Not used */

/* T2 timer macros */
#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# define DescActivateLimiter(iContext)                               (g_descRcrrpLimitCounter[iContext] = kDescRcrrpMaxTicks)
# define DescDeactivateLimiter(iContext)                             (g_descRcrrpLimitCounter[iContext] = 0)
#else
# define DescActivateLimiter(iContext)                               /* Not used */
# define DescDeactivateLimiter(iContext)                             /* Not used */
#endif

#define DescActivateT2Timer(iContext)                                (g_descT2Timer[iContext] = kDescP2InitValue)
#define DescReloadT2TimerWithP3maxTime(iContext)                     (g_descT2Timer[iContext] = kDescP2ReloadValue)
#define DescDeactivateT2Timer(iContext)                              (g_descT2Timer[iContext] = 0)

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnTiming()                           /* Not used */

#define DescSubcompOnceInitTiming()                                  (DescTimingOnceInit())
#define DescSubcompIterInitTiming(iContext)                          (DescTimingIterInit(DESC_CONTEXT_PARAM_ONLY))

/* S1 timer macros */
#define DescActivateS1Timer()                                        (g_descS1Timer = kDescS1TimerTicks)
#define DescReloadS1Timer()                                          (g_descS1Timer = kDescS1TimerTicks)
#define DescDeactivateS1Timer()                                      (g_descS1Timer = 0)

/* Oem specific timers during service execution */
#define DescOemTaskTimer()                                           /* Not used */

#define DescOemPreActiveTimer(iContext)                              /* Not used */
#define DescOemPostActiveTimer(iContext)                             /* Not used */

/* Oem specific timers desc idle mode */
#define DescOemDescIdleTimer()                                       /* Not used */

#define DescOemOnS1Timeout()                                         /* not used */

#define DescOemOnT2Timeout(iContext)                                 /* not used */
#define DescOemOnResPendingOvertime(iContext)                        /* not used */
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# define DescOemOnResPendingOverrun(iContext)                        (DescOemResPendingOverrun(DESC_CONTEXT_PARAM_ONLY))
/* No else since the count limit disables the whole code */
#endif

/* Protocol specific initialization */
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL) && \
    defined (DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION)
# define DescStateCompInitOnceGroup()                                (g_descIsOemMainHdlrAlreadyCalled = 0)
#endif
#if defined(DESC_ENABLE_AUTO_STATES)
# define DescOemOnTransitionSession(newState,currentState)           (DescOnTransitionStateSession((newState), (currentState)))
#endif

/* Internal API for INIT */
#if !defined(DescStateCompInitOnceOem)
# define DescStateCompInitOnceOem()                                  /* Not used */
#endif

#if !defined(DescStateCompInitOnceGroup)
# define DescStateCompInitOnceGroup()                                /* Not used */
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
# define DescStateCompInitOnceCore()                                 (DescStateOnceInit())
#else
# define DescStateCompInitOnceCore()                                 /* Not used */
#endif


#define DescSubcompOnceInitPowerOnState()                            /* Not used */
#define DescSubcompOnceInitState()                                   {DescStateCompInitOnceCore(); DescStateCompInitOnceGroup(); DescStateCompInitOnceOem()}
#define DescSubcompIterInitState(iContext)                           /* Not used */

#if defined (DESC_ENABLE_AUTO_STATES)
# if (kDescStateGroupNumTransition > 0)
static void DescSetState(DescSvcInstIndex svcInstHandle);
# else
#  define DescSetState(svcInstHandle)                                /* Not used */
# endif
static DescNegResCode DescCheckState (V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3 * refState);
#else
# define DescCheckState(a)                                           /* Not used */
# define DescSetState(svcInstHandle)                                 /* Not used */
#endif

#if defined(DescOemOnTransitionSession)
#else
  #define DescOemOnTransitionSession(newState, formerState)
#endif

#define DescSvcIsSupportedInStateSession(refState)                   (((refState)->stateSession & g_descCurState.stateSession) != 0)
/* Going to the default session */

#if defined (DESC_ENABLE_COMM_CTRL)
# define DESC_COMM_CTRL_REENABLE                                     DescEnableCommunication()
#else
# define DESC_COMM_CTRL_REENABLE
#endif
#if defined (VGEN_ENABLE_DPM) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
# define DESC_SET_SLEEP_INDICATION                                   DescNpmSetSleepInd()
#else
# define DESC_SET_SLEEP_INDICATION
#endif
#if defined (DESC_ENABLE_CONTROL_DTC_SETTING_SUPPORT)
# define DESC_DTC_SETTING_REENABLE                                   FrfmServiceSetStorageState(storageEnable)
#else
# define DESC_DTC_SETTING_REENABLE
#endif

#define DescOemOnTransitionToDefaultSession()                        {                            \
                                                                     DESC_COMM_CTRL_REENABLE;   \
                                                                     DESC_SET_SLEEP_INDICATION; \
                                                                     DESC_DTC_SETTING_REENABLE; \
                                                                     }

/* Going to a non-default session */
#define DescOemOnTransitionToNonDefaultSession()                     /* not used */
/* Session Transition notification */
#define DescOemOnSessionTransition()                                 /* not used */

#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/* Prototype exists in desc.h */
# if (kDescNumContexts > 1)
#  define _DescStartRepeatedServiceCall(iContext,mainHandler)        (DescStartRepeatedServiceCall(iContext, mainHandler))
# else
#  define _DescStartRepeatedServiceCall(iContext,mainHandler)        (DescStartRepeatedServiceCall(mainHandler))
# endif
#else
  /* Preprocessor workaround */
# define _DescStartRepeatedServiceCall(iContext,mainHandler)         /* Not active */
#endif
#define DescSubcompOnceInitPowerOnDispatcher()                       /* Not used */

#define DescSubcompOnceInitDispatcher()                              /* Not used */
#define DescSubcompIterInitDispatcher(iContext)                      (DescDispatcherIterInit(DESC_CONTEXT_PARAM_ONLY))

/* Extract the bit position from the handle and shift with one position more 
 * (start from 0x02 instead of 0x01) since the Bit0 is for the SId.
 */
#define DescGetSvcInstFailurePosMask(svcInstHandle)                  ((vuint8)(0x02<<((vuint8)((svcInstHandle)>>13))))

#define DescOemOnProcessingDone(iContext)                            /* Not used */
#define DescOemOnSvcNotFound(iContext)                               /* Not used */
#define DescOemOnSvcInstNotFound(iContext)                           /* Not used */
#define DescOemOnReqLengthNotMatched(iContext)                       /* Not used */
#define DescOemOnReqLengthTooSmall(iContext)                         /* Not used */
#define DescOemOnInvalidSidSession(iContext)                         /* Not used */
#define DescOemOnInvalidAddrMethod(iContext)                         /* Not used */
#define DescOemOnInvalidEcuState(iContext)                           /* Not used */
#define DescOemOnValidService(iContext)                              /* Not used */

/* API for inter sub-component initialization */
#define DescSubcompOnceInitPowerOnController()                       /* Not used */
#define DescSubcompOnceInitController()                              /* Not used */
#define DescSubcompIterInitController(iContext)                      /* Not used */

#define DescOemOnInit(initParam)                                     /* Not used */
#define DescOemOnPowerOnInit(initParam)                              /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnProcessor()                        /* Not used */
#define DescSubcompOnceInitProcessor()                               /* Not used */
#define DescSubcompIterInitProcessor(iContext)                       /* Not used */

#define ApplDescGenericServiceConfirmation(status)
#define DescOemCustomizeComTypeParam(pCommCtrlInfo)                  /* Not used */

/* -- Communication layer adapter -- */
/* Part offline function handler prototype */
#if defined (C_MULTIPLE_RECEIVE_CHANNEL)
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
#  if defined ( C_ENABLE_MULTI_ECU_CONFIG )
#   define DescCommSetTxOnline(channel, msgGroup)                    do { if ( (CanChannelIdentityAssignment[channel] & V_ACTIVE_IDENTITY_MSK) != (tVIdentityMsk)0 ) {CanPartOnline((channel), (msgGroup));} } while (0)
#   define DescCommSetTxOffline(channel, msgGroup)                   do { if ( (CanChannelIdentityAssignment[channel] & V_ACTIVE_IDENTITY_MSK) != (tVIdentityMsk)0 ) {CanPartOffline((channel), (msgGroup));} } while (0)
#  else
/* Code-doubled systems are excluded up to now */
#   define DescCommSetTxOnline(channel, msgGroup)                    CanPartOnline((CanChannelHandle)(channel), (vuint8)(msgGroup))
#   define DescCommSetTxOffline(channel, msgGroup)                   CanPartOffline((CanChannelHandle)(channel), (vuint8)(msgGroup))
#  endif
# else
#  define DescCommSetTxOnline(channel, msgGroup)                     CanPartOnline(0, (vuint8)(msgGroup))
#  define DescCommSetTxOffline(channel, msgGroup)                    CanPartOffline(0, (vuint8)(msgGroup))
# endif
#else
# define DescCommSetTxOnline(channel, msgGroup)                      CanPartOnline((vuint8)(msgGroup))
# define DescCommSetTxOffline(channel, msgGroup)                     CanPartOffline((vuint8)(msgGroup))
#endif
#if defined (DESC_ENABLE_RX_COMM_CONTROL)
# define DescMakeCommCtrlParam(txState,rxState)                      ((vuint8)(((rxState) << 2)|(txState)))
#else
# define DescMakeCommCtrlParam(txState,rxState)                      ((vuint8)(txState))
#endif

#define DescSubcompOnceInitPowerOnFaultMemory()                      (DescFaultMemoryOnceInitPowerOn())
#define DescSubcompOnceInitFaultMemory()                             /* Not used */
#define DescSubcompIterInitFaultMemory(iContext)                     /* Not used */


/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnSecurityAccess()                   /* Not used */
#define DescSubcompOnceInitSecurityAccess()                          /* Not used */
#define DescSubcompIterInitSecurityAccess(iContext)                  /* Not used */
#define DescOemOnInvalidRequest(iContext)                            /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnPidManager()                       /* Not used */
#define DescSubcompOnceInitPidManager()                              /* Not used */
#define DescSubcompIterInitPidManager(iContext)                      /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnRidManager()                       /* Not used */
#define DescSubcompOnceInitRidManager()                              /* Not used */
#define DescSubcompIterInitRidManager(iContext)                      /* Not used */

#if defined (DESC_ENABLE_RID_OPTIMIZED_USAGE)
#endif

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnScheduled()                        /* Not used */
#define DescSubcompOnceInitScheduled()                               /* Not used */
#define DescSubcompIterInitScheduled(iContext)                       /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnPidListProcessor()                 /* Not used */
#define DescSubcompOnceInitPidListProcessor()                        /* Not used */
#define DescSubcompIterInitPidListProcessor(iContext)                /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnDynDefinePid()                     /* Not used */
#define DescSubcompOnceInitDynDefinePid()                            /* Not used */
#define DescSubcompIterInitDynDefinePid(iContext)                    /* Not used */

/* Hook functions for PID manager */
#define DescPmClientCheckPid(result, pid)                            (result)
#define DescPmClientGetResLength(pidHandle)                          ((vuint8)0)


/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnDynDefineDpid()                    /* Not used */
#define DescSubcompOnceInitDynDefineDpid()                           /* Not used */
#define DescSubcompIterInitDynDefineDpid(iContext)                   /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnRoeProcessor()                     /* Not used */
#define DescSubcompOnceInitRoeProcessor()                            /* Not used */
#define DescSubcompIterInitRoeProcessor(iContext)                    /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnVariantManager()                   /* Not used */
#define DescSubcompOnceInitVariantManager()                          /* Not used */
#define DescSubcompIterInitVariantManager(iContext)                  /* Not used */



/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

/* Check if this feature is enabled */
#if defined (GEN_MAGIC_NUMBER_V_CFG) && \
    defined (kDescIntegrationMagicNumber)
/* begin Fileversion check */
# if (GEN_MAGIC_NUMBER_V_CFG != kDescIntegrationMagicNumber)
#  error "The magic number of the generated header v_cfg.h is different! Check time and date of generated files!"
# endif
#endif

/******************************************************************************
* All necessary preprocessor directives existence checks
******************************************************************************/
#if !defined(DESC_ENABLE_RES_PENDING_TIME_LIMIT) && \
    !defined(DESC_DISABLE_RES_PENDING_TIME_LIMIT)
# error "Missing switch DESC_XXXABLE_RES_PENDING_TIME_LIMIT!"
#endif

#if !defined(DESC_ENABLE_RES_PENDING_COUNT_LIMIT) && \
    !defined(DESC_DISABLE_RES_PENDING_COUNT_LIMIT)
# error "Missing switch DESC_XXXABLE_RES_PENDING_COUNT_LIMIT!"
#endif

#if defined (kDescNumContexts)
# if (kDescNumContexts == 0)
#  error "No diagnostic connection will be available!"
# endif
#else
# error "Missing kDescNumContexts define!"
#endif
/******************************************************************************
*  Conditional checks
******************************************************************************/
#if defined(DESC_ENABLE_MULTI_TP)
# if defined(DESC_ENABLE_SINGLE_TP_OPTIMIZED)
#  error "Could not be used both transport layers types!"
# endif
#elif defined(DESC_DISABLE_MULTI_TP)
# if defined(DESC_DISABLE_SINGLE_TP_OPTIMIZED)
#  error "At least one transport layer type must be selected!"
# endif
#else
# error "Missing switch DESC_XXXABLE_MULTI_TP!"
#endif

#if !defined(DESC_ENABLE_SINGLE_TP_OPTIMIZED) && \
    !defined(DESC_DISABLE_SINGLE_TP_OPTIMIZED)
# error "Missing switch DESC_XXXABLE_SINGLE_TP_OPTIMIZED!"
#endif

#if defined(DESC_ENABLE_RES_PENDING_TIME_LIMIT) && \
    defined(DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# error "Both type of response pending limitations are not possible at the same time!"
#endif

#if defined (C_MULTIPLE_RECEIVE_CHANNEL) || defined (C_SINGLE_RECEIVE_CHANNEL)
/* config ok */
#else
/* code doubled system */
# if (kDescNumCommChannels > 1)
#  if defined (kDescCanChannel)
/* config ok */
#  else
#   error "Missing kDescCanChannel define!"
#  endif
# endif
#endif


#if defined (DESC_ENABLE_DEBUG_INTERNAL)
/*******************************************************************************
* NAME:              CheckIndexTableConsistency
*
* CALLED BY:         DescInitPowerOn
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs check if the table relations are consistent, and 
*                    if all main handler functions are not V_NULL.
*
*******************************************************************************/
static void CheckTableConsistency(void)
{
# if defined( C_COMP_IAR_M16C )
#  if defined ( _NEAR_ )
  static vuint8  sidCnt;
  static DescSvcInstIndex i;
#  else
  vuint8  sidCnt;
  DescSvcInstIndex i;
#  endif
# else
  vuint8  sidCnt;
  DescSvcInstIndex i;
# endif
  /*--------------------------*/
  /*   Check SID references   */
  /*--------------------------*/
  sidCnt = 0;
  for (i = 0; i < kDescSvcIdMapSize; i++)
  {
    if (g_descSidMap[i] != 0xff)
    {
       /* Will be used for checking if all sid are referenced */
       sidCnt++;
        /* unexisting reference (-1 due to the dummy entry */
       DescAssertInternal((g_descSidMap[i] < (kDescSvcHeadNumItems - 1)),
                         kDescAssertIndexTableInvalidReference
                       );
    }
  }
  DescAssertInternal((sidCnt == (kDescSvcHeadNumItems - 1)),
                    kDescAssertSvcTableUnreachableItem
                  );
  /*--------------------------------*/
  /*  Check SID To SINST references */
  /*--------------------------------*/
  for (i = 0; i < (kDescSvcHeadNumItems - 1); i++)
  {
    DescAssertInternal((g_descSvcHead[i].svcInstFirstItem < kDescSvcInstNumItems),
                      kDescAssertSvcTableInvalidReference
                    );
  }
# if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
  /* Check the last line content (must be exactly the last line number of the svcInst table) */
  DescAssertInternal((g_descSvcHead[i].svcInstFirstItem == (kDescSvcInstNumItems - 1)),
                    kDescAssertSvcTableInvalidReference
                  );
# else
  /* Check the dummy line content */
  DescAssertInternal((g_descSvcHead[i].svcInstFirstItem == kDescSvcInstNumItems),
                    kDescAssertSvcTableInvalidReference
                  );
# endif
  /*--------------------------------*/
  /*  Check Main handler existence  */
  /*--------------------------------*/
  for (i = 0; i < kDescSvcInstNumItems; i++)
  {
    DescAssertInternal((g_descSvcInst[i].mainHandler != V_NULL), kDescAssertMissingMainHandler);
  }
}
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL) || \
    defined (DESC_ENABLE_DEBUG_USER)
/*******************************************************************************
* NAME:              DescDebugIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the debug subcomponent context specific data.
*
*******************************************************************************/
static void DescDebugIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
}
#endif

/******************************************************************************
* All necessary preprocessor directives existence checks
******************************************************************************/
#if !defined(DESC_ENABLE_ADDR_METHOD_CHECK_ON_SID) && \
    !defined(DESC_DISABLE_ADDR_METHOD_CHECK_ON_SID)
# error "Missing switch DESC_XXXABLE_ADDR_METHOD_CHECK_ON_SID!"
#endif

/* Node power management configuration validation*/
#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && \
    !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION) && \
    !defined (DESC_ENABLE_COMMON_OEM_POST_HANDLER)
# error "Enable OEM-post-handler support on service $10"
#endif

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInitPowerOn
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Power on initialization
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInitPowerOn(void)
{
  DescUsdtNetIsoTpInit();
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInitContext
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Re-initialization 
*                    
*                    
*******************************************************************************/
static void DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  vuint8  descTmpTxChannel;

  /* Find a channel for TP */
  descTmpTxChannel = TpTxGetConnectionStatus(DescGetConnectionOfContext(DESC_TPCONTEXT_PARAM_VALUE));
  if(descTmpTxChannel == kTpNoChannel)
  {
    if( (g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] = TpTxGetFreeChannel(DescGetConnectionOfContext(DESC_TPCONTEXT_PARAM_VALUE))) != kTpNoChannel )
    {
      TpTxLockChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
#  if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      /* Initialize the transmission type */
      g_descTpCtrl.txPath[g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]].type = kDescMainTransmission;
#  endif
    }
  }
#  if defined (DESC_ENABLE_DEBUG_INTERNAL)
  else
  { /* The TX channel is still locked but is it the same as before? */
    DescUsdtNetIsoTpAssertChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] == descTmpTxChannel, kDescAssertWrongTpTxChannel);
  }
#  endif
  DescUsdtNetIsoTpAssertChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] != kTpNoChannel, kDescAssertWrongTpTxChannel);
# endif
#endif

#if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.availBufferLength = kDescPrimBufferLen;
#endif
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resDataPtr = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resType = kDescUsdtResponseNone;
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInit
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Re-initialization 
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInit(void)
{
  { /* Init tx resources */
    vuint8_least resIter = kTpTxChannelCount;
    while(resIter != 0)
    {
      resIter--;
      g_busInfoPoolTxRef[resIter] = V_NULL;
    }
  }

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  {
    vuint8_least addIter = kDescNumAddRequestChannels;

    g_descAddChannelCtrl.count = 0;
    while(addIter != 0)
    {
      --addIter;
      g_descAddChannelCtrl.channel[addIter].status = kDescContextIdle;
    }
  }
#endif

  DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
#if defined (DESC_ENABLE_PARALLEL_OBD)
  DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(kDescObdContext));
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION) && \
    (kDescNumFuncReqContexts > 0)
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].descHandle = kDescUsdtNetInvalidDescContext;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].reqDataPtr = g_descSecBuffer;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].resDataPtr = g_descSecBuffer;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].resType = kDescUsdtResponseNone;
# if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].busInfo.availBufferLength = kDescSecBufferLen;
# endif
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpStateTask
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       State Task of the IsoTp driver
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpStateTask(void)
{
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  /* Process additional requests */
  DescBusyResponseHandler();
#endif
}

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY) && \
     defined (DESC_DISABLE_EXTERNAL_CHECK_TA)
/*******************************************************************************
* NAME:              DescCheckTA
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Target address evaluation.
*                    
*******************************************************************************/
t_ta_type DescCheckTA (vuint8 targetAddress)
{
  t_ta_type returnValue = kTpNone;

  if (targetAddress == TP_ECU_NUMBER)
  {
    returnValue = kTpPhysical;
  }
  else
  {
    if (targetAddress == kDescOemExtAddrFuncTargetAddr)
    {
      returnValue = kTpFunctional;
    }
  }
  return returnValue;
}
# endif
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
/*******************************************************************************
* NAME:              DescDispatchServiceContext
*
* CALLED BY:         Desc start reception event
* PRECONDITIONS: 
*
* DESCRIPTION:       this function dispatches the parallel request reception target context
*******************************************************************************/
static vuint8 DescDispatchServiceContext(vuint8 sid)
{
  vuint8 result = kDescPrimContext; /* Main connection */

  /* OBD predispatching for request routing */
  if((sid > 0x00) && (sid < 0x10))
  {
    result = kDescObdContext;
  }
  return result;
}
#endif

/*******************************************************************************
* NAME:              DescGetBuffer
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*******************************************************************************/
TP_MEMORY_MODEL_DATA vuint8* DescGetBuffer(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint16 dataLength)
{
  DescUsdtNetMsg returnValue = V_NULL;

#if (defined (DESC_ENABLE_PHYSREQ_TA_CHECK) || defined (DESC_ENABLE_PHYSREQ_SA_CHECK))
  DescBool addressCheckResult;

# if defined (DESC_ENABLE_PHYSREQ_TA_CHECK)
  addressCheckResult = DescOemCheckPhysTargetAddress(TpGetTargetAddress(TP_CHANNEL_RX_PARAM_ONLY));
  if(addressCheckResult == kDescTrue)
# endif
  {
# if defined (DESC_ENABLE_PHYSREQ_SA_CHECK)
    addressCheckResult = DescOemCheckPhysSourceAddress(TpRxGetSourceAddress(TP_CHANNEL_RX_PARAM_ONLY));
# endif
  }

  if(addressCheckResult == kDescTrue)
#endif
  {
#if defined (DESC_ENABLE_PARALLEL_OBD)
    DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
    DESC_TPCONTEXT_PARAM_VALUE = DescDispatchServiceContext(TpRxGetCanBuffer(tpRxChannel)[0]);
#endif

    if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle == kDescUsdtNetInvalidDescContext)
    {
      if(dataLength > kDescPrimBufferLen)
#if defined (DESC_ENABLE_NEGRES_ON_MSG_TOO_LONG)
      {
        /* Force only one frame copy, length validation should fail later on causing NRC message */
        TpRxSetBufferOverrun(TP_CHANNEL_RX_PARAM_ONLY);
      } /* no else required in that case - a valid reception has to be simulated */
#else
      {
# if ((TP_ISO15765_VERSION >= 0x0273) && defined (TP_ENABLE_ISO_15765_2_2))
#  if (TP_ISO15765_VERSION >= 0x0277)
        TpRxSetFCStatus(TP_CHANNEL_RX_PARAM_FIRST kTpFCStatusOverflow);
#  else
#   error "Incompatible TPMC Version - please use version 2.77+"
#  endif
# else
        /* returnValue = V_NULL; it is already default */
# endif
      } /* discard reception */
      else
#endif
      {
        t_descUsdtNetResult result;
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
        t_ta_type ta_type;
# endif
#endif
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.busType   = kDescUsdtNetBusTypeIsoTp;
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress = TpRxGetSourceAddress(TP_CHANNEL_RX_PARAM_ONLY);
        /* Make the tester ID visible to the above layer */
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.testerId = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress;

    /* g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetReceivedTargetAddress (TP_CHANNEL_RX_PARAM_VALUE); */
#endif

#if ( kCanNumberOfChannels > 1 ) /* more than one canChannel ? */
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpRxGetCanChannel(TP_CHANNEL_RX_PARAM_ONLY);
# else
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpRxGetCanChannel();
# endif
        /* Make the communication channel ID visible to the above layer */
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.comChannel = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle         = TP_CHANNEL_RX_PARAM_VALUE;
#endif

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_ENABLE_MULTIPLE_ADDRESSING)
          /*ktw: This check should be used for all Multi Addressing Tps =>*/
        if(TpRxGetAddressingFormat(TP_CHANNEL_RX_PARAM_ONLY) == kTpExtendedAddressing)
# endif
        {
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY) /*It has to be actviated for Extended Addressing */
          ta_type = TpRxGetTaType(TP_CHANNEL_RX_PARAM_ONLY);
          if (ta_type == kTpPhysical)
# endif
#endif
          {
            g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType         = kDescUsdtNetReqTypePhysical;
          }
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
          else
          {
            g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType         = kDescUsdtNetReqTypeFunctional;
          }
# endif

        }
# if defined (TP_ENABLE_MULTIPLE_ADDRESSING)
        else
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType   = (t_descUsdtNetReqType)((TpRxGetAssignedDestination(TP_CHANNEL_RX_PARAM_ONLY) == kTpRequestDiagPhysical) ? kDescUsdtNetReqTypePhysical: kDescUsdtNetReqTypeFunctional);
        }
# endif
#endif

        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].dataLength        = dataLength;
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle        = DESC_TPCONTEXT_PARAM_VALUE; /* Write used context */

        /* Check if Desc itself is free */
        result = DescUsdtNetStartReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE]);
        if(result == kDescUsdtNetworkOk)
        { /* it is */
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
          /* store the connection type */
          g_descTpCtrl.rxPath[tpRxChannel].type = kDescMainReception;
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
          /* store the working context type */
          g_busInfoPoolRxRef[tpRxChannel] = &g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE];
#endif
          returnValue = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr;
        }
        else
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext; /* Write used context */
        }
      }
    }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    else
    { /* check if an additional request channel is free */
      vuint8_least iter;
      iter = kDescNumAddRequestChannels;
      while( iter != 0 )
      {
        --iter;
        if(g_descAddChannelCtrl.channel[iter].status == kDescContextIdle)
        {
          g_descAddChannelCtrl.channel[iter].status = kDescContextActiveRx;
          /* Force only one frame copy */
          TpRxSetBufferOverrun(TP_CHANNEL_RX_PARAM_ONLY);
          g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_ONLY].type = kDescAddReception;
          g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_ONLY].info = (vuint8)iter;
          returnValue = g_descAddChannelCtrl.channel[iter].buffers.reqBuffer;
          /* Break */
          iter = 0;
        }
      }
    }
#endif
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              DescPhysReqInd
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Rx path for physical requests.
*                    Function name must be entered to the CANgen OSEK-TP Options 
*                    dialog in the fields "RxIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescPhysReqInd(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint16 dataLen)
{
  DESC_IGNORE_UNREF_PARAM(dataLen);

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].type)
  {
  case kDescMainReception:
#endif
    {
#if defined (DESC_ENABLE_PARALLEL_OBD)
      DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
      DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[TP_CHANNEL_RX_PARAM_VALUE]->descHandle;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      DescUsdtNetIsoTpAssertChannel(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == TP_CHANNEL_RX_PARAM_VALUE, kDescNetAssertWrongIsoTpRxChannel);
#endif
      /*-----------------------------*/
      /*Transport protocol management*/
      /*-----------------------------*/
#if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
#else
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.Connection = TpRxGetConnectionNumber(TP_CHANNEL_RX_PARAM_ONLY);
#endif
#if defined (TP_ENABLE_DYNAMIC_CHANNELS)
# if defined (TP_ENABLE_NORMAL_ADDRESSING)       || \
     defined (TP_ENABLE_MIXED_11_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.ReceiveID = TpRxGetChannelID(TP_CHANNEL_RX_PARAM_ONLY);
#  if defined (TP_FUNC_ENABLE_RECEPTION)
      if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType == kDescUsdtNetReqTypeFunctional)
      {
        TpFuncSetResponse(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
      }
      else
#  endif
      {
        TpTxSetResponse(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle, g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
      }
# endif
#endif
#if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetEcuNumber(TP_CHANNEL_RX_PARAM_ONLY);
#else
# if (TP_USE_EXTENDED_ADDRESSING == kTpOn) || \
     defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
     defined (TP_ENABLE_MIXED_29_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = kDescEcuNumber;
# endif
#endif
#if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
# if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.BaseAddress = TpRxGetBaseAddress(TP_CHANNEL_RX_PARAM_ONLY);
# endif
#endif
      /* Reception has finished */
      DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkOk);
      /* Reset the channel */
      TpRxResetChannel(TP_CHANNEL_RX_PARAM_ONLY);
    }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    break;
  case kDescAddReception:
    /* Increase succesfully received additionally requests */
    DescUsdtNetIsoTpAssertUser((g_descAddChannelCtrl.count < kDescNumAddRequestChannels), kDescAssertIllegalAddRequestCount);

# if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* Process any SID */
# else
    /* Check for invalid SID (if bit6 set -> SID from the response ID page received. */
    if((g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.reqBuffer[0] & 0x40) == 0)
# endif
    {
      if(g_descAddChannelCtrl.count < kDescNumAddRequestChannels)
      {
        g_descAddChannelCtrl.count++;
      }
      /* Store tpRxChannel in buffer*/
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.tpRxChannel = TP_CHANNEL_RX_PARAM_VALUE;
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextActiveProcess;
      /* write the negative response code */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[2] = 0x21;
      /* copy SID onto the right place */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[1] = g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.reqBuffer[0];
      /* write the negative response identifier */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[0] = 0x7f;
    }
# if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* nothing to do */
# else
    else
    {
      /* Reset the additional channel state */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextIdle;
      TpRxResetChannel(TP_CHANNEL_RX_PARAM_VALUE);
    }
# endif
    break;
  default:
    /* Unknown type */
    DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
    break;
  }
#endif
}


/*******************************************************************************
* NAME:              DescRxErrorIndication
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Release the lock mechanism for Rx on error by receiving.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpXXXErrorIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescRxErrorIndication(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(status);
  TP_CHANNEL_RX_PARAM_IGNORE_UNREF;

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].type)
  {
    case kDescMainReception:
#endif
      {
#if defined (DESC_ENABLE_PARALLEL_OBD)
        DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
        DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[TP_CHANNEL_RX_PARAM_VALUE]->descHandle;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        DescUsdtNetIsoTpAssertChannel(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == TP_CHANNEL_RX_PARAM_VALUE, kDescNetAssertWrongIsoTpRxChannel);
#endif
        /* reception error - notify CANdesc */
        DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkAbort);
      }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      break;
    case kDescAddReception:
      /* reset the additional cahnnel status */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextIdle;
      break;
    default:
      /* Unknown type */
      DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
      break;
  }
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpPrepareResponse
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Prepare address info for response message
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
  vuint8 sourceAddress;

  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);

  /* Swap Source- and TargetAddress */
  sourceAddress = infoPool->busInfo.addressingInfo.isoTp.SourceAddress;
  infoPool->busInfo.addressingInfo.isoTp.SourceAddress  = infoPool->busInfo.addressingInfo.isoTp.TargetAddress;
  infoPool->busInfo.addressingInfo.isoTp.TargetAddress = sourceAddress;
#else
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(infoPool);
#endif
}

/*******************************************************************************
* NAME:              DescTransmitResponse
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Response transmission function
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
  vuint8 result;
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) || defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) )
  vuint8 tpTxChannel;
# endif
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
#endif
  volatile t_descUsdtNetInfoPoolPtr* lBusInfoPoolTxRef;

  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);

#if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_VALUE = infoPool->descHandle;
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  tpTxChannel = g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE];
  infoPool->busHandle = tpTxChannel;
# else
#  if defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
  tpTxChannel = g_descCan2TpChannelMap[DESC_COMM_CHANNEL_PARAM_WRAP_INDEX(infoPool->busInfo.comChannel)];
#  endif
# endif
#endif
  /* Avoid compiler optimization */
  lBusInfoPoolTxRef = &g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE];

  /* Busy ? */
  if(*lBusInfoPoolTxRef != V_NULL)
  {
    DescInterruptDisable();
    /* Still busy ? */
    if(*lBusInfoPoolTxRef != V_NULL)
    {
      t_descUsdtNetInfoPoolPtr lBusInfoPoolTxRefBackup;
      /* Push old content */
      lBusInfoPoolTxRefBackup = g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE];
      /* assign temporarly the new resource to be finalized */
      g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = infoPool;
      /* Cancel the transmission */
      DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST kTpBusy);
      /* Pop old content */
      g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = lBusInfoPoolTxRefBackup;
      DescInterruptRestore();
      return;
    }
    DescInterruptRestore();
  }

  g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = infoPool;

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)     || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
  TpTxSetTargetAddress (TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.testerId); /* use the abstract info for spontaneus responses */
#endif
#if ( kTpNumberOfCanChannels > 1 ) /* more than one canChannel ? */
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  TpTxSetCanChannel(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.comChannel);/* use the abstract info for spontaneus responses */
# endif
#endif
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
# if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
  TpTxSetEcuNumber(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.addressingInfo.isoTp.SourceAddress);
# endif
#endif
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
  TpTxSetBaseAddress(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.addressingInfo.isoTp.BaseAddress);
# endif
#endif

#if (!defined (TP_ENABLE_DYNAMIC_CHANNELS) && !defined (TP_ENABLE_SINGLE_CHANNEL_TP))
# if defined (DESC_ENABLE_DESC_ON_MULTI_CAN) && \
     !defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
/* In order to use CANdesc on multiple CANchannels, define DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND 
 * in your user config file and define the CAN to TPconnection association e.g.:
  #define kDescCan2TpChannel_0    1 - if CAN 0 corresponds to TPconnection 1 */
#  error "CANdesc on multiple CANchannels needs DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND!"
# endif
#endif

#if (!defined (TP_ENABLE_DYNAMIC_CHANNELS) && !defined (TP_ENABLE_SINGLE_CHANNEL_TP))
  /* Overwrite the 0xFE value to avoid assertions to be miscalled. */
  infoPool->busHandle = TP_CHANNEL_TX_PARAM_VALUE;
  /* CAN-channel to TP-channel */
  DescUsdtNetIsoTpAssertUser((TP_CHANNEL_TX_PARAM_VALUE != kTpNoChannel), kDescNetAssertWrongIsoTpTxChannel);

# if defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
  result = DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_VALUE, infoPool->resDataPtr, infoPool->dataLength);
# else
#  if defined(DESC_ENABLE_DOBT_SUPPORT)
#   error "DOBT on static multi TPMC is not supported!"
#  endif
  result = TpTransmitDiag(infoPool->resDataPtr, infoPool->dataLength);
# endif
#else
  result = DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_VALUE, infoPool->resDataPtr, infoPool->dataLength);
#endif
  if (result != kTpSuccess)
  { /* Cancel the transmission */
    DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST result);
  }
}

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
/*******************************************************************************
* NAME:              DescUsdtNetIsoTpGetRingBuffTxMinLen
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS:
*
* DESCRIPTION:       Get Minimum Length
*
*
*******************************************************************************/
DESCNET_USDT_STATIC vuint16 DescUsdtNetIsoTpGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool)
{
  DESC_IGNORE_UNREF_PARAM(infoPool);
  return (vuint16) 0x06;
}
#endif

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpCopyToCan
*
* CALLED BY:         DescCopyToCAN
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides abstract copy functionality between CANdriver and DANIS.
*******************************************************************************/
static void DescUsdtNetIsoTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct)
{
  vuint8_least i = infoStruct->Length;
  while(i--)
  {
    infoStruct->pDestination[i] = infoStruct->pSource[i];
  }
}

/*******************************************************************************
* NAME:              DescCopyToCAN
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Callback for filling the data into the Tx buffer.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpCopyToCan".
*******************************************************************************/
vuint8 TP_API_CALLBACK_TYPE DescCopyToCAN(TpCopyToCanInfoStructPtr infoStruct)
{
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
  vuint8 returnValue = kTpFailed;
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
#  if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) || defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) )
  vuint8 TP_CHANNEL_TX_PARAM_ONLY = infoStruct->Channel;
#  endif
# endif
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.txPath[infoStruct->Channel].type)
  {
    case kDescMainTransmission:
#endif
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      DescUsdtNetIsoTpAssertChannel(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE, kDescNetAssertWrongIsoTpTxChannel);
# endif
      if (g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->resType == kDescUsdtResponseRingBuffer)
      {
        t_descUsdtNetResult result;
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
        result = DescUsdtNetRingBufferCopyRoutine(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], &g_descCopyToCanData[0], (vuint8)infoStruct->Length);
# else
        result = DescUsdtNetRingBufferCopyRoutine(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], (DescUsdtNetMsg)infoStruct->pDestination, (vuint8)infoStruct->Length);
# endif
        if (result == kDescUsdtNetworkOk)
        {
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
          infoStruct->pSource = &g_descCopyToCanData[0];
          DescUsdtNetIsoTpCopyToCan(infoStruct);
# endif
          returnValue = kTpSuccess;
        }
      }
      else
      {
        DescUsdtNetIsoTpCopyToCan(infoStruct);
        returnValue = kTpSuccess;
      }
      return returnValue;
#else
      {
        DescUsdtNetIsoTpCopyToCan(infoStruct);
        return kTpSuccess;
      }
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    case kDescAddTransmission:
      DescUsdtNetIsoTpCopyToCan(infoStruct);
      return kTpSuccess;   /*Everythings ok now*/
    default:
      /* Unknown type */
      break;
    }
    DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
    return kTpSuccess;   /*Everythings ok now*/
#endif
}

/*******************************************************************************
* NAME:              DescConfirmation
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides the post transmission processing.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpConfirmation".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescConfirmation(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  t_descUsdtNetResult result;
  TP_CHANNEL_TX_PARAM_IGNORE_UNREF;

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.txPath[tpTxChannel].type)
  {
    case kDescMainTransmission:
#endif
      {
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        DescUsdtNetIsoTpAssertChannel(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE, kDescNetAssertWrongIsoTpTxChannel);
#endif
        /* Translate the TP parameter to the DESC_NET type */
        result = (status != kTpSuccess) ? kDescUsdtNetworkAbort:kDescUsdtNetworkOk;

        DescUsdtNetFinishTransmission(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], result);
      /* No response any more is reset by CANdesc (DescUsdtNetFinishTransmission) */
      /* g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->resType = kDescUsdtResponseNone;*/
      }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      break;
    case kDescAddTransmission:
      /* Decrease pending count of additionally requests */
      DescUsdtNetIsoTpAssertUser((g_descAddChannelCtrl.count != 0), kDescAssertIllegalAddRequestCount);
      if(g_descAddChannelCtrl.count != 0)
      {
        g_descAddChannelCtrl.count--;
      }

      g_descAddChannelCtrl.channel[g_descTpCtrl.txPath[tpTxChannel].info].status = kDescContextIdle;
      break;
    default:
      /* Unknown type */
      DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
      break;
  }
#endif

  g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = V_NULL;
}

/*******************************************************************************
* NAME:              DescTxErrorIndication
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Release the lock mechanism for Tx on error by sending.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpXXXErrorIndication".
*******************************************************************************/
vuint8 TP_API_CALLBACK_TYPE DescTxErrorIndication(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(status);
  TP_CHANNEL_TX_PARAM_IGNORE_UNREF;

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  if (g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE)
#endif
  {
    /* Flush the response */
    DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST status);
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    switch (g_descTpCtrl.txPath[tpTxChannel].type)
    {
      case kDescMainTransmission:
#endif
        return kTpHoldChannel;
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      case kDescAddTransmission:
        return kTpFreeChannel;
      default:
        /* Unknown type */
        DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
        return kTpFreeChannel;
    }
#endif
  }
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  else
  {
    return kTpFreeChannel;
  }
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpReleaseInfoPool
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Release of infopool
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool)
{
  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);
  infoPool->descHandle = kDescUsdtNetInvalidDescContext;
}


#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/******************************************************************************
* NAME:              DescBusyResponseHandler
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Busy response handler for additional received requests
*
*******************************************************************************/
static void DescBusyResponseHandler(void)
{
  vuint8_least addIter;
  vuint8       tpTxChannel;

  /* */
  if (g_descAddChannelCtrl.count != 0)
  {
    addIter = kDescNumAddRequestChannels;
    while(addIter != 0)
    {
      --addIter;
      if(g_descAddChannelCtrl.channel[addIter].status == kDescContextActiveProcess)
      {
        tpTxChannel = TpTxGetFreeChannel(kDescDiagAddConnection);
        if (tpTxChannel != kTpNoChannel)
        {
          g_descTpCtrl.txPath[tpTxChannel].type = kDescAddTransmission;
          /* store additional request channel number */
          g_descTpCtrl.txPath[tpTxChannel].info = (vuint8)addIter;
          /* copy the TP addressinformations from rx channel to tx channel */
          /* tpRxChannel is stored in 6.th byte of dummy buffer */
          TpTxSetResponse(g_descAddChannelCtrl.channel[addIter].buffers.res.tpRxChannel, tpTxChannel);

          g_descAddChannelCtrl.channel[addIter].status = kDescContextActiveTx;

          if (DanisIsoTpTransmit(tpTxChannel, g_descAddChannelCtrl.channel[addIter].buffers.res.resBuffer, 3) == kTpSuccess)
          {
            TpRxResetChannel(g_descAddChannelCtrl.channel[addIter].buffers.res.tpRxChannel);
          }
          else
          { /* If we can not send the data, we have to terminate this channel and try it at next cycle */
            g_descAddChannelCtrl.channel[addIter].status = kDescContextActiveProcess;
            TpTxResetChannel(tpTxChannel);
          }
        }
      }
    }
  }
}
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION) && \
    !defined (TP_ENABLE_EXTENDED_ADDRESSING)
/*******************************************************************************
* NAME:              DescGetFuncBuffer
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*******************************************************************************/
TP_MEMORY_MODEL_DATA vuint8* TP_API_CALLBACK_TYPE DescGetFuncBuffer(vuint16 dataLength)
{
  DescUsdtNetMsg returnValue = V_NULL;

# if (defined (DESC_ENABLE_FUNCREQ_TA_CHECK) || defined (DESC_ENABLE_FUNCREQ_SA_CHECK))
  DescBool addressCheckResult;

#  if defined (DESC_ENABLE_FUNCREQ_TA_CHECK)
  addressCheckResult = DescOemCheckFuncTargetAddress(TpFuncGetTargetAddress());
  if(addressCheckResult == kDescTrue)
#  endif
  {
#  if defined (DESC_ENABLE_FUNCREQ_SA_CHECK)
    addressCheckResult = DescOemCheckFuncSourceAddress(TpFuncGetSourceAddress());
#  endif
  }

  if(addressCheckResult == kDescTrue)
# endif
  {
# if defined (DESC_ENABLE_PARALLEL_OBD)
    DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
    DESC_TPCONTEXT_PARAM_VALUE = DescDispatchServiceContext(TpFuncGetCanBuffer()[0]);
# endif
    if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle == kDescUsdtNetInvalidDescContext)
    {
      t_descUsdtNetResult result;

      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.busType   = kDescUsdtNetBusTypeIsoTp;
# if ( kCanNumberOfChannels > 1 ) /* more than one canChannel ? */
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpFuncGetCanChannel();
      /* Make the communication channel ID visible to the above layer */
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.comChannel = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel;
# endif
# if defined (TP_ENABLE_EXTENDED_ADDRESSING)      || \
     defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
     defined (TP_ENABLE_MIXED_29_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress = TpFuncGetSourceAddress();
      /* Make the tester ID visible to the above layer */
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.testerId = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress;

    /* g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetReceivedTargetAddress (TP_CHANNEL_RX_PARAM_VALUE); */
# endif
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle         = 0xfe;
# endif
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType           = kDescUsdtNetReqTypeFunctional;
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resType           = kDescUsdtResponseNone;
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr        = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resDataPtr        = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].dataLength        = dataLength;
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle        = DESC_TPCONTEXT_PARAM_VALUE; /* Write used context */
      /* Check if Desc itself is free */
      result = DescUsdtNetStartReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE]);
      if(result == kDescUsdtNetworkOk)
      { /* it is */
        returnValue = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr;
# if defined (DESC_ENABLE_PARALLEL_OBD)
       /* store the working context type */
       g_busInfoPoolRxRef[kDescUsdtNetFuncInfPoolRef] = &g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE];
# endif
      }
      else
      {
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
      }
    }
  }
  /* discard reception */
  return returnValue;
}

/*******************************************************************************
* NAME:              DescFuncReqInd
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Rx path for physical requests.
*                    Function name must be entered to the CANgen OSEK-TP Options 
*                    dialog in the fields "RxIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescFuncReqInd(vuint16 dataLen)
{
# if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_DEF_LOCAL
# endif

  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(dataLen);

# if defined (DESC_ENABLE_PARALLEL_OBD)
   /* store the working context type */
  DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[kDescUsdtNetFuncInfPoolRef]->descHandle;
# endif

# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == 0xfe)
# endif
  {
    /*-----------------------------*/
    /*Transport protocol management*/
    /*-----------------------------*/
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
#  if defined (TP_ENABLE_NORMAL_ADDRESSING)       || \
      defined (TP_ENABLE_MIXED_11_ADDRESSING)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.ReceiveID = TpFuncGetReceiveCanID();
    TpFuncSetResponse(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
#  endif
# endif
# if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpFuncGetTargetAddress();
# else
#  if (TP_USE_EXTENDED_ADDRESSING == kTpOn) || \
      defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
      defined(TP_FUNC_ENABLE_EXTENDED_ADDRESSING) || \
      defined (TP_ENABLE_MIXED_29_ADDRESSING)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = kDescEcuNumber;
#  endif
# endif
# if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
#  if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.BaseAddress = TpFuncGetBaseAddress();
#  endif
# endif
    /* Reception has finished */
    DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkOk);
    /* Reset the channel */
    TpFuncResetChannel();
  }
}
#endif

#if defined(DESC_ENABLE_NODE_POWER_CONTROL) || (kDescNumContexts > 1) || defined(DESC_ENABLE_SPONTANEOUS_RES)
/*******************************************************************************
* NAME:              DescNetworkOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent specific data.
*
*******************************************************************************/
static void DescNetworkOnceInit(void)
{
# if (kDescNumContexts > 1)
  g_descActiveRequestsMask = 0;
# endif

# if defined(DESC_ENABLE_NODE_POWER_CONTROL)
#  if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  g_descNpmTimer = 0;
#  endif

  /* Not necessary since the timer is not running 
   * g_descDoReloadNpmTimer = 0;
   */

  /* Reset channel map and queue */
  g_descCanChannelMap = 0;
  g_descCanChannelMapQueue = 0;
# endif
# if defined (DESC_ENABLE_SPONTANEOUS_RES)
  /* Initialization of the spontaneous pool */
  g_descUsdtNetSpontanResInfoPool.resType = kDescUsdtResponseNone;
  /* will be done at transmission time:
  g_descUsdtNetSpontanResInfoPool.descHandle = kDescPrimContext;
  g_descUsdtNetSpontanResInfoPool.reqDataPtr = V_NULL; 
  g_descUsdtNetSpontanResInfoPool.busInfo.busType = kDescUsdtNetBusTypeIsoTp;
  */
# endif
  /* Don't forget the USDT NET */
  DescNetworkInit();
}
#endif

/*******************************************************************************
* NAME:              DescNetworkIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent context specific data.
*
*******************************************************************************/
static void DescNetworkIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Init the buffer state mashine */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState = kDescUsdtNetworkOk;
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 0;
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;

  /* Interrupt context controller */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextIdle;
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;
#endif

  /* Prepare for RCR-RP negative response - the SID will be filled 
  when the T2 timer expires */
  g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][0] = kDescNegResSId;
  g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][2] = kDescNrcResponsePending;

#if defined (DESC_ENABLE_RES_RINGBUFFER)
  DescRingBufferIterInit(DESC_CONTEXT_PARAM_ONLY);
#endif

}

/*******************************************************************************
* NAME:              DescReleaseContext
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       releases the RX path and manages the S1 timer
*******************************************************************************/
static void DescReleaseContext(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
  /* Check if this instance is a internal request */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType != kDescUsdtNetReqTypeInternal)
#endif
  {
    /* Force reloading the S1 timer (will affect only if timer active) */
    g_descDoReloadS1Timer = kDescTrue;
    /* Notify the application */
    ApplDescOnEndOfProcExt();
  }
  /* Deactivate the connection */
  DescResetConnectionActive(DESC_CONTEXT_PARAM_VALUE);
  /* Release context */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
  /* Release the network resource */
  DescUsdtNetAbsReleaseInfoPool(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr );
}

#if defined (DESC_ENABLE_SPONTANEOUS_RES)
/*******************************************************************************
* NAME:              DescSendSpontaneousResponse
*
* CALLED BY:         Desc internal
* PRECONDITIONS: 
*
* DESCRIPTION:       Any time can make the application a single frame response.
*******************************************************************************/
DescBool DescSendSpontaneousResponse(DescMsg resData, DescMsgLen resLen, t_descUsdtNetBus* pBusInfo, t_descUsdtNetResType resType)
{
  if(g_descUsdtNetSpontanResInfoPool.resType == kDescUsdtResponseNone)
  {
    DescInterruptDisable();
    if(g_descInterruptContextCtrl[kDescPrimContext].activity == kDescContextIdle)
    {
      /* Lock the component for RX */
      g_descInterruptContextCtrl[kDescPrimContext].isContextLocked = 1;
      DescInterruptRestore();

      /* Store into the global variables */
      g_descUsdtNetSpontanResInfoPool.descHandle = kDescPrimContext;
      g_descUsdtNetSpontanResInfoPool.reqDataPtr = V_NULL;
      g_descUsdtNetSpontanResInfoPool.resDataPtr = resData;
      g_descUsdtNetSpontanResInfoPool.busInfo = *pBusInfo;
      g_descUsdtNetSpontanResInfoPool.dataLength = resLen;
      g_descUsdtNetSpontanResInfoPool.resType = resType;

      DescUsdtNetAbsTransmitResponse(&g_descUsdtNetSpontanResInfoPool);
      return kDescTrue;
    }
    /* Ignore */
    DescInterruptRestore();
  }
  return kDescFalse;
}
#endif


#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
/* Not needed */
#else
/*******************************************************************************
* NAME:              DescIsTesterPresent
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescBool DescIsTesterPresent(t_descUsdtNetInfoPoolPtr infoPool)
{
  DescBool returnValue = kDescFalse;

  if ((infoPool->reqType == kDescUsdtNetReqTypeFunctional) && /* Only for functional request */
      (infoPool->reqDataPtr[0] == 0x3e) &&                /* Is it a TesterPresent? */
      (infoPool->reqDataPtr[1] == 0x80) &&                /* Is the SPRIMB set?*/
      (infoPool->dataLength == 0x02))                     /* Do little format check */
  {
    /* Reloading the S1 timer (will affect only if timer active) will be performed at DescReleaseContect call */
    returnValue = kDescTrue;
  }
  return returnValue;
}
#endif

#if defined(DESC_ENABLE_PERIODIC_MODE) && defined (DESC_ENABLE_SCHEDULER_UUDT_TRANSMITTER)
/*******************************************************************************
* NAME:              DescUudtNetFinishTransmission
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides the post transmission processing.
*                    The used resources should be freed  
*                    
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetFinishTransmission(t_descUudtNetInfoPoolPtr infoPool, t_descUudtNetResult status)
{
  DESC_IGNORE_UNREF_PARAM(infoPool);
  DESC_IGNORE_UNREF_PARAM(status);
  DescDoSchedulePostProcessing();
}
#endif

/*******************************************************************************
* NAME:              DescSendPosRespFBL
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Enforces a transmission of a specific pos response.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescSendPosRespFBL(t_descFblPosRespType posRespSId)
{
  t_descUsdtNetBus busInfo;
  vuintx result;

  result = ApplDescInitPosResFblBusInfo(&busInfo);
  if(kDescOk == result)
  {
    switch(posRespSId)
    {
      /*-------------------------------------*/
      case kDescSendFblPosRespEcuHardReset:
      /*-------------------------------------*/
        g_descFblPosRes[0] = 0x51;
        g_descFblPosRes[1] = 0x01;
        (void)DescSendSpontaneousResponse(g_descFblPosRes, 2, &busInfo, kDescUsdtResponseSpontaneous);
        break;
      /*-------------------------------------*/
      case kDescSendFblPosRespDscDefault:
      /*-------------------------------------*/
        {
#if defined (DESC_ENABLE_P2_TIME_REPORT)
          vuint16   p2Time, p2ExTime;
          DescGetSessionTimings(kDescStateSessionDefault, &p2Time, &p2ExTime);

          g_descFblPosRes[0] = 0x50;
          g_descFblPosRes[1] = 0x01;
          g_descFblPosRes[2] = DescGetHiByte(p2Time);
          g_descFblPosRes[3] = DescGetLoByte(p2Time);
          g_descFblPosRes[4] = DescGetHiByte(p2ExTime);
          g_descFblPosRes[5] = DescGetLoByte(p2ExTime);
          (void)DescSendSpontaneousResponse(g_descFblPosRes, 6, &busInfo, kDescUsdtResponseSpontaneous);
#else
          g_descFblPosRes[0] = 0x50;
          g_descFblPosRes[1] = 0x01;
          (void)DescSendSpontaneousResponse(g_descFblPosRes, 2, &busInfo, kDescUsdtResponseSpontaneous);
#endif
        }
        break;
      default:
        /* Invalid value */
        DescAssertUserAlways(kDescAssertWrongFblPosResParameterValue);
        break;
    }
  }
}

/*******************************************************************************
* NAME:              DescNetworkInitPowerOn
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
static void DescNetworkInitPowerOn(void)
{
  DescUsdtNetAbsInitPowerOn();
  DescUudtNetInitPowerOn();
}


/*******************************************************************************
* NAME:              DescNetworkInit
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
static void DescNetworkInit(void)
{
  DescUsdtNetAbsInit();
  DescUudtNetInit();
}

/*******************************************************************************
* NAME:              DescGetActivityState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE DescGetActivityState(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity;
}

#if defined(DESC_ENABLE_DESCICN_SUPPORT)
/*******************************************************************************
* NAME:              DescICNRxMsgInd
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNRxMsgInd(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  switch(infoPool->busInfo.addressingInfo.descICN.Client)
  {
# if defined(DESC_ENABLE_DYN_DEFINED_DID_CLIENT)
    case kDescIcnClientDynDefDid:
      DescDynDefinedDidRxMsgInd(infoPool, status);
      break;
# endif
# if defined(DESC_ENABLE_DYN_DEFINED_DPID_CLIENT)
    case kDescIcnClientDynDefDpid:
      DescDynDefinedDpidRxMsgInd(infoPool, status);
      break;
# endif
# if defined(DESC_ENABLE_ROE_CLIENT)
    case kDescIcnClientRoe:
      DescRoeRxMsgInd(infoPool, status);
      break;
# endif
    default:
      DescAssertInternalAlways(kDescAssertInvalidDescICNClient);
      break;
  }
}
#endif


/*******************************************************************************
* NAME:              DescUsdtNetAbsStartReception
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsStartReception(t_descUsdtNetInfoPoolPtr infoPool)
{
  t_descUsdtNetResult returnValue = kDescUsdtNetworkFailed;

  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].isContextLocked == 0)
  {
#if defined (DESC_ENABLE_CHECK_MSG_RX_ACCEPTANCE)
    if(DescOemCheckAcceptance(infoPool) != kDescFalse)
#endif
    {
      /* Lock the buffer */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].isContextLocked = 1;
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity |= kDescContextActiveRxBegin;

      /* Store infoPool reference */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].infoPoolPtr = infoPool;

      /* Set connection active for S1 timer check */
      DescSetConnectionActive(infoPool->descHandle);

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescSetNpmOnCanChannelActive(infoPool->busInfo.comChannel, g_descCanChannelMapQueue);
#endif
#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
      /* Store the ISO TP Source Address */
      g_descTesterAddress[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)] = infoPool->busInfo.testerId;
#endif
      /* Notify the application */
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
      /* Check if this instance is a internal request */
      if(infoPool->reqType != kDescUsdtNetReqTypeInternal)
#endif
      {
        ApplDescOnBeginOfProcExt();
      }
      /* Notify the implementation */
      DescOemOnRxStart(infoPool);
      returnValue = kDescUsdtNetworkOk;
    }
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              DescUsdtNetAbsFinishReception
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       reception has finished
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetAbsFinishReception(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  /* Clear this state always!!! (in error case lefts ContextIdle then) */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity &= (DescContextActivity)(~kDescContextActiveRxBegin);
  if ((status == kDescUsdtNetworkOk) &&
      (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].infoPoolPtr == infoPool))
  {
    /* Check if a TesterPresent is requested with SuppresPosBit set to not lock Desc */
    DescBool result = DescIsTesterPresent(infoPool);
    if (result == kDescFalse)
    {
      /* On physical requested message actions (for S1 timer normally)*/
      DescOemOnReqInd(infoPool->descHandle);

      g_descMsgContext[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].busInfo = infoPool->busInfo;

      DescUsdtNetAbsPrepareResponse(infoPool);

      /* Sets indication flag for cyclic task */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity |= kDescContextActiveRxEnd;
      /*TBD: DescSetEvent(DescDSDTask, descRequestReceived)*/
      return;
    }
  }
  else
  { /* Reception error had happened */
    DescOemOnRxErrorInd(status);
  }
  DescReleaseContext(DESC_CONTEXT_PARAM_WRAPPER_ONLY(infoPool->descHandle));
}

/*******************************************************************************
* NAME:              DescUsdtNetAbsFinishTransmission
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       transmission has finished
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetAbsFinishTransmission(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_ONLY = infoPool->descHandle;
#endif

  if (status == kDescUsdtNetworkOk)
  {
    /* nothing to do */
  }
  else
  {
    DescOemOnTxErrorInd(status);
  }

  switch (infoPool->resType)
  {
  case kDescUsdtResponsePositive:
    /* fall through */
  case kDescUsdtResponseNegative:
    /* fall through */
  case kDescUsdtResponseRingBuffer:
    /* Make post processing not always success (if called from the error indication)*/
    DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST status);
#if defined(DESC_ENABLE_SPONTANEOUS_RES)
    /* fall through */
  case kDescUsdtResponseRoe:
    /* fall through */
  case kDescUsdtResponseSpontaneous:
    /* fall through */
  case kDescUsdtResponseSpontaneousAppl:
# if defined (DESC_ENABLE_PROTOCOL_UDS)
    if(infoPool->resType == kDescUsdtResponseSpontaneousAppl)
    {
       vuint8 result;
      /* Interpret the status */
      result = (vuint8)((status == kDescUsdtNetworkOk)?kDescOk:kDescFailed);
      /* Confirm the forced RCR-RP response transmission */
      ApplDescSpontaneousResponseConfirmation(DESC_CONTEXT_PARAM_FIRST result);
      /* no break - fall through */

    }
#  if defined (DESC_ENABLE_ROE_SUPPORT)
    else
    {
      if(infoPool->resType == kDescUsdtResponseRoe)
      {
        /* Notify the ROE handler */
        DescRoeResponseConfirmation();
      }
    }
#  endif
    /* Release context here */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
# endif
#endif
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
    if (infoPool->resDataPtr != infoPool->reqDataPtr )
    {
      DescUsdtNetReleaseTransmissionObj(infoPool);
    }
#endif
    break;
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  case kDescUsdtResponseNegativeApplRCR_RP:
    {
      vuint8 result;
      /* Interpret the status */
      result = (vuint8)((status == kDescUsdtNetworkOk)?kDescOk:kDescFailed);
      /* Confirm the forced RCR-RP resposne transmission */
      ApplDescRcrRpConfirmation(DESC_CONTEXT_PARAM_FIRST result);
      /* no break - fall through */
    }
#endif
    /* fall through */
  case kDescUsdtResponseNegativeRCR_RP:
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
    if (infoPool->resDataPtr != g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE])
    {
      infoPool->resDataPtr = V_NULL;
      DescUsdtNetReleaseTransmissionObj(infoPool);
    }
#endif
    break;
#if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
  case kDescUsdtResponsePeriodic:
    DescDoSchedulePostProcessing();
    break;
#endif
  default:
    break;
  }
  /* Reset response type */
  infoPool->resType = kDescUsdtResponseNone;
}

/*******************************************************************************
* NAME:              DescTransmitRcrRp
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       Transmission of RCR-RP
*
*******************************************************************************/
static void DescTransmitRcrRp(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
  /* The response message is already filled with the necessary information */
  if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr == V_NULL)
  {
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = DescUsdtNetGetTransmissionPtr(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
    memcpy(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr,g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE],3);
  }
  else
#endif
  {
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE];
  }
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength = kDescNegResLen;

  DescUsdtNetAbsTransmitResponse(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
  DescReloadT2TimerWithP3maxTime(DESC_CONTEXT_PARAM_VALUE);
  /* Custom management in case of timeout of T2 */
  DescOemOnT2Timeout(DESC_CONTEXT_PARAM_VALUE);
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
  g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE]--;
#endif
}

#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
/*******************************************************************************
* NAME:              DescGetTesterAddress
*
* CALLED BY:         Application
* PRECONDITIONS: 
*
* DESCRIPTION:       Returns the tester address of the last request.
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE DescGetTesterAddress(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return g_descTesterAddress[DESC_CONTEXT_PARAM_VALUE];
}
#endif

/*******************************************************************************
* NAME:              DescGetCurrentBusInfo
*
* CALLED BY:         Application
* PRECONDITIONS: 
*
* DESCRIPTION:       Returns the current communication parameters.
*******************************************************************************/
t_descUsdtNetBus* DESC_API_CALL_TYPE DescGetCurrentBusInfo (DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return &(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].busInfo);
}

/*******************************************************************************
* NAME:              DescTimingIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the timing subcomponent context data.
*
*******************************************************************************/
static void DescTimingIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
  DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);
}

#if defined (DESC_ENABLE_FORCE_RCR_RP)
/*******************************************************************************
* NAME:              DescForceRcrRpResponse
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Forces the CANdesc to send immediately a RCR-RP response.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescForceRcrRpResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Check if allowed such force RCR-RP to be used) 
   * To be able to send RCR-RP teh requested service must be a service which will send a response. */
  DescAssertUser(((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq & g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0), kDescAssertInvalidUsageOfForceRcrRpApi);
  /* Mark that a RCR-RP shall be sent immediately */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpCharged;
}
#endif

/* Functions */
/*******************************************************************************
* NAME:              DescTimingOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent common data.
*
*******************************************************************************/
static void DescTimingOnceInit(void)
{
#if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  /* Set the default session reference timings */
  g_descCurrSessionNumber = 0;
#endif

  /* Clear the flag to avoid one DescTask callcycle time S1 timeout jitter */
  g_descDoReloadS1Timer = kDescFalse;
  /* Deactivate the timers */
  DescDeactivateS1Timer();
}

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
/*******************************************************************************
* NAME:              DescNpmSetSleepInd
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Timer which will be running only when DESC not idle mode
*
*******************************************************************************/
static void DescNpmSetSleepInd(void)
{
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
  vuint8_least channel = kDescNumCommChannels;
  while(channel > 0)
  {
    channel--;
# endif
    if(DescIsNpmOnCanChannelActive(channel, g_descCanChannelMap))
    {
      DescNpmSetSleepReady(channel);
    }
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
  }
# endif
  /* Reset channel map */
  g_descCanChannelMap = 0;
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  /* Stop always here (even in dpmTimeout) */
  g_descNpmTimer = 0;
# endif
}
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
/*******************************************************************************
* NAME:              DescNpmProcessQueue
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Timer which will be running only when DESC not idle mode
*
*******************************************************************************/
static void DescNpmProcessQueue(void)
{
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  vuint8_least canChannelMapMirror;
  /* Something in the queue */
  if(g_descCanChannelMapQueue != 0)
  {
    /* Activate / reload the DPM timer (it is not running during reception and service processing) */
    g_descNpmTimer = kDescNpmTimerTicks;

    /* Make a safe copy of the queue */
    DescInterruptDisable();
    canChannelMapMirror = g_descCanChannelMapQueue;
    DescInterruptRestore();
# endif
    /* Merge queued and already active channels => leave only the new CAN channels */
    DescGetMirroredQueue(g_descCanChannelMapQueue, canChannelMapMirror) &= (vuintx)(~g_descCanChannelMap);
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
    {
      vuint8_least channel = kDescNumCommChannels;
      while(channel != 0)
      {
        channel--;
# endif
        if(DescIsNpmOnCanChannelActive(channel, DescGetMirroredQueue(g_descCanChannelMapQueue, canChannelMapMirror)))
        {
          DescNpmSetKeepAwake(channel);
        }
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
      }
    }
# endif
    /* Merge the queued channel to the activity map */
    g_descCanChannelMap |= DescGetMirroredQueue(g_descCanChannelMapQueue, canChannelMapMirror);
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
    DescInterruptDisable();
# endif
    /* Clear already processed flags */
    g_descCanChannelMapQueue &= (vuint8_least)(~g_descCanChannelMap);
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
    DescInterruptRestore();
  }
# endif
}
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
/*******************************************************************************
* NAME:              DescOemNpmTimer
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Timer which will be running only in DESC idle mode and default session active
*
*******************************************************************************/
static void DescOemNpmTimer(void)
{
  /* ----------------*/
  /* Activity Timeout*/
  /* ----------------*/
  if(g_descNpmTimer != 0)
  {
    /* Decrement timer */
    g_descNpmTimer--;
    /* Check for timeout */
    if(g_descNpmTimer == 0)
    {
      /* The same behavior as in a non-default session timeout */
      DescNpmSetSleepInd();
    }
  }
}
#endif

#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
/*******************************************************************************
* NAME:              DescOemResPendingOverrun
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       In case of too many RCR-RP timeout send NR with NRC $21. 
*
*******************************************************************************/
static void DescOemResPendingOverrun(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Insure no interruption from the application */
  DescInterruptDisable();
  /* Set an error BUSY for the tester and no PostHandler to be called */
  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcConditionsNotCorrect;
  /* Close the case :) */
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
  DescInterruptRestore();
}
#endif

/*******************************************************************************
* NAME:              DescStateOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the state subcomponent common data.
*
*******************************************************************************/
static void DescStateOnceInit(void)
{
  DescStateInit();
}

void DESC_API_CALL_TYPE DescStateInit(void)
{
  g_descCurState.stateSession = kDescStateSessionDefault;
}


DescStateGroup DESC_API_CALL_TYPE DescGetStateSession(void)
{
  return g_descCurState.stateSession;
}


void DESC_API_CALL_TYPE DescSetStateSession(DescStateGroup descState)
{
  /* The new state shall not be zero */
  DescAssertCommon((descState != 0), kDescAssertZeroStateValue);
  DescOemOnTransitionSession(descState, g_descCurState.stateSession);
  ApplDescOnTransitionSession(descState, g_descCurState.stateSession);
  g_descCurState.stateSession = CANBITTYPE_CAST descState;
}


static DescNegResCode DescCheckState(V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3* refState)
{
  if((refState->stateSession & g_descCurState.stateSession) == 0)
  {
    return kDescNrcRejectStateSession;
  }
  return kDescNrcNone;
}


static void DescSetState(DescSvcInstIndex svcInstHandle)
{
  V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3* curRefState;
  if(g_descSvcInst[svcInstHandle].setStateIndex != kDescStateNoTransition)
  {
    curRefState = &g_descStateGroupTransition[g_descSvcInst[svcInstHandle].setStateIndex][0];
    DescInterruptDisable();
    if((g_descCurState.stateSession & curRefState->stateSession) != 0)
    {
      DescSetStateSession((curRefState+1)->stateSession);
    }
    DescInterruptRestore();
  }
}


#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescGetSessionStateOfSessionId
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Converts Session ID to its state.
*
*******************************************************************************/
DescStateGroup DESC_API_CALL_TYPE DescGetSessionStateOfSessionId(DescMsgItem sessionId)
{
  vuint8_least iter;
  vuint8_least scanner;
  vuint8_least step;
  V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * pReqHeadExt;
  DescStateGroup returnValue;
  step = DescGetSvcInstHeadExtEntrySize(&g_descSvcHead[kDescSvcHeadOffsetSDS]);

  /* First entry */
  pReqHeadExt = DescGetSvcInstReqHeadExt(&g_descSvcHead[kDescSvcHeadOffsetSDS], kDescSvcInstOffsetSDS);

  iter = 0;
  scanner = 0;
  while(iter < kDescNumStateSession)
  {
    if(pReqHeadExt[scanner] == sessionId)
    {
      break;
    }
    scanner+=step;
    iter++;
  }

  /* Check if found */
  DescAssertCommon((iter < kDescNumStateSession), kDescAssertInvalidStateParameterValue);

  /* Convert to bit mask */
  if(g_descSvcInst[iter + kDescSvcInstOffsetSDS].setStateIndex != kDescStateNoTransition)
  {
    returnValue = g_descStateGroupTransition[g_descSvcInst[iter + kDescSvcInstOffsetSDS].setStateIndex][1].stateSession;
  }
  else
  {
    /* Would mean illegal state was found */
    DescAssertCommonAlways(kDescAssertInvalidStateParameterValue);
    /*lint --e(527) */
    returnValue = kDescStateValueInvalid;
  }
  return returnValue;
}
#endif

#if defined(DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
/*******************************************************************************
* NAME:              DescGetSessionStateBitPosition
*
* CALLED BY:         SetState
* PRECONDITIONS:     
*
* DESCRIPTION:       Gathers the set bit number (0,1,...).
*
*******************************************************************************/
static vuint8_least DescGetSessionStateBitPosition(DescStateGroup sessionState)
{
  vuint8_least stateNumber = 1;

  /* Must be non-zero value */
  DescAssertCommon((sessionState != 0), kDescAssertZeroStateValue);
  while((sessionState>>stateNumber)!= 0)
  {
    stateNumber++;
  }
  /* correct the zero offset */
  stateNumber--;

  /* Must be one of the legal state values */
  DescAssertCommon((stateNumber < kDescNumStateSession), kDescAssertInvalidStateParameterValue);
  return stateNumber;
}
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescGetSessionIdOfSessionState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Converts given session state into its corresponding sub-function Id.
*
*******************************************************************************/
DescMsgItem DESC_API_CALL_TYPE DescGetSessionIdOfSessionState(DescStateGroup sessionState)
{
  vuint8_least iter;

  iter = kDescSvcInstOffsetSDS;
  while (iter < (kDescSvcInstOffsetSDS + kDescNumStateSession))
  {
    if(g_descSvcInst[iter].setStateIndex != kDescStateNoTransition)
    {
      if((DescStateGroup) (g_descStateGroupTransition[g_descSvcInst[iter].setStateIndex][1].stateSession) == sessionState)
      {
        return *DescGetSvcInstReqHeadExt(&g_descSvcHead[kDescSvcHeadOffsetSDS], iter);
      }
    }
    iter++;
  }

  /* Check if not found */
  DescAssertCommonAlways( kDescAssertInvalidStateParameterValue);

  return (DescMsgItem)0xFF;
}
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescGetSessionTimings
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the session specific P2/P2* timings
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescGetSessionTimings(DescStateGroup sessionState, vuint16* p2Time_1ms, vuint16* p2ExTime_10ms)
{
# if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  vuint8_least    bitPos;
# endif

# if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  bitPos = DescGetSessionStateBitPosition(sessionState);
  /* Set P2 Time for the response */
  *p2Time_1ms = g_descP2TimingsTable[bitPos][kDescTimingRefP2];
  /* Set P2* Time for the response */
  *p2ExTime_10ms = g_descP2TimingsTable[bitPos][kDescTimingRefP2Star];
# else
  DESC_IGNORE_UNREF_PARAM(sessionState);
  /* Set P2 Time for the response */
  *p2Time_1ms = kDescTimeValueP2;
  /* Set P2* Time for the response */
  *p2ExTime_10ms = kDescTimeValueP2Star;
# endif
}
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescOnTransitionStateSession
*
* CALLED BY:         SetState
* PRECONDITIONS:     
*
* DESCRIPTION:       Special processing for the state group session.
*
*******************************************************************************/
static void DescOnTransitionStateSession(DescStateGroup newState, DescStateGroup currentState)
{
  /* On any transition */
  DescOemOnSessionTransition();

# if defined (DESC_ENABLE_SECURITY_ACCESS)
  /* Restore the security sequence */
  DescSecurityOnceInit();
# endif

# if defined (DESC_ENABLE_ROE_SUPPORT)
  DescClearRoeEvents();
# endif
  /* S1 Timer managment */
  if(currentState == kDescStateSessionDefault)
  {
    if(newState != kDescStateSessionDefault)
    {
      DescActivateS1Timer();
# if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescNpmProcessQueue();
# endif
      DescOemOnTransitionToNonDefaultSession();
    }
  }
  else
  {
    if(newState == kDescStateSessionDefault)
    {
      DescDeactivateS1Timer();
# if defined (DESC_ENABLE_PERIODIC_MODE)
      /* Clear the Scheduler */
      DescSchedulerInit();
# endif
# if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescNpmSetSleepInd();
# endif
      /* OEM implementation for this transition */
      DescOemOnTransitionToDefaultSession();
    }
  }
# if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  /* In case of dynamical P2 timings - set the new session reference */
  g_descCurrSessionNumber = (vuint8)DescGetSessionStateBitPosition(newState);
# endif
}
#endif


#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/*******************************************************************************
* NAME:              DescStartRepeatedServiceCall
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Enables the multicall feature for the current service.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescStartRepeatedServiceCall(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMainHandler mainHandler)
{
  /* Initialize the required function handler */
  g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] = mainHandler;
}
#endif

/*******************************************************************************
* NAME:              DescSetNegResponse
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Sets the error.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescSetNegResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescNegResCode errorCode)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Ignore setting an error if already set */
  if (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
  {
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = errorCode;
  }
}

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstHeadExtEntrySize
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
static vuint8_least DescGetSvcInstHeadExtEntrySize(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead)
{
  return (vuint8_least)((pSvcHead->isReqHeadExtEchoed != 0)?
                  (pSvcHead->reqHeadExLen):(pSvcHead->reqHeadExLen + pSvcHead->resHeadExLen));
}
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstResHeadExt
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# endif
{
  vuint8_least offset = 0;
  if(pSvcHead->isReqHeadExtEchoed == 0)
  {
    offset = pSvcHead->reqHeadExLen;
  }
  return (DescGetSvcInstReqHeadExt(pSvcHead, svcInstAbsRef) + offset);
}
#endif

#if defined (DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstReqHeadExt
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# endif
{
  vuint16_least offset = DescGetSvcInstHeadExtEntrySize(pSvcHead);
  offset *= (vuint16)(svcInstAbsRef - pSvcHead->svcInstFirstItem);

  return &g_descSvcInstHeadExt[pSvcHead->svcInstHeadExtFirstItem + offset];
}
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined(DESC_ENABLE_BINARY_SVCINST_SEARCH)
/******************************************************************************
* NAME:              DescFindSvcInst
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask)
{
  V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * headEx;
  DescSvcInstIndex        loIdx;
  DescSvcInstIndex        hiIdx;
  DescSvcInstIndex        idx;
  DescSvcInstIndex        reqSvcInstHandle;
  vuint8_least            currColFound;
  DescBool                isEqual;

  loIdx = pSvcHead->svcInstFirstItem;
  /* Calculate search elements */
  hiIdx = (DescSvcInstIndex)((pSvcHead + 1)->svcInstFirstItem - 1);

  /* Mark subserviceInstance handle as invalid */
  reqSvcInstHandle = kDescInvalidSvcInstHandle;

  /* No error still found */
  *failedByteMask = 0;
  do
  {
    /* Examine one concrete serviceInstanceHeader */
    /* ------------------------------------------ */
    idx = (DescSvcInstIndex)(((vuint16)((vuint16)hiIdx + (vuint16)loIdx)) >> 1);

    headEx = DescGetSvcInstReqHeadExt(pSvcHead, idx);
    currColFound = 0;

    do
    {
      isEqual = V_BOOL_EXPR(reqHeadPtr[currColFound] == headEx[currColFound]);
      currColFound++;
    }
    while((currColFound < pSvcHead->reqHeadExLen)&&(isEqual != kDescFalse));

    if(isEqual != kDescFalse)
    {
#  if defined (DESC_ENABLE_MULTI_VARIANT)
      /*Check if it is allowed in the actual configuration*/
      if(DescPermittedInConfig(g_descSvcInst[idx].variantMask) != 0)
#  endif
      {
        reqSvcInstHandle = idx;
      }
      break;
    }
    else
    {
      /* Compensate post increment */
      currColFound--;
      /* Check for deepest error column */
      if(currColFound > *failedByteMask)
      {
        *failedByteMask = currColFound;
      }
      /* Determine which half shall be taken */
      if (reqHeadPtr[currColFound] < headEx[currColFound])
      {
        /* Avoid signed types */
        if(idx == 0)
        {
          break;
        }
        hiIdx = (DescSvcInstIndex)(idx - 1);
      }
      else
      {
        /* Message 'greater' than service instance: Use upper half of interval... */
        loIdx = (DescSvcInstIndex)(idx + 1);
      }
    }
  }
  while (loIdx <= hiIdx);
  /* Use 0x02, to skip the SID bit */
  *failedByteMask = (vuint8)(0x02 << *failedByteMask);
  /* return the search result 
   * place the error column number in the last 3 bits */
  return reqSvcInstHandle;
}
# endif
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined(DESC_ENABLE_LINEAR_SVCINST_SEARCH)
/******************************************************************************
* NAME:              DescFindSvcInst
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Linear search for service instance.
*
*******************************************************************************/
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask)
{
  DescSvcInstHeadExtIndex iter;
  DescSvcInstIndex        reqSvcInstHandle;
  DescSvcInstIndex        offset;
  vuint8_least            currColFound;
  vuint8_least            incStep;
  DescBool                isEqual;


  incStep = DescGetSvcInstHeadExtEntrySize(pSvcHead);

  /* Mark subserviceInstance handle as invalid */
  reqSvcInstHandle = kDescInvalidSvcInstHandle;
  /* No error still found */
  *failedByteMask = 0;
  offset = 0;

  for(iter = pSvcHead->svcInstHeadExtFirstItem;
      iter < (pSvcHead + 1)->svcInstHeadExtFirstItem;
      iter+= incStep)
  {
    currColFound = 0;
    do
    {
      isEqual = V_BOOL_EXPR(reqHeadPtr[currColFound] == g_descSvcInstHeadExt[iter + currColFound]);
      currColFound++;
    }
    while ((currColFound < pSvcHead->reqHeadExLen)&&(isEqual != kDescFalse));


    if(isEqual != kDescFalse)
    {
      reqSvcInstHandle = (DescSvcInstIndex)(offset + pSvcHead->svcInstFirstItem);
#  if defined (DESC_ENABLE_MULTI_VARIANT)
       /*Check if it is allowed in the actual configuration*/
      if(DescPermittedInConfig(g_descSvcInst[reqSvcInstHandle].variantMask) == 0)
      {
        reqSvcInstHandle = kDescInvalidSvcInstHandle;
      }
#  endif
      break;
    }
    else
    {
      /* Compensate post increment */
      currColFound--;
      /* Check for deepest error column */
      if(currColFound > *failedByteMask)
      {
        /* Use 0x02, to skip the SID bit */
        *failedByteMask = currColFound;
      }
      /* Check if it makes sense to continue the search */
      if(reqHeadPtr[currColFound] < g_descSvcInstHeadExt[iter + currColFound])
      {
        /* That was it */
        break;
      }
    }
    /* Increment the reference */
    offset++;
  }

  /* Use 0x02, to skip the SID bit */
  *failedByteMask = (vuint8)(0x02 << *failedByteMask);
  return reqSvcInstHandle;
}
# endif
#endif

/******************************************************************************
* NAME:              DescFindSvc
*
* CALLED BY:         Dispatcher,FuncReception
* PRECONDITIONS:     
*
* DESCRIPTION:       Search a service ID.
*
*******************************************************************************/
static DescSvcHeadIndex DescFindSvc(DescMsgItem reqSvcId)
{
  DescSvcHeadIndex result  = kDescInvalidSvcHandle;
  vuint8_least     byteVar = 0;

  /* check if it is in the correct range (0x00-0x3f or 0x80-bf => bit2 must be 0) */
  /* check if it is not bigger that the maximum defined SID */
  if (((reqSvcId & kDescPosResIdOffset) == 0)&&
       (reqSvcId <= kDescMaxReqSid))
  {
    /* find in which response range is the request. */
    if ((reqSvcId & 0x80) != 0)
    {
      byteVar = kDescPosResIdOffset;
    }
    result = g_descSidMap[reqSvcId - byteVar];
  }


#if defined (DESC_ENABLE_MULTI_VARIANT) || \
    defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
  if(result < kDescInvalidSvcHandle)
  {
# if defined (DESC_ENABLE_MULTI_VARIANT)
    /*Check if it is allowed in the actual configuration*/
    if(DescPermittedInConfig(g_descSvcHead[result].variantMask) == 0)
    {
      result = kDescInvalidSvcHandle;
    }
# endif
  }
  else
  {
# if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
    /* Check if the application can recognize the SID */
    if(ApplDescCheckUserService(reqSvcId) == kDescOk)
    {
      /* The last service is the generic user one */
      result = (DescSvcHeadIndex)(kDescSvcHeadNumItems - 1);
    }
# endif
  }
#endif
  return result;
}

#if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
/******************************************************************************
* NAME:              DescGetServiceId
*
* CALLED BY:         Application user service
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the current request's SId.
*
*******************************************************************************/
DescMsgItem DESC_API_CALL_TYPE DescGetServiceId(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
# if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
  /* Service Id can be reported only if not receive was active (post-handler are called in Idle mode) 
   * Removed since the condition is incomplete - if between the call of DescProcessingDOne and the PosHandler excution a new service will be requested,
   * it is still possible to evaluate the SID but the activity is set to ActiveRx.
   */
  /* DescAssertUser((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity != kDescContextActiveRx), kDescAssertNoSidCanBeReportedInIdleMode);*/
  /* Take from the backup */
  return g_descUserSIdBackup[DESC_CONTEXT_PARAM_VALUE];
# else
  /* Service Id can be reported only during request processing */
  DescAssertUser((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess), kDescAssertNoSidCanBeReportedInIdleMode);
  /* Take from the current buffer */
  return g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[0];
# endif
}
#endif

/*******************************************************************************
* NAME:              DescDispatcherIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the dispatcher subcomponent context specific data.
*
*******************************************************************************/
static void DescDispatcherIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
  /* Clear the multicall function pointer */
  g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] = V_NULL;
#endif
#if (kDescNumContexts > 1)
  /* Init the context reference */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].iContext = DESC_CONTEXT_PARAM_VALUE;
#endif
  /* Delete the error registers */
  /* Done before the dispatcher will be called.
   * g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
   */
}

/*******************************************************************************
* NAME:              DescDispatcher
*
* CALLED BY:         DescTask
* PRECONDITIONS:     If there is at least one received request.
*
* DESCRIPTION:       Provides the kernel of the diagnostic
*
*******************************************************************************/
static void DescDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Code optimization */
  DescMsg msg;

  msg = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;

#if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
  /* Store the SId for the case it is user SId */
  g_descUserSIdBackup[DESC_CONTEXT_PARAM_VALUE] = msg[0];
#endif
  /* Encapsulate the error handling for distinguishing if the PostHAndler has to
   * be called in error cases, handled by CANdesc 
   */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 0;
  /* Set default response on request type (phys - yes, func - no) */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = kDescDefaultResOnReq;
  /* Update the context phase */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcess;

  /*---------------------------------------------*/
  /*              Search service ID              */
  /*---------------------------------------------*/
  /* If service not supported */
  /* -------------------------*/
  g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] = DescFindSvc(msg[0]);
  if(g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] < kDescInvalidSvcHandle)
  {
    V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * refDescSvcHead;

    refDescSvcHead = &g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]];

    /* -----------------------------------------------*/
    /*      Set the default state for the response    */
    /* -----------------------------------------------*/
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = refDescSvcHead->resOnReq;

#if defined (DESC_ENABLE_ADDR_METHOD_CHECK_ON_SID)
    /*---------------------------------------------*/
    /*     Service ID addressing method check      */
    /*---------------------------------------------*/
    if ((refDescSvcHead->reqType &
         g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
#endif
    {
      /*------------------------------------*/
      /*     Service ID session check       */
      /*------------------------------------*/
      if ((refDescSvcHead->checkSessionState & g_descCurState.stateSession) != 0)
      {
        /*---------------------------------------------*/
        /*      The length of the request must be at   */
        /*    least the length of the requests header  */
        /*---------------------------------------------*/
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined (DESC_ENABLE_MIN_REQ_LEN_CHECK)
        if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >= refDescSvcHead->minReqLength)
# else
        /* increment by 1 to include the SID byte also in the length of the header */
        if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >= (refDescSvcHead->reqHeadExLen + 1))
# endif
#endif
        {
          vuint8_least supPosResBit;
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          vuint8_least svcInstFailedBytePosMask = 0;
#endif

          /* SID is no more of relevance - position to the first sub-service byte */
          msg++;
          /*---------------------------------------------*/
          /*   Suppress positive response bit calc       */
          /*---------------------------------------------*/
          supPosResBit = refDescSvcHead->suppPosRes;
          /* compose 0x80 or 0x00 depending on the CDD info */
          supPosResBit <<= 7;
          /* Extract the information to the application */
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = CANBITTYPE_CAST (((supPosResBit & *msg)!= 0)?0x01:0x00);
          /* Mask out the SPRMB */
          *msg &= (DescMsgItem)(~supPosResBit);/* compose 0x80 or 0x00 depending on the CDD info */

          /*---------------------------------------------*/
          /*              Search service instance        */
          /*---------------------------------------------*/
          /* if at least one instance is defined - check if it is valid */
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          if(refDescSvcHead->reqHeadExLen > 0)
          { /*lint -e{644}*/
            g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE] = (DescMemSvcInstIndex)DescFindSvcInst(msg, refDescSvcHead, &svcInstFailedBytePosMask);
          }
          else
#endif
          {
            g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE] = refDescSvcHead->svcInstFirstItem;
          }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          if((g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]) < kDescInvalidSvcInstHandle)
#endif
          {
            V_MEMROM1 DescSvcInst V_MEMROM2 V_MEMROM3 * refDescSvcInst;

            refDescSvcInst = &g_descSvcInst[g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]];

            /* -----------------------------------------------*/
            /*      Set the default state for the response    */
            /* -----------------------------------------------*/
            /* Set service instance specific addressing information */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = refDescSvcInst->msgAddInfo.resOnReq;

            /*---------------------------------------------*/
            /*  Service instance addressing method check   */
            /*---------------------------------------------*/
            if ((refDescSvcInst->msgAddInfo.reqType &
                 g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
            {
              /*---------------------------------------------*/
              /*      Service instance related checks        */
              /*---------------------------------------------*/
              /* Request length (top limit) check */

              /*---------------------------------------------*/
              /*      Service instance related checks        */
              /*---------------------------------------------*/
              /* Generated session check */
#if defined (DESC_ENABLE_SESSION_FORMAT_STATE_CHECK)
              if ((refDescSvcInst->checkState.stateSession & g_descCurState.stateSession) != 0)
#endif
              {
                /* Request length (top limit) check */
                /* If the table stored length is not zero - 
                check it for matching with the request length */
                if((refDescSvcInst->reqLen == 0) ||
                  (refDescSvcInst->reqLen == g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen))
                {
#if defined (DESC_ENABLE_AUTO_STATES)
                  /* Generated state checks */
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = DescCheckState(&(refDescSvcInst->checkState));

                  /* If any error was detected - go out */
                  if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
                  {
                    /* Release the PostHandler call feature */
                    g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 1;

                    /* OEM specific hook for pre-service execution */
                    DescOemOnValidService(DESC_CONTEXT_PARAM_VALUE);

                    /* If any error was detected - go out */
                    /* Do not use pre-processor encapsulation - since good compilers would optimize this check. */
                    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
                    {
#if defined (DESC_ENABLE_PREHANDLER_USAGE)
                      /*---------------------------------------------*/
                      /*    Application specific condition check     */
                      /*---------------------------------------------*/
                      /* Call the pre handler */
                      g_descPreHandlerTable[refDescSvcInst->preHandlerRef](DESC_CONTEXT_PARAM_ONLY);
                      /* If any error was detected - go out */
                      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
                      {
                        /* Prepare the application information */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData    = (DescMsg)(msg + DescExtractReqExtHeadLen(refDescSvcHead->reqHeadExLen));
                        /* This is the extension of the response header (the header without the resposne SID), so for the complete length - add 1 */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resData    = (DescMsg)(msg + DescExtractResExtHeadLen(refDescSvcHead->resHeadExLen));
                        /* The length contains up to now the whole request length, so just substract the header length */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen -= (DescMsgLen)(DescExtractReqExtHeadLen(refDescSvcHead->reqHeadExLen) + 1);
                        /* Zero the response length - optimization for no data responses */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0;

                        /*---------------------------------------------*/
                        /*      Call the main handler function         */
                        /*---------------------------------------------*/
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
                        /* If each service needs it - start always here to save ROM for the application */
                        _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, refDescSvcInst->mainHandler);
#endif
                        refDescSvcInst->mainHandler(&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]);

                        DescAssertContext((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].iContext == DESC_CONTEXT_PARAM_VALUE), kDescAssertContextIdWasModified);
                        DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts), kDescAssertInvalidContextId);
                        /* Skip the processing done call - let the application decide when */
                        return;
                      }
                    }/* else: error code already set - skip further processing */
                  }
#if defined (DESC_ENABLE_AUTO_STATES)
                  else
                  {
                    /* Correct the negative response code dependent on the sub-function instantiation */
                    if((g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcSubfunctionNotSupportedInActiveSession)
                      &&(refDescSvcHead->hasSubFunction == 0))
                    {
                      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcParamIdNotSupportedInSession;
                    }

                    /* EXAMPLE: Additional activities may be necessary */
                    DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                    DescOemOnInvalidEcuState(DESC_CONTEXT_PARAM_VALUE);
                  }
#endif
                }
                else
                {
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
                  /* EXAMPLE: Additional activities may be necessary */
                  DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                  DescOemOnReqLengthNotMatched(DESC_CONTEXT_PARAM_VALUE);
                }
              }
#if defined (DESC_ENABLE_SESSION_FORMAT_STATE_CHECK)
              else
              {
                /* Correct the negative response code dependent on the sub-function instantiation */
                if(refDescSvcHead->hasSubFunction == 0)
                {
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcParamIdNotSupportedInSession;
                }
                else
                {
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcSubfunctionNotSupportedInActiveSession;
                }
                /* EXAMPLE: Additional activities may be necessary */
                DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                DescOemOnInvalidEcuState(DESC_CONTEXT_PARAM_VALUE);
              }
#endif
            }
            else
            {
              g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
              /* EXAMPLE: Additional activities may be necessary */
              DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
              DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_VALUE);
            }
          }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          else
          {
# if defined (DESC_ENABLE_SAME_NRC_ON_SUB_FUNC_AND_PARAM_ID)
            /* Send always NRC kDescNrcSubfunctionNotSupported */
# else
            /* Check which negative response shall be send (UnexpectedId/UnexpectedSubFunction)*/
            /*lint -e{644} (PClint can not know that this code will be reached only if the service is not found, and the variable is always initialized with 0)*/
            if((vuintx)(refDescSvcHead->reqHeadByteSpec & svcInstFailedBytePosMask) != (vuintx)0)
            {
              g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
            }
            else
# endif
            {
              g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcSubfunctionNotSupported;
            }
            /* Could be used in case when the instance is not found special init to be done*/
            DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
            DescOemOnSvcInstNotFound(DESC_CONTEXT_PARAM_VALUE);
          }
#endif
        }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
        else
        {
          g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
          /* EXAMPLE: Additional activities may be necessary */
          DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
          DescOemOnReqLengthTooSmall(DESC_CONTEXT_PARAM_VALUE);
        }
#endif
      }
      else
      {
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcServiceNotSupportedInActiveSession;
        /* EXAMPLE: Additional activities may be necessary */
        DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
        DescOemOnInvalidSidSession(DESC_CONTEXT_PARAM_VALUE);
      }
    }
#if defined (DESC_ENABLE_ADDR_METHOD_CHECK_ON_SID)
    else
    {
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
      /* EXAMPLE: Additional activities may be necessary */
      DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
      DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_VALUE);
    }
#endif
  }
  else
  {
    /* Could be used in case when the service is not found special init to be done*/
    DescOemOnSvcNotFound(DESC_CONTEXT_PARAM_VALUE);
#if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* Let always a response transmission */
#else
    if((msg[0] & 0x40) != 0)
    {
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
    }
#endif
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcServiceNotSupported;
  }
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
/*******************************************************************************
* NAME:              DescProcessingDone
*
* CALLED BY:         Dispatch,  any application function
* PRECONDITIONS: 
*
* DESCRIPTION:       Depending on the current situation, provides the right 
*                    action. 
*******************************************************************************/
void DESC_API_CALL_TYPE DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);

  switch(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode)
  {
    case kDescContextModeNormal:
      /* Finalize the request processing */
      DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# if defined (DESC_ENABLE_PID_LIST_MODE) || \
     defined (DESC_ENABLE_SIM_PID_LIST_MODE)
    case kDescContextModePidList:
      /* Current Pid list process finalization */
      DescPidProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
# if defined (DESC_ENABLE_PERIODIC_MODE)
    case kDescContextModePeriodic:
      /* Current P-Pid list process finalization */
      DescSchedulerProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
# if defined (DESC_ENABLE_ROUTINE_CONTROL_MODE)
    case kDescContextModeRoutineControl:
      /* The routine control service is ready - finalize it */
      DescRidProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
# if defined (DESC_ENABLE_MEMORY_BY_ADDRESS_MODE)
    case kDescContextModeMemByAddr:
      /* The memory by address service is ready - finalize it */
      DescMemByAddrProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
    default:
      /* Unknown context mode */
      DescAssertCommonAlways(kDescAssertInvalidContextMode);
      break;
  }
}
#endif

/*******************************************************************************
* NAME:              DescFinalProcessingDone/DescProcessingDone
*
* CALLED BY:         DescProcessingDone/Appl(CANdesc)
* PRECONDITIONS: 
*
* DESCRIPTION:       Depending on the current situation, provides the right 
*                    action. 
*******************************************************************************/
#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
static void DescFinalProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
#else
void DESC_API_CALL_TYPE DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
#endif
{
  DescMsg       msg;
  /* temporary variable to avoid multiple calculations */
  vuint8_least  resHeadLen;

  /* check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* check for correct time point of function call */
  DescAssertCommon((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess),
                   kDescAssertProcessingDoneCallAfterResFlushing);
  /* Is ProcessingDone awaited */
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & kDescContextActiveProcess) != 0)
  {
#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
    /* Set the CANdesc in a normal mode */
    g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;
#endif

    /* Specific actions which will be performed each time processing done with real response is called (timer management) */
    DescOemOnProcessingDone(DESC_CONTEXT_PARAM_VALUE);

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL) && \
    defined (DESC_ENABLE_RES_RINGBUFFER)
    /* If no ring buffer currently in use - stop multiple calls */
    if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
#endif
    {
      /* Deactivate the multicall mechanism */
      _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
    }

    /* Check if there will be a real response onto the bus */
    if ((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq &
         g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) !=0 )
    {
      /* Init with the current buffer location */
      msg = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
      /* if there was an error detection - make negative response */
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
      {
        /*---------------------------------------------*/
        /*          Negative response section          */
        /*---------------------------------------------*/
        if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType & kDescFuncReq) != 0)
        {
          /* In case of secured transmission - it is not possible to enter here!!! */
          switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
          {
            case 0x11:/* fall through */
            case 0x12:/* fall through */
            case 0x31:/* fall through */
            DESC_OEM_SUPPRESSED_FUNC_NRC
              /* fall through */
              /* Simulate success confirmation */
              DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
              return;/* Leave the function */
            default:break;/* Send negative response onto the comm bus */
          }

#if defined (DESC_ENABLE_OBDII_NR_CONFORMANCE)
          /* Functional OBD requests (Sid =[0x00,...,0x0F]) */
          if(msg[0] < 0x10)
          {
            /* ...may support only NRCs: $21, $22 and $78 */
            switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
            {
              case 0x21:/* Fall through */
              case 0x22:/* Fall through */
              case 0x78:/* Fall through */
                /* These are allowed - continue processing */
                break;
              default:
                /* Simulate success confirmation */
                DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
                return;
            }
          }
#endif
        }

        /* Format and send negative response */
        msg[1] = msg[0]; /* Copy the SID */
        msg[0] = kDescNegResSId;/* Place 0x7F ...*/
        msg[2] = g_descNegResCode[DESC_CONTEXT_PARAM_VALUE];/*... and the current error code*/
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = kDescNegResLen;
      }
      else
      {
        /*---------------------------------------------*/
        /*          Positive response section          */
        /*---------------------------------------------*/
#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
        /* Do not consider the bit information - send always positive response */
#else
        /* Check if positive response shall be sent */
        if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes == 0)
#endif
        {
          /* Create response SID */
          msg[0] += kDescPosResIdOffset;
          msg++;
          /* Fill header of response */
          DescAssertCommon((g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] < kDescSvcHeadNumItems),kDescAssertSvcTableIndexOutOfRange);
          /* optimize the loop - casting because it is sure that the header length is far below 254 bytes */
          /* This is the extension of the response header (the header without the resposne SID), so for the complete length - add 1 */
          resHeadLen = DescExtractResExtHeadLen((vuintx)(g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]].resHeadExLen));
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          DescMsgCopyRomToFarRam(msg,
                                 DescGetSvcInstResHeadExt(&g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]],
                                                           g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]),
                                 (vuint16)resHeadLen);
#endif
          /* Now consider the SID too */
          resHeadLen++;
          /* Making the total length of the response message 
          * (header + data) This macro is an optimization for adding a value: (X+=Y)*/
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += (DescMsgLen)resHeadLen;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
          /*Set the write pointer for the ring buffer manager (resHeadLen + SIdByte) */
          g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex =    (DescMsgLen)resHeadLen;
          /* Protocol data are the response head data */
          g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen = (DescBitType)resHeadLen;
#endif
        }
#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
        /* Do not consider the bit information - send always positive response */
#else
        else
        {
          /* Simulate success confirmation */
          DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
          return;
        }
#endif
      }

#if defined (DESC_ENABLE_RES_RINGBUFFER)
      /* Mark that from now on a single response will be sent */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcessEnd;
      /* Set it for the copyToCan function */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
      /* Init RingBuffer controller */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0;

      /* Set the write pointer in case of RingBuffer usage and leave this function */
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
#endif
      {
        /* Set ready for transmit */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTxReady;
      }
    }
    else
    {
      /* Simulate success confirmation */
      DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
    }
  }
}

/*******************************************************************************
* NAME:              DescDoPostProcessing
*
* CALLED BY:         DescConfirmation, DescProcessingDone
* PRECONDITIONS: 
*
* DESCRIPTION:       Provides finalizing actions
*                    In case of secured Transmission
*******************************************************************************/
static void DescDoPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);

  /* Copy the state for task processing */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState = status;

  /* Deactivate the RCR-RP timer here for those services without response */
  DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
  DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);
  /* Activate the post processing */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActivePostProcess;

  /* Predefined function */
  DescOemOnConfirmation(DESC_CONTEXT_PARAM_VALUE, status);

  /* Stop calling the application if set */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
  /* Release context for next requests */
  DescReleaseContext(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescInitPowerOn
*
* CALLED BY:         Application
* PRECONDITIONS:     On system boot.
*
* DESCRIPTION:       Performs time consuming init/checks of the diag module.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescInitPowerOn(DescInitParam initParam)
{
  /******************************
  Subcomponent once InitPowerOn
  *******************************/
  DescSubcompOnceInitPowerOnDebug();
  DescSubcompOnceInitPowerOnNetwork();
  DescSubcompOnceInitPowerOnTiming();
  DescSubcompOnceInitPowerOnState();
  DescSubcompOnceInitPowerOnDispatcher();
  DescSubcompOnceInitPowerOnController();
  DescSubcompOnceInitPowerOnProcessor();
  DescSubcompOnceInitPowerOnFaultMemory();
  DescSubcompOnceInitPowerOnScheduled();
  DescSubcompOnceInitPowerOnSecurityAccess();
  DescSubcompOnceInitPowerOnPidManager();
  DescSubcompOnceInitPowerOnRidManager();
  DescSubcompOnceInitPowerOnPidListProcessor();
  DescSubcompOnceInitPowerOnDynDefinePid();
  DescSubcompOnceInitPowerOnDynDefineDpid();
  DescSubcompOnceInitPowerOnRoeProcessor();
  DescSubcompOnceInitPowerOnVariantManager();


  /* Generated function - DescInit must be here called because of init parameters */
  DescOemOnPowerOnInit(initParam);
  DescInit(initParam);
}

/*******************************************************************************
* NAME:              DescInit
*
* CALLED BY:         any application function, DescInitPowerOn
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs init of the diag module.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescInit(DescInitParam initParam)
{

  DESC_CONTEXT_PARAM_DEF_LOCAL

  /* Parameter may not be used - use dummy assignemt if necessary */
  DESC_IGNORE_UNREF_PARAM(initParam);

  /************************
  Subcomponent once init
  ************************/
  DescSubcompOnceInitDebug();
  DescSubcompOnceInitNetwork();
  DescSubcompOnceInitTiming();
  DescSubcompOnceInitState();
  DescSubcompOnceInitDispatcher();
  DescSubcompOnceInitController();
  DescSubcompOnceInitProcessor();
  DescSubcompOnceInitFaultMemory();
  DescSubcompOnceInitScheduled();
  DescSubcompOnceInitSecurityAccess();
  DescSubcompOnceInitPidManager();
  DescSubcompOnceInitRidManager();
  DescSubcompOnceInitPidListProcessor();
  DescSubcompOnceInitDynDefinePid();
  DescSubcompOnceInitDynDefineDpid();
  DescSubcompOnceInitRoeProcessor();
  DescSubcompOnceInitVariantManager();

#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /************************
    Subcomponent context init
    ************************/
    DescSubcompIterInitDebug(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitNetwork(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitTiming(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitState(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDispatcher(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitController(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitFaultMemory(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitScheduled(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitSecurityAccess(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitPidManager(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitRidManager(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitPidListProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDynDefinePid(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDynDefineDpid(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitRoeProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitVariantManager(DESC_CONTEXT_PARAM_VALUE);
#if(kDescNumContexts > 1)
  }
#endif
  /* Customized function */
  DescOemOnInit(initParam);
}

/*******************************************************************************
* NAME:              DescTimerTask
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescTimerTask(void)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

  /* Check if desc is globally in idle mode */
#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /* RCR-RP only during processing (pprocessingEnd but not during transmission) */
    if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & (kDescContextActiveProcess|kDescContextActiveProcessEnd)) != 0)
    {
      DescResponseTimeoutTask(DESC_CONTEXT_PARAM_ONLY);
    }
#if(kDescNumContexts > 1)
  }
#endif

#if defined (DESC_ENABLE_DESCICN_SUPPORT)
  if(DescIsNoExtConnectionActive())
#else
  if(DescIsNoConnectionActive())
#endif
  {
#if defined (DESC_ENABLE_AUTO_STATES)
    /* ----------------*/
    /* Tester Timeout  */
    /* ----------------*/
    if(g_descS1Timer != 0)
    {
      if(g_descDoReloadS1Timer == kDescTrue)
      {
        /* This will clear the flag. No data loss possible, since the flag can be only set 
         * in interrupt, and only here will be cleared.
         */
        g_descDoReloadS1Timer = kDescFalse;
        DescReloadS1Timer();
      }
      /* Decrement timer */
      g_descS1Timer--;
      /* Check for timeout */
      if(g_descS1Timer == 0)
      {
        /* Simulate the same behavior as it would be done by requesting
         * default session 
         */
# if (kDescStateGroupNumTransition > 0)
        /* Patch the setstate function to simulate real request */
        DescSetState(kDescDefaultSessionSvcInstEntry);
# endif
# if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
        DescNpmSetSleepInd();
# endif
        /* Special handling in case of S1 timeout */
        DescOemOnS1Timeout();
      }
    }
    else
#endif
    {
#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescOemNpmTimer();
#endif
      /* OEM specific timer during diag idle & default session) */
      DescOemDescIdleTimer();
    }
  }

#if defined(kDescSecureTimer) && defined(DESC_ENABLE_SECURITY_ACCESS)
# if (kDescSecureTimer != 0)
  DescSecurityAccessTimer();
# endif
#endif

  /* Custom timers */
  DescOemTaskTimer();
#if defined(DESC_ENABLE_PERIODIC_MODE)
  /* In case of periodic PIDs process them here */
  DescSchedulerTimerTask();
#endif
  /* Call the DescNet  tasks */
  DescUudtNetTimerTask();
  DescUsdtNetAbsTimerTask();
}

/*******************************************************************************
* NAME:              DescResponseTimeoutTask
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
static void DescResponseTimeoutTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT)
  /* --------------------------------------------------------*/
  /* Response pending time limitation -----------------      */
  /* --------------------------------------------------------*/
  /* Attention: Reenable interrupt after comparision against zero to avoid test-and-set problem. */
  if(g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE] != 0)
  {
    g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE]--;
    if(g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE] == 0)
    {
# if defined (DESC_ENABLE_FORCE_RCR_RP)
      /* Reset this flag if set */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;
# endif
# if defined(DESC_ENABLE_RES_RINGBUFFER)
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
      {
        DescRingBufferCancel(DESC_CONTEXT_PARAM_ONLY);
      }
      else
# endif
      {
        /* Stop sending of further $78 error codes */
        DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
        /* further call of processing done is illegal */
# if defined(DESC_ENABLE_OEM_HANDLING_ON_RCRRP_LIMIT_EXPIRATION)
        /* Custom action */
        DescOemOnResPendingOvertime(DESC_CONTEXT_PARAM_VALUE);
# else
        DescInterruptDisable();
        /* Set no response - just finalize the request */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
        /* Set an error so no complicatet checks to be performed and no PostHandler to be called */
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = (DescNegResCode)(~kDescNrcNone);

        /* Close the case :) */
        DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
        DescInterruptRestore();
# endif
      }
      /* Notify the application about timeout */
      ApplDescResponsePendingOvertimed(DESC_CONTEXT_PARAM_ONLY);
      return;
    }
  }
#endif
  /* --------------------------------------------------------*/
  /* Response Timeout ---------------------------------------*/
  /* --------------------------------------------------------*/
  if(g_descT2Timer[DESC_CONTEXT_PARAM_VALUE] != 0)
  {
#if defined (DESC_ENABLE_FORCE_RCR_RP)
    /* Check if the application needs RCR-RP right now */
    if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState == kDescForcedRcrRpCharged)
    {
      /* Check if the TX channel is free */
      if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType == kDescUsdtResponseNone)
      {
# if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
        /* Catch situation: ongoing USDT periodic response and parallel main response 
         * check if other context wants to send or scheduler is not on sending */
        if((DESC_CONTEXT_PARAM_VALUE != kDescPrimContext)
            ||((g_descInterruptContextCtrl[kDescSchedulerContext].activity & kDescContextActiveTx) == 0))
# endif
        {
          /* reserve the TX channel for single frame */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType = kDescUsdtResponseNegativeApplRCR_RP;
          /* reset RCR-RP state */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;

          /* Ignore the SPRMB value and send always positive response if at least one RCR-RP has been sent */
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = 0;

          DescTransmitRcrRp(DESC_CONTEXT_PARAM_WRAPPER_ONLY(DESC_CONTEXT_PARAM_VALUE));
        }
      }
      else
      { /* Force timeout */
        g_descT2Timer[DESC_CONTEXT_PARAM_VALUE] = 1;
      }
    }
    else
#endif
    {
      /* TimeoutT2 unequal to 0 means running */
      g_descT2Timer[DESC_CONTEXT_PARAM_VALUE]--;
      /*Timeout reached?*/
      if(g_descT2Timer[DESC_CONTEXT_PARAM_VALUE] == 0)
      {
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
        if(g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE] != 0)
#endif
        {
          /* Check for request with response required */
          if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq &
              g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
          {
            /* Ignore the SPRMB value and send always positive response if P2 time has expired */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = 0;
            /* Check if the TX channel is free */
            if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType == kDescUsdtResponseNone)
            {
#if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
              /* Catch situation: ongoing USDT periodic response and parallel main response 
               * check if other context wants to send or scheduler is not on sending */
              if((DESC_CONTEXT_PARAM_VALUE != kDescPrimContext)
                  ||((g_descInterruptContextCtrl[kDescSchedulerContext].activity & kDescContextActiveTx) == 0))
#endif
              {
                /* reserve the TX channel for single frame */
                g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType = kDescUsdtResponseNegativeRCR_RP;

                DescTransmitRcrRp(DESC_CONTEXT_PARAM_WRAPPER_ONLY(DESC_CONTEXT_PARAM_VALUE));
              }
            }
            else
            {
              /* Retry again */
              g_descT2Timer[DESC_CONTEXT_PARAM_VALUE]++;
            }
          }
          else
          {
            /* Run into assertion to show during development that the application can not fulfill
             * the timing requirements for the tester.
             */
            DescAssertUserAlways(kDescAssertApplLackOfConfirmation);
          }
        }
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
        else
        {
# if defined (DESC_ENABLE_FORCE_RCR_RP)
          /* Reset this flag if set */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;
# endif
# if defined(DESC_ENABLE_RES_RINGBUFFER)
          if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
          {
            DescRingBufferCancel(DESC_CONTEXT_PARAM_ONLY);
          }
          else
# endif
          {
# if defined(DESC_ENABLE_OEM_HANDLING_ON_RCRRP_LIMIT_EXPIRATION)
            /* Custom action */
            DescOemOnResPendingOverrun(DESC_CONTEXT_PARAM_VALUE);
# else
            DescInterruptDisable();
            /* Set no response - just finalize the request */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
            /* Set an error so no complicatet checks to be performed and no PostHandler to be called */
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = (DescNegResCode)(~kDescNrcNone);

            /* Close the case :) */
            DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
            DescInterruptRestore();
# endif
          }
          /* Notify the application about timeout */
          ApplDescResponsePendingOverrun(DESC_CONTEXT_PARAM_ONLY);
        }
#endif
      }/* T2 timeout case */
    }/* T2 timer running check */
  }
}


/*******************************************************************************
* NAME:              DescTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescTask(void)
{
#if defined(DESC_ENABLE_HIPERFORMANCE_DYNDID_MODE)
  /* Do not call the state task again to avoid CPU overload - the do-while loop will do this job */
#else
  DescStateTask();
#endif
  DescTimerTask();
}


/*******************************************************************************
* NAME:              DescStateTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescStateTask(void)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

  /*Postprocess UUDT confirmation*/
  DescUudtNetStateTask();

  /*-------------------------*/
  /* Global tasks processing */
  /*-------------------------*/
#if defined(DESC_ENABLE_PERIODIC_MODE)
  DescSchedulerTask();
#endif
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE)
  DescDynDidTask();
#endif
#if defined (DESC_ENABLE_ROE_SUPPORT)
  DescRoeStateTask();
#endif
  /*--------------------------*/
  /* Context tasks processing */
  /*--------------------------*/
#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /* Check pending post-processing */
    if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity != kDescContextIdle)
    {
      DescContextStateTask(DESC_CONTEXT_PARAM_ONLY);
    }
#if(kDescNumContexts > 1)
  }
#endif

  /*-------------------------*/
  /* Global tasks processing */
  /*-------------------------*/

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  DescNpmProcessQueue();
#endif
  /* Call the DescNet  tasks */
  DescUudtNetStateTask();
  DescUsdtNetAbsStateTask();
}

/*******************************************************************************
* NAME:              DescContextStateTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
static void DescContextStateTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /*------------------------*/
  /*  Post processing task  */
  /*------------------------*/
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & kDescContextActivePostProcess) != 0)
  {
    vuint8  postProcessState;

    DescInterruptDisable();
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity &= (DescContextActivity)(~kDescContextActivePostProcess);
    DescInterruptRestore();

    /* By default - ok */
    postProcessState = kDescPostHandlerStateOk;

    /* Check the status of the response */
    if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState != kDescUsdtNetworkOk)
    {
      /* Clear ok, set error type */
      postProcessState = kDescPostHandlerStateTxFailed;
    }

    /* Add type of the response */
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
    {
      /* Clear ok, set error type */
      postProcessState &= (vuint8)(~kDescPostHandlerStateOk);
      postProcessState |= kDescPostHandlerStateNegResSent;
    }

#if defined (DESC_ENABLE_RES_RINGBUFFER)
    /**********************
    * RingBuffer handling
    **********************/
    /* Ring buffer relevant states reset */
    DescRingBufferStateReset(DESC_CONTEXT_PARAM_ONLY);
#endif

    ApplDescGenericServiceConfirmation(postProcessState);
#if defined (DESC_ENABLE_POSTHANDLER_USAGE)
    /* Call the post handler only if application error was active */
    if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError != 0)
    {
      /* Call the post handler */
      g_descPostHandlerTable[g_descSvcInst[g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]].postHandlerRef](DESC_CONTEXT_PARAM_FIRST postProcessState);
    }
#endif

#if defined (DESC_ENABLE_AUTO_STATES) && (kDescStateGroupNumTransition > 0)
    /*----------------------------*/
    /*        Modify state        */
    /*----------------------------*/
    /* Called only in successfully finished 
     * request processing */
    if((postProcessState & kDescPostHandlerStateOk) != 0)
    {
      DescSetState(g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]);
    }
#endif
  }

  /*-------------------------*/
  /*    Rx processing task   */
  /*-------------------------*/
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveRxEnd)
  {
    /* Switch to process state */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcess;

#if defined (DESC_ENABLE_DESCICN_SUPPORT)
    /* Check if this instance is a internal request */
    if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType != kDescUsdtNetReqTypeInternal)
#endif
    {
      /* transfer addressing information from infoPool into MsgContext */
      if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType == kDescUsdtNetReqTypeFunctional)
      {
        /* Specify that the current request was actually a functional one */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescFuncReq;
      }
      else
      {
        /* Set request addressing method */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescPhysReq;
      }
      /* Copy the SID for RCR-RP response. 
       * necessary for multi session diag to know which one will be sent
       */
      g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][1] = *g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;

      /* Activate always the T2 timer. Once the timeout occurs, 
       * there will be decision about sending a response or not.
       */
      DescActivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
      DescActivateLimiter(DESC_CONTEXT_PARAM_VALUE);
    }
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
    else
    {
      /* Set request addressing method always to simulate physical reception */
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescPhysReq;
    }
#endif
    /* Stores the length */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength;

    /* Clear the error code */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
    /* Process the dispatcher */
    DescDispatcher(DESC_CONTEXT_PARAM_ONLY);
  }

  /*------------------------------*/
  /*    Process processing task   */
  /*------------------------------*/
#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL) || defined (DESC_ENABLE_PID_LIST_MODE)
  /*--------------------------------------*/
  /*    Repeated Main-Handler Call task   */
  /*--------------------------------------*/
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & (kDescContextActiveProcess |
                                                                       kDescContextActiveTxReady |
                                                                       kDescContextActiveTx |
                                                                       kDescContextActiveProcessEnd)) != 0)
  {
    /*--------------------------------------*/
    /*    Repeated Main-Handler Call task   */
    /*--------------------------------------*/
# if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
    if(g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] != V_NULL)
    {
#  if defined(DESC_ENABLE_PID_LIST_MODE)
      /* If list mode service - process using its context */
      if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode == kDescContextModePidList)
      {
        g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE](&g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE]);
      }
      else
#  endif
      {
        g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE](&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]);
      }
    }
# endif
# if defined (DESC_ENABLE_PID_LIST_MODE)
    DescPidProcessorTask(DESC_CONTEXT_PARAM_ONLY);
# endif
  }
#endif

  /*-------------------------*/
  /*    Tx processing task   */
  /*-------------------------*/
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveTxReady)
  {
    /* Check if the TX channel is free */
#if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
    /* Catch situation: ongoing USDT periodic response and parallel main response 
     * check if other context wants to send or scheduler is not on sending */
    if((DESC_CONTEXT_PARAM_VALUE != kDescPrimContext)
        ||((g_descInterruptContextCtrl[kDescSchedulerContext].activity & kDescContextActiveTx) == 0))
#endif
    {
      if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType == kDescUsdtResponseNone)
      {
        /* Deactivate the RCR-RP timer here:
         * - equivalent to stopping it into ProcessingDone
         * - reduces code complexity to distinguish the different use cases 
         */
        DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
        DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);

        /* Set the new state of CANdesc */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTx;

        /* reserve the TX channel and set the confirmation type to be expected */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength = g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
        if (g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
        {
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType    = kDescUsdtResponseRingBuffer;
        }
        else
#endif
        {
          /* Check if the negative response code is set */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType    = (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)?kDescUsdtResponsePositive:kDescUsdtResponseNegative;
        }
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
    /* Save code */
#else
        if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr == V_NULL)
        {
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = DescUsdtNetGetTransmissionPtr(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
          memcpy(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr,g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr,g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength);
        }
        else
#endif
        {
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
        }
        DescUsdtNetAbsTransmitResponse(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
      }
    }
  }
}

/*  ********************************************************************************
 * Function name:DescOemStartSessionDefault
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemStartSessionDefault(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionDefault);
}


/*  ********************************************************************************
 * Function name:DescOemStartSessionProgramming
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemStartSessionProgramming(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionProgramming);
}


/*  ********************************************************************************
 * Function name:DescOemStartSessionExtended
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemStartSessionExtended(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionExtendedDiagnostic);
}


/*  ********************************************************************************
 * Function name:DescOemStartSessionNxtrMode
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemStartSessionNxtrMode(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionNxtr_Mode);
}


/*  ********************************************************************************
 * Function name:DescOemCommCtrlEnableRxEnableTx
 * Description:The communicationType is a 1-byte value. The bit-encoded low nibble of this byte
 * represents the communicationTypes, which can be controlled via the
 * CommunicationControl (28 hex) service. For example, a communicationType with a
 * bit combination (Bits 1-0) of "11b" is valid and disables both
 * "normalCommunicationMessages" and "networkManagementCommunicationMessages"
 * messages. 
 * The high nibble of the communicationType 1-byte value defines which of the
 * subnets connected to the receiving node shall be disabled/enabled when an
 * appropriate CommunicationControl service is received
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemCommCtrlEnableRxEnableTx(DescMsgContext* pMsgContext)
{
  DescOemCommonCommCtrlProcess(DescMakeCommCtrlParam(kDescCommControlStateEnable, kDescCommControlStateEnable), pMsgContext);
}


/*  ********************************************************************************
 * Function name:DescOemCommCtrlEnableRxDisableTx
 * Description:The communicationType is a 1-byte value. The bit-encoded low nibble of this byte
 * represents the communicationTypes, which can be controlled via the
 * CommunicationControl (28 hex) service. For example, a communicationType with a
 * bit combination (Bits 1-0) of "11b" is valid and disables both
 * "normalCommunicationMessages" and "networkManagementCommunicationMessages"
 * messages. 
 * The high nibble of the communicationType 1-byte value defines which of the
 * subnets connected to the receiving node shall be disabled/enabled when an
 * appropriate CommunicationControl service is received
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemCommCtrlEnableRxDisableTx(DescMsgContext* pMsgContext)
{
  DescOemCommonCommCtrlProcess(DescMakeCommCtrlParam(kDescCommControlStateDisable, kDescCommControlStateEnable), pMsgContext);
}


/*  ********************************************************************************
 * Function name:DescOemPostStartSessionDefault (Service request header:$10 $1 )
 * Description:If no other diagnostic session is requested, then the Default Session shall be
 * running as long as the ECU is powered.
 * Returns:  nothing
 * Parameter(s):
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionDefault(vuint8 status)
{
  DescOemCommonSessionPostProcessing(status, kDescStateSessionDefault);
}


/*  ********************************************************************************
 * Function name:DescOemPostStartSessionProgramming (Service request header:$10 $2 )
 * Description:This session type provides the specific functionality required for ECU Flash
 * Re-programming defined in DC-10761.
 * Returns:  nothing
 * Parameter(s):
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionProgramming(vuint8 status)
{
  DescOemCommonSessionPostProcessing(status, kDescStateSessionProgramming);
}


/*  ********************************************************************************
 * Function name:DescOemPostStartSessionExtended (Service request header:$10 $3 )
 * Description:This session type provides a timer controlled environment for an ECU in which all
 * of the supported diagnostic services can be executed. Those diagnostic services
 * which temporarily alter the default behavior of an ECU are reset when the
 * Extended Diagnostic Session is left (either by diagnostic service request or via
 * a timeout condition). As all diagnostic services are supported in the Extended
 * Diagnostic Session (given that security access protected diagnostic services are
 * properly unlocked before usage) this session is usually entered before any
 * diagnostics are performed in engineering, manufacturing and service.
 * Returns:  nothing
 * Parameter(s):
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionExtended(vuint8 status)
{
  DescOemCommonSessionPostProcessing(status, kDescStateSessionExtendedDiagnostic);
}


/*  ********************************************************************************
 * Function name:DescOemPostStartSessionNxtrMode (Service request header:$10 $7E )
 * Description:This session is for Nxtr personnel only
 * Returns:  nothing
 * Parameter(s):
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemPostStartSessionNxtrMode(vuint8 status)
{
  DescOemCommonSessionPostProcessing(status, kDescStateSessionNxtr_Mode);
}


#if defined (DESC_ENABLE_ANY_PREHANDLER_USAGE)
/*******************************************************************************
* NAME:              DescDummyPreHandler
*
* CALLED BY:         DESCDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Used instead of V_NULL pointer
*
*******************************************************************************/
static void DESC_API_CALL_TYPE DescDummyPreHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
}
#endif

#if defined (DESC_ENABLE_ANY_POSTHANDLER_USAGE)
/*******************************************************************************
* NAME:              DescDummyPostHandler
*
* CALLED BY:         DESCDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Used instead of V_NULL pointer
*
*******************************************************************************/
static void DESC_API_CALL_TYPE DescDummyPostHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
  DESC_IGNORE_UNREF_PARAM(status);
}
#endif

/*******************************************************************************
* NAME:              DescSessionGetSuppressPosBit
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Will return the current value of the SPRMIB.
*
*******************************************************************************/
DescBool DESC_API_CALL_TYPE DescIsSuppressPosResBitSet(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return V_BOOL_EXPR(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes != 0);
}

/************************************************/
/* $3E Tester Present */
/************************************************/
/*******************************************************************************
* NAME:              DescOemProcessTesterPresent
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemProcessTesterPresent(DescMsgContext *pMsgContext)
{
#if (kDescNumContexts == 1)
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(pMsgContext);
#endif
  DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
}

#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
/*******************************************************************************
* NAME:              DescOemCheckAndExtractCommTypeParam
*
* CALLED BY:         Chrysler/CommunicationControl is activated
* PRECONDITIONS:     
*
* DESCRIPTION:       Checks if the subnetNumber is not 0xF0
*
*******************************************************************************/
static DescBool DescOemCheckAndExtractCommTypeParam(DescOemCommControlInfo * pCommControlInfo, DescMsgItem comType)
{
  DescBool returnValue = kDescFalse;

  if(((comType & 0x0F) <= kDescCommControlMsgTypeAll) &&
     ((comType & 0x0F) != 0)  &&
     ((comType & 0xF0) != 0xF0)
     )
  {
    /* Extract ComType parameter values */
    pCommControlInfo->msgTypes = (DescBitType)(comType & 0x03);
    pCommControlInfo->subNetNumber = (DescBitType)((comType & 0xF0) >> 4);

    returnValue = kDescTrue;
  }
  return returnValue;
}
#endif

/*******************************************************************************
* NAME:              DescEnableCommunication
*
* CALLED BY:         Application/DescInit/Session fall
* PRECONDITIONS:     
*
* DESCRIPTION:       Enables the communciation for all messages on all channels.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescEnableCommunication(void)
{
  /* Prepare for "TxEnable on ALL channels" */
  g_descCommControlInfo.subNetNumber   = kDescCommControlSubNetNumAll;
  g_descCommControlInfo.txPathState    = kDescCommControlStateEnable;
#if defined (DESC_ENABLE_RX_COMM_CONTROL)
  g_descCommControlInfo.rxPathState    = kDescCommControlStateEnable;
#endif
  g_descCommControlInfo.msgTypes       = kDescCommControlMsgTypeAll;

  /* Context parameter doesn't mean anything - use zero.*/
  DescOemPostCommonCommCtrlProcess(DESC_CONTEXT_PARAM_WRAPPER_FIRST(0) kDescPostHandlerStateOk);
}

/*******************************************************************************
* NAME:              DescOemCommonCommCtrlProcess
*
* CALLED BY:         DescOemCommCtrl_XXXableRxAndXXXableTx
* PRECONDITIONS:     
*
* DESCRIPTION:       Central communciation control processing.
*
*******************************************************************************/
static void DescOemCommonCommCtrlProcess(vuint8 reqInfo, DescMsgContext *pMsgContext)
{
  DescNegResCode errorCode = kDescNrcNone;

#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
  DescBool result;
#endif

  DESC_IGNORE_UNREF_PARAM(pMsgContext);

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  if(g_descIsOemMainHdlrAlreadyCalled == kDescFalse)
#endif
  {
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
    g_descIsOemMainHdlrAlreadyCalled = kDescTrue;
#endif
    /* Optimize the pointer operation (only the first 4 bits are relevant)*/
#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
    /* Check control parameter type */
    result = DescOemCheckAndExtractCommTypeParam(&g_descCommControlInfo, pMsgContext->reqData[0]);
    if(kDescFalse == result)
    {
      errorCode = kDescNrcRequestOutOfRange;
    }
#else /*No Dynamic Communication Control Parameter*/
# if defined(DESC_ENABLE_COM_CTRL_PARAM_CHECK)
    if(pMsgContext->reqData[0] != (vuint8)kDescComParam)
    {
      errorCode = kDescNrcRequestOutOfRange;
    }
    else
# endif
    {
      g_descCommControlInfo.msgTypes = (DescBitType)((kDescComParam)& 0x03);
      g_descCommControlInfo.subNetNumber = (DescBitType)(((kDescComParam) & 0xF0) >> 4);
    }
#endif
    if(kDescNrcNone == errorCode)
    {
      /* Set the TX communication state */
      g_descCommControlInfo.txPathState = reqInfo;
#if defined (DESC_ENABLE_RX_COMM_CONTROL)
      /* Set the TX communication state */
      g_descCommControlInfo.rxPathState = (DescBitType)(reqInfo >> 2);
#endif
#if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
      g_descCommControlInfo.reqCommChannel = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(pMsgContext->iContext)].infoPoolPtr->busInfo.comChannel;
#endif

      /* make customized parameter interpretation */
      DescOemCustomizeComTypeParam(&g_descCommControlInfo);

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
      /* Let the application decide which sub-network to which CAN channel is mapped */
#else
      if((g_descCommControlInfo.subNetNumber == kDescCommControlSubNetNumAll) ||
        (g_descCommControlInfo.subNetNumber == kDescCommControlSubNetNumRx))
      {
        /* Legal parameter values both for single and multi channel systems */
      }
      else
      {
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
        /* Assume 1:1 mapping subNetNumber:CAN (on multi channel system) */
        g_descCommControlInfo.commCtrlChannel = g_descCommControlInfo.subNetNumber;
        /* Convert subnetNum1 -> CAN0, etc.*/
        g_descCommControlInfo.commCtrlChannel--;
        /* If an invalid subnetwork (CAN channel) is requested - reject */
        if(g_descCommControlInfo.commCtrlChannel > (kDescNumCommChannels - 1))
        {
          errorCode = kDescNrcRequestOutOfRange;
        }
# else
        /* No sub-networks => no subnetwork number can be requested */
        errorCode = kDescNrcRequestOutOfRange;
# endif
      }
#endif

      /* Prepare the response length for positive response 
      * done by Dispatcher  (set to zero)
      */
    }
  }

  if(errorCode == kDescNrcNone)
  {
    /* Call the application for request data evaluation */
    ApplDescCheckCommCtrl(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) &g_descCommControlInfo);
  }
  else
  {
    /* Only out of range is used - use the constant */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcRequestOutOfRange);
    DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
  }
}

/*******************************************************************************
* NAME:              DescOemPostCommonCommCtrlProcess
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Processes the request after the positive response was sent.
*
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemPostCommonCommCtrlProcess(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  DESC_COMM_CHANNEL_LOCAL_PARAM_DEF

  /* If you intend to use the context parameter don't forget the DescEnableCommunication API!!! */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateOk) != 0)
  {
    switch(g_descCommControlInfo.subNetNumber)
    {
      case kDescCommControlSubNetNumAll:/* Disable all comm channels (CAN, LIN, etc.)*/
        DESC_COMM_CHANNEL_PARAM_VALUE_INIT;
        DESC_COMM_CHANNEL_LOOP
        {
          DESC_COMM_CHANNEL_PARAM_VALUE_DEC;
          DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_PARAM_ONLY);
        }
#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
        /* Manipulate application channels */
        ApplDescSetCommMode(&g_descCommControlInfo);
#endif
        break;
      case kDescCommControlSubNetNumRx:/* Disable only the request RX comm channel (CAN)*/
        DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_PARAM_WRAP_ONLY(g_descCommControlInfo.reqCommChannel));
        break;
      default:
        if(g_descCommControlInfo.commCtrlChannel != kDescCommControlCanChNone)
        {
          DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_PARAM_WRAP_ONLY(g_descCommControlInfo.commCtrlChannel));
        }
#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
        else
        {
          /* Only application specific communication busses (no CAN) */
          ApplDescSetCommMode(&g_descCommControlInfo);
        }
#endif
    }

    if((g_descCommControlInfo.txPathState & kDescCommControlStateEnable) != 0)
    {
      /* Notify the application about the enabling communication */
      ApplDescOnCommunicationEnable();
    }
    else
    {
      /* Notify the application about the disabling communication */
      ApplDescOnCommunicationDisable();
    }
  }
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* Always clear the flag */
  g_descIsOemMainHdlrAlreadyCalled = kDescFalse;
#endif
}

/*******************************************************************************
* NAME:              DescCommCtrlManipulateCAN
*
* CALLED BY:         DescOemPostCommonCommCtrlProcess
* PRECONDITIONS:     
*
* DESCRIPTION:       Processes requested action.
*
*******************************************************************************/
static void DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ONLY)
{
  if((g_descCommControlInfo.txPathState & kDescCommControlStateEnable) != 0)
  {
    DescCommSetTxOnline(DESC_COMM_CHANNEL_PARAM_VALUE, g_descCommControlInfo.msgTypes);
  }
  else
  {
    DescCommSetTxOffline(DESC_COMM_CHANNEL_PARAM_VALUE, g_descCommControlInfo.msgTypes);
  }

#if defined (DESC_ENABLE_RX_COMM_CONTROL)
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
  /* Reinit the comm channel in case of multi CAN */
  g_descCommControlInfo.commCtrlChannel = DESC_COMM_CHANNEL_PARAM_VALUE;
# endif
  /* let the application to manipulate the RX path */
  ApplDescSetCommModeOnRxPath(&g_descCommControlInfo);
#endif
}

/*******************************************************************************
* NAME:              DescOemPrepareSessionControl
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Prepares the response for DiagnosticSessionControl.
*
*******************************************************************************/
static void DescOemPrepareSessionControl(DescMsgContext *pMsgContext, DescStateGroup targetSession)
{
#if defined (DESC_ENABLE_P2_TIME_REPORT)
  DescMsg   resData;
  vuint16   p2Time, p2ExTime;
#endif

  DESC_IGNORE_UNREF_PARAM(pMsgContext);/* Not always used - ignore per default! */

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  if(g_descIsOemMainHdlrAlreadyCalled == kDescFalse)
#endif
  {
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
    g_descIsOemMainHdlrAlreadyCalled = kDescTrue;
#endif
#if defined (DESC_ENABLE_P2_TIME_REPORT)
    resData = pMsgContext->resData;
    /* Set the new response length */
    pMsgContext->resDataLen = 4;

    DescGetSessionTimings(targetSession, &p2Time, &p2ExTime);
    /* Set P2 Time for the response */
    resData[0] = DescGetHiByte(p2Time);
    resData[1] = DescGetLoByte(p2Time);
    /* Set P2* Time for the response */
    resData[2] = DescGetHiByte(p2ExTime);
    resData[3] = DescGetLoByte(p2ExTime);
#endif
#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
    /* Store the CAN channel here, since there during the session transition there can be another request */
    DescSetNpmOnCanChannelActive(pMsgContext->busInfo.comChannel, g_descCanChannelMapQueue);
#endif
  }

  /* Ask the application for permission to accept the session transition */
  ApplDescCheckSessionTransition(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) targetSession, g_descCurState.stateSession);
}

#if defined (DESC_ENABLE_COMMON_OEM_POST_HANDLER)
/*******************************************************************************
* NAME:              DescOemCommonSessionPostProcessing
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Common DiagnosticSessionControl session post handler.
*                    Workaround for session self-transitioning.
*
*******************************************************************************/
static void DescOemCommonSessionPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status, DescStateGroup newSession)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  DESC_IGNORE_UNREF_PARAM(status);
  DESC_IGNORE_UNREF_PARAM(newSession);
# if defined (DESC_ENABLE_SESSION_SELFTRANSITION_SIM) || \
     defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  /* If ok ( no negative response, no transmission failure) */
  if((status & kDescPostHandlerStateOk) != 0)
  {
#  if defined (DESC_ENABLE_SESSION_SELFTRANSITION_SIM)
    /* Simulate session self-transition into default one */
    if((((DescStateGroup)g_descCurState.stateSession) & newSession) != 0)
    {
      DescSetStateSession(newSession);
    }
#  endif
  }
#  if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  else
  {
    /* Reset the queue if error */
    g_descCanChannelMapQueue = 0;
  }
#  endif
# endif
}
#endif

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
/*******************************************************************************
* NAME:              DescSessionTransitionChecked
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Session transition check finished.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescSessionTransitionChecked(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Clear always the flag */
  g_descIsOemMainHdlrAlreadyCalled = kDescFalse;
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}
#endif

/*******************************************************************************
* NAME:          DescFaultMemoryOnceInitPowerOn
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Subcomponent init power on implementation 
*                
*******************************************************************************/
static void DescFaultMemoryOnceInitPowerOn(void)
{
  g_descFrfmSrcBuffer = 0;
}


/*******************************************************************************
* NAME:          DescOemClearFaultMem
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - ClearDiagnosticInformation (Svc $14)
*                
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemClearDiagInfo(DescMsgContext* pMsgContext)
{
  /* Clear DTC */
  t_FrfmReturnCode resultValue;

  pMsgContext->resDataLen = 0;

  resultValue = FrfmClearDTC((t_FrfmDtcNumType)(DescMake32Bit(0,pMsgContext->reqData[0],pMsgContext->reqData[1],pMsgContext->reqData[2])), frfmDO_ChronoStack);
  if (resultValue == frfmRC_OK)
  {
    /*positive response - DTC or DTC range cleared*/
  }
  else if (resultValue == frfmRC_WrongDTC)
  {
    /*negative response - specified groupOfDTC parameter is not supported*/
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcRequestOutOfRange );
  }
  else  /* (resultValue == frfmRC_Failed) */
  {
    /*negative response - internal error */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcInvalidFormat );
  }

  DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
}

/*******************************************************************************
* NAME:          DescOemReadDtcRDTCBSM
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - ReadDTCInformation (Svc $19 02)
*            reportDTCByStatusMask                
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemReadDtcRDTCBSM(DescMsgContext* pMsgContext)
{
  /*access chrono stack*/
  g_descFrfmRequestedCount = FrfmSetDTCFilter(pMsgContext->reqData[0], frfmDO_ChronoStack);
#if defined (FRFM_ENABLE_HISTORICALSTACK)
  if (g_descFrfmRequestedCount != 0xFFFF)
  {
    FrfmCopyChronoToHistoricalStack();
    FrfmUpdateInterrogationRecord();  /*update on successful requests  ** DPRS 9.4-85*/
  }
#endif

  if (g_descFrfmRequestedCount != 0xFFFF)
  {
    /* Check for wrongly set SPRMIB by the tester */
    if(pMsgContext->msgAddInfo.suppPosRes == 0)
    {
      vuint8 data[1];

      pMsgContext->resDataLen = 1 + (4 * g_descFrfmRequestedCount);
      data[0] = FrfmGetDTCStatusAvailab_Mask();

      DescRingBufferStart(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));

      /* the first octet will always fit in the ring buffer */
      (void) DescRingBufferWrite(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) data, 1);
      /* fill the ring buffer for the first time */
      DescFrfmFillRbByDtcAndValue(pMsgContext);

      /* if there is more data than ring buffer size, use repeated service call to fill */
      if (g_descFrfmRequestedCount > 0)
      {
        DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) DescFrfmFillRbByDtcAndValue);
      }
    }
    else
    {
      /* Just close the service processing */
      DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
    }
  }
  else  /* FRFM is non-operative */
  { /*negative response - ConditionsNotCorrect */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcConditionsNotCorrect );
    DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
  }
}


/*******************************************************************************
* NAME:          DescOemReadDtcRDTCEDRBDN
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - ReadDTCInformation (Svc $19 06)
*                 reportDTCExtendedDataRecordByDTCNumber
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemReadDtcRDTCEDRBDN(DescMsgContext* pMsgContext)
{
  DescNegResCode   errorCode = 0;
  t_FrfmDtcNumType reqDTC;
  t_FrfmReturnCode rc;

  reqDTC = DescMake32Bit(0, pMsgContext->reqData[0], pMsgContext->reqData[1], pMsgContext->reqData[2]);
  rc = FrfmLockExtendedDataRecordByDTC(reqDTC, frfmDO_ChronoStack, pMsgContext->reqData[3], (vuint16*) &g_descFrfmRequestedCount);
#if defined (FRFM_ENABLE_HISTORICALSTACK)
  if (rc == frfmRC_OK)
  {
    FrfmUpdateInterrogationRecord(); /*update on successful requests  ** DPRS 9.4-85*/
  }
  if (rc == frfmRC_OK || rc == frfmRC_WrongRecordNumber)
  {
  /* access to valid DTC number triggers copying the chrono stack to historical stack */
    FrfmCopyChronoToHistoricalStack();
  }
#endif

  if (rc == frfmRC_OK)
  {
    /* Check for wrongly set SPRMIB by the tester */
    if(pMsgContext->msgAddInfo.suppPosRes == 0)
    {
      /* set length of response (g_descFrfmRequestedCount is always >0) */
      pMsgContext->resDataLen = g_descFrfmRequestedCount;

      /* success on locking the data, now start filling the ringbuffer */
      DescRingBufferStart(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));

      /* use repeated service call to fill the data */
      DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) DescFrfmFillRbDTCExtRecByDTCNum);

      /* fill the ring buffer for the first time */
      /* if there is no more data to copy, repeated service call will be stopped by the DescRingBufferWrite API */
      DescFrfmFillRbDTCExtRecByDTCNum(pMsgContext);

      /* the data record is unlocked in DescFrfmFillRbDTCExtRecByDTCNum() */
    }
    else
    {
      /* Release lock */
      (void) FrfmUnlockExtDataRecordByDTC();
      /* Just close the service processing */
      DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
    }
  }
  else if (rc == frfmRC_WrongDTC || rc == frfmRC_WrongRecordNumber)
  {
    /*negative response - invalid DTC or invalid record number request*/
    errorCode = kDescNrcRequestOutOfRange;
  }
  else /* (rc == frfmRC_Failed) */
  {
    /*negative response - Conditions not correct*/
    errorCode = kDescNrcConditionsNotCorrect;
  }

  if (errorCode != 0)
  {
    /* negative response */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) errorCode );
    DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
  }
}

/*******************************************************************************
* NAME:          DescOemReadDtcRSUPDTC
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - ReadDTCInformation (Svc $19 0A)
*                 reportSupportedDTCs
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemReadDtcRSUPDTC(DescMsgContext* pMsgContext)
{
  g_descFrfmRequestedCount = FrfmSetDTCFilter(0x00u, frfmDO_AllSupported);
  if (g_descFrfmRequestedCount != 0xFFFF)
  {
#if defined (FRFM_ENABLE_HISTORICALSTACK)
    FrfmCopyChronoToHistoricalStack();
    FrfmUpdateInterrogationRecord();                            /*update on successful requests  ** DPRS 9.4-85*/
#endif
    /* Check for wrongly set SPRMIB by the tester */
    if(pMsgContext->msgAddInfo.suppPosRes == 0)
    {
      vuint8 data[1];
      pMsgContext->resDataLen = 1 + (4 * g_descFrfmRequestedCount);
      data[0] = FrfmGetDTCStatusAvailab_Mask();
      DescRingBufferStart(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
      /* use repeated service call to fill the data */
      DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) DescFrfmFillRbByDtcAndValue);

      /* the first octet will always fit in the ring buffer */
      (void) DescRingBufferWrite(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) data, 1);
      /* fill the ring buffer for the first time */
      DescFrfmFillRbByDtcAndValue(pMsgContext);
    }
    else
    {
      /* Just close the service processing */
      DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
    }
  }
  else  /* FRFM is non-operative */
  { /*negative response - ConditionsNotCorrect */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcConditionsNotCorrect );
    DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
  }
}



/*******************************************************************************
* NAME:          DescFrfmFillRbByDtcAndValue
*
* CALLED BY:     DescOemProcessReadDtcInformation()-subservice functions ($19 xx)
* PRECONDITIONS: -
*
* DESCRIPTION:   Fill ring buffer for Diagnostic Service implementation of
*                ReadDTCInformation subfunction: reportDTCByStatusMask, 
*                                                reportMirrorMemoryDTCByStatusMask,
*                                           and  reportDTCFaultDetectionCounter
*******************************************************************************/
static void DescFrfmFillRbByDtcAndValue(DescMsgContext* pMsgContext)
{
  vuint8              data[4];
  DescMsgLen          freeSpace;
  t_FrfmDtcNumType    DiagFrfmDTC;
  t_FrfmReturnCode    result;
#if defined(DESC_ENABLE_ITER_LIMITATION)
  vuintx              limiter = kDescFillRbMaxCount;
#endif

  /* Ignore if not used */
  DESC_IGNORE_UNREF_PARAM(pMsgContext);

  /* fill the ring buffer until a) buffer is full or b) all DTCs are written */
  for (freeSpace = DescRingBufferGetFreeSpace(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
#if defined(DESC_ENABLE_ITER_LIMITATION)
      (limiter != 0) &&
#endif
      (g_descFrfmRequestedCount > 0) && (freeSpace >= 4);
#if defined(DESC_ENABLE_ITER_LIMITATION)
       --limiter,
#endif
      --g_descFrfmRequestedCount, freeSpace = DescRingBufferGetFreeSpace(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext)) )
  {
    result = FrfmGetNextFilteredDTC(&DiagFrfmDTC, &data[3]);
    if (result != frfmRC_OK)
    {
      g_descFrfmRequestedCount = 0;
      break;    /* this will abort the request by TP timeout */
    }
    data[0] = FrfmGetHiLoByte(DiagFrfmDTC);
    data[1] = FrfmGetLoHiByte(DiagFrfmDTC);
    data[2] = FrfmGetLoLoByte(DiagFrfmDTC);
  /*data[3]   is directly filled by FrfmGetNextFilteredDTC() */
    (void) DescRingBufferWrite(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) data, 4);
  }
}


/*******************************************************************************
* NAME:          DescFrfmFillRbDTCExtRecByDTCNum
*
* CALLED BY:     DescOemProcessReadDtcInformation()
* PRECONDITIONS: -
*
* DESCRIPTION:   Fill ring buffer for Diagnostic Service implementation of
*                ReadDTCInformation subfunction: reportDTCExtendedDataRecordByDTCNumber
*                                           and  reportMirrorMemoryDTCExtendedDataRecordByDTCNumber
*                Unlock data record, if no more data available
*******************************************************************************/
static void DescFrfmFillRbDTCExtRecByDTCNum(DescMsgContext* pMsgContext)
{
  DescMsgLen          freeSpace;
  t_FrfmReturnCode    result;
  vuint8              success;
  static vuint16  srcBufSize;
  static vuint16  offset;
#if defined(DESC_ENABLE_ITER_LIMITATION)
  vuint8_least    limiter = kDescFillRbMaxCount;
#endif

  /* Ignore if not used */
  DESC_IGNORE_UNREF_PARAM(pMsgContext);
  /* fill the ring buffer until a) buffer is full or b) all data is written */
  for (freeSpace = DescRingBufferGetFreeSpace(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
#if defined(DESC_ENABLE_ITER_LIMITATION)
    (limiter != 0) &&
#endif
    (g_descFrfmRequestedCount > 0) && (freeSpace > 0);
#if defined(DESC_ENABLE_ITER_LIMITATION)
  --limiter,
#endif
    freeSpace = DescRingBufferGetFreeSpace(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext)) )
  {
    if (g_descFrfmSrcBuffer == 0)
    {
      /* get next data from frfm to put into ring buffer */
      result = FrfmGetExtendedDataRecordByDTC(&g_descFrfmSrcBuffer, &srcBufSize);
      if (result != frfmRC_OK)
      {
        g_descFrfmRequestedCount = 0;
        break;    /* this will abort the request by TP timeout */
      }
      offset = 0;
    }
    /* write data to ring buffer */
    if ((srcBufSize - offset) > freeSpace)
    { /* limit count to freespace */
      success = DescRingBufferWrite(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) &g_descFrfmSrcBuffer[offset], freeSpace);
      if (success == kDescOk)
      {
        offset                   += freeSpace;
        g_descFrfmRequestedCount -= freeSpace;
      }
      break;    /* ring buffer is full now (or writing failed) */
    }
    else
    { /* whole data set will fit in ring buffer */
      success = DescRingBufferWrite(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) &g_descFrfmSrcBuffer[offset], (DescMsgLen) (srcBufSize-offset));
      if (success == kDescOk)
      {
        g_descFrfmRequestedCount -= (srcBufSize-offset);
        offset              = 0;
        g_descFrfmSrcBuffer = 0;
      }
      /*continue filling the buffer*/
    }
  }

  /* unlock record, if all bytes are sent */
  if (g_descFrfmRequestedCount == 0)
  {
    (void) FrfmUnlockExtDataRecordByDTC();
  }
}


/*******************************************************************************
* NAME:          DescOemPostProcessReadDtcInformation (Service request header: $19 06 and $19 10)
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Post Handler Diagnostic Service implementation - ReadDTCInformation
*                Unlock records on transmission errors
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemPostReadDtcInfo(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST  vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateTxFailed) != 0)
  {
    /* transmission has failed. */
    (void) FrfmUnlockExtDataRecordByDTC();
  }
}


/*******************************************************************************
* NAME:          DescOemReadROElightActivationState
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - ReadDataByIdentifier (RDBI) (Svc $22 0107)
*                 Get ResponseOnEventLightActivationState
*                
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemReadDidROElightActivationState(DescMsgContext* pMsgContext)
{
  t_FrfmBool returnValue;

  /* prepare response */
  pMsgContext->resDataLen = 1;

  returnValue = FrfmRoelGetActiveState();
  if (returnValue == frfmFalse)
  {
    pMsgContext->resData[0] = 0x00u;
  }
  else
  {
    pMsgContext->resData[0] = 0x01u;
  }
  DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
}


/*******************************************************************************
* NAME:          DescOemWriteROElightActivationState
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - WriteDataByIdentifier (WDBI) (Svc $2e 0107)
*                 Set ResponseOnEventLightActivationState: $2e 0107 <newActivation:0|1>
*                
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemWriteDidROElightActivationState(DescMsgContext* pMsgContext)
{
  /* prepare response */
  pMsgContext->resDataLen = 0;

  /* check for valid activation state value */
  if (pMsgContext->reqData[0] <= 1u)
  {
    if (pMsgContext->reqData[0] == 0x0u)
    {
      FrfmRoelSetActiveState(frfmFalse);  /* deactivated */
    }
    else
    {
      FrfmRoelSetActiveState(frfmTrue);   /* activated */
    }
  }
  else
  {
    /*negative response - invalid value for status flag */
    DescSetNegResponse( kDescNrcRequestOutOfRange );
  }

  DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
}


/*******************************************************************************
* NAME:          DescOemControlDTCSettingModeOn
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - ControlDTCSetting (Svc $85 01)
*                 switch on
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemControlDtcSettingEnable(DescMsgContext* pMsgContext)
{
  t_FrfmBool success = FrfmServiceSetStorageState(storageEnable);

  /* Ignore if not used */
  DESC_IGNORE_UNREF_PARAM(pMsgContext);
  if (success == frfmFalse)
  {
    /*negative response - Diag_Faultmemory is in non operable state  */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcConditionsNotCorrect );
  }
  else
  {
	  CDD_CntrlDTCReset_G_lgc == TRUE;
  }
  DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
}


/*******************************************************************************
* NAME:          DescOemControlDtcSettingDisable
*
* CALLED BY:     Desc.c
* PRECONDITIONS: -
*
* DESCRIPTION:   Diagnostic Service implementation - ControlDTCSetting (Svc $85 02)
*                 switch off
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemControlDtcSettingDisable(DescMsgContext* pMsgContext)
{
  t_FrfmBool success = FrfmServiceSetStorageState(storageDisable);

  /* Ignore if not used */
  DESC_IGNORE_UNREF_PARAM(pMsgContext);
  if (success == frfmFalse)
  {
    /*negative response - Diag_Faultmemory is in non operable state  */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcConditionsNotCorrect );
  }
  DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
}


/*******************************************************************************
* NAME:              DescPidProcessingDone
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent processing done for a single PID 
* iContext for the main response is also the same for the DID 
*******************************************************************************/
static void DescPidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
  /* The application sets the correct length - no compensation needed! */
#else
  /* Add the PID length */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen+= 2;
#endif
  /* Go on with the response */
  DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescReadDataByIdentifier
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Main handler for PID list handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescReadDataByIdentifier(DescMsgContext *pMsgContext)
{
  /* Use iContext when necessary */
  DESC_CONTEXT_PARAM_DEF_LOCAL
  DescPidInstIndex pidHandle;

#if (kDescNumContexts > 1)
  /* Use iContext as name to be able to use the DESC_CONTEXT_PARAM_VALUE macro */
  DESC_CONTEXT_PARAM_VALUE = pMsgContext->iContext;
#endif
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  g_descRdbiPidHandle[DESC_CONTEXT_PARAM_VALUE] = kDescInvalidPidHandle;
#endif
  /* The length for this service shall be ZERO to allow the application (CANdesc) 
   * to check it */
  if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen > 1)&&
    ((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen & 0x01) == 0))
  {
    /* Also the capacity of the ECU shall not be exceeded: reqLen = 2 means 1 DID => 
     * reqLen must not be > 2 in order to accept single DID only */
    if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen  == 2)
    {
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
      DescBool isSupported;
      pidHandle = DescMake16Bit(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[0],
                                g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[1]);
      isSupported = ApplDescIsPidSupported(pidTypeReadOnce, pidHandle);
#else
      /* Find PID (use main pool since each read-able PID is accessible by $22)*/
      pidHandle = DescPmGetAvailablePidHandle(DescMake16Bit(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[0],
                                                            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[1]));
#endif
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
      g_descRdbiPidHandle[DESC_CONTEXT_PARAM_VALUE] = pidHandle;
#endif

    /* If found */
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
      if(isSupported != kDescFalse)
#else
      if(pidHandle < kDescInvalidPidHandle)
#endif
      {
        /* Do dispatch the PID */
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = ApplDescVerifyPidAccessConditions(pidTypeReadOnce, pidHandle);
#else
        (void)DescPmAnalysePid(DESC_CONTEXT_PARAM_FIRST &g_descPIDInfo[pidHandle].tinyInfo);
#endif
        if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
        {
          /* Set the CANdesc in a PID List mode */
          g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModePidList;

          /* Copy the PID */
          pMsgContext->resData[0] = pMsgContext->reqData[0];
          pMsgContext->resData[1] = pMsgContext->reqData[1];

#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
          /* Let the pMsgContext pointees still to point to the PID for application PID dispatching */
          /* Request and response length parameter are still valid - do not touch them */
# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
          /* If each service needs it - start always here to save ROM for the application */
          _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, ApplDescReadDataByIdentifier);
# endif
          /* Call the only available main-handler for PID read: Sid $22's one.*/
          ApplDescReadDataByIdentifier(pMsgContext);
#else
          /* Simulate normal CANdesc mode (skip the protocol info) */
          pMsgContext->reqData+= 2;
          pMsgContext->resData+= 2;
          pMsgContext->reqDataLen -= 2;

# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
          /* If each service needs it - start always here to save ROM for the application */
          _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, g_descPIDInfo[pidHandle].mainHandler);
# endif
          /* Give the control to the application */
          g_descPIDInfo[pidHandle].mainHandler(pMsgContext);
#endif
          /* let the main-handler do the job */
          return;
        }
      }
      else
      {
        /* Out of range */
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
      }
    }
    else
    {
      /* Out of range */
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
    }
  }
  else
  {
    /* Invalid length */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
  }
  /* Reaching this point means diagnostic error was found */
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescPostReadDataByIdentifier
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Post handler for PID list handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescPostReadDataByIdentifier(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  DESC_IGNORE_UNREF_PARAM(status);
#if (kDescNumContexts > 1)
  DESC_IGNORE_UNREF_PARAM(DESC_CONTEXT_PARAM_VALUE);
#endif
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  if(g_descRdbiPidHandle[DESC_CONTEXT_PARAM_VALUE] != kDescInvalidPidHandle)
  {
    g_descPostHandlerTable[g_descPIDInfo[g_descRdbiPidHandle[DESC_CONTEXT_PARAM_VALUE]].postHandlerRef](DESC_CONTEXT_PARAM_FIRST status);
  }
#endif
}

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
/*******************************************************************************
* NAME:              DescPmGetPidResponseLen
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescMsgLen DescPmGetPidResponseLen(DescPidInstIndex pidHandle)
{
  DescMsgLen result;

  result = DescPmClientGetResLength(pidHandle);

  /* If client didn't recognize it as own DID */
  if(result == 0)
  {
    result = g_descPIDInfo[pidHandle].resDataLen;
  }

  return result;
}
#endif

/*******************************************************************************
* NAME:              DescAnalysePid
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescPidAnalyseFailureReason DescPmAnalysePid(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescPidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo)
{
  DescPidAnalyseFailureReason reason = pmAnalyseReasonOther;
  /*---------------------------------------------*/
  /*     Service ID addressing method check      */
  /*---------------------------------------------*/
  if ((pRefTinyInfo->msgAddInfo.reqType &
       g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
  {
#if defined (DESC_ENABLE_AUTO_STATES)
    /* Generated state checks */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = DescCheckState(&(pRefTinyInfo->checkState));
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
    {
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE)
      /*---------------------------------------------*/
      /*    Application specific condition check     */
      /*---------------------------------------------*/
      /* Call the pre handler */
      g_descPreHandlerTable[pRefTinyInfo->preHandlerRef](DESC_CONTEXT_PARAM_ONLY);
#endif
    }
#if defined (DESC_ENABLE_AUTO_STATES)
    else
    {
      /* Correct the negative response code dependent on the sub-function availability */
# if defined (DESC_ENABLE_PROTOCOL_KWP)
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcServiceNotSupportedInActiveMode)
# else
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcSubfunctionNotSupportedInActiveSession)
# endif
      {
        reason = pmAnalyseReasonSession;
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcParamIdNotSupportedInSession;
      }

      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] ==  kDescOemNrcParamIdNotSupportedInSecurityState)
      {
        reason = pmAnalyseReasonSecurityState;
      }
    }
#endif
  }
  else
  {
    /* EXAMPLE: Additional activities may be necessary */
    /*DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_ONLY);*/
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
  }
  return reason;
}

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || defined(DESC_ENABLE_PERIODIC_MODE)
/******************************************************************************
* NAME:              DescPmGetPidClientHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetPidClientHandle(DescPidInstIndex pidInfoHandle, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable)
{
  DescPidInstIndex result;
  DescPidInstIndex iter;

  result = kDescInvalidPidHandle;
  iter = topOfTable;
  while(iter != 0)
  {
    iter--;
    if(pClientInfoTbl[iter].pidHandle == pidInfoHandle)
    {
# if defined (DESC_ENABLE_MULTI_VARIANT)
      /*Check if it is allowed in the actual configuration*/
      if(DescPermittedInConfig(pClientInfoTbl[iter].tinyInfo.variantMask) != 0)
# endif
      {
        result = iter;
      }
      /* Break */
      iter = 0;
    }
  }
  return result;
}
#endif

/******************************************************************************
* NAME:              DescPmGetAvailablePidHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetAvailablePidHandle(vuint16 pid)
{
  DescPidInstIndex result;

  result = DescPmGetPidPoolHandle(pid);
  result = DescPmClientCheckPid(result, pid);

  return result;
}

#if defined(DESC_ENABLE_PERIODIC_MODE)
/******************************************************************************
* NAME:              DescPmGetSupportedPidClientHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:    Returns a reference of the DID in the client specific info table
*
*******************************************************************************/
static DescPidInstIndex DescPmGetSupportedPidClientHandle(vuint16 pid, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable)
{
  DescPidInstIndex result;
  result = DescPmGetAvailablePidHandle(pid);
  /* No check needed for invalidity since all the functions are protected by such checks */
  result = DescPmGetPidClientHandle(result, pClientInfoTbl, topOfTable);
  return result;
}
#endif

/******************************************************************************
* NAME:              DescPmGetPidPoolHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetPidPoolHandle(vuint16 pid)
{
  DescPidInstIndex  loIdx;
  DescPidInstIndex  hiIdx;
  DescPidInstIndex  idx;

  /* Init look-up */
  loIdx= 0;
  hiIdx= (DescPidInstIndex)(kDescNumPids - 1);

  do
  {
    /* Examine one concrete serviceInstanceHeader */
    /* ------------------------------------------ */
    idx = (DescPidInstIndex)(((vuint16)((vuint16)hiIdx + (vuint16)loIdx)) >> 1);

    /* Check for matching element */
    if(g_descPIDInfo[idx].reqPid == pid)
    {
#if defined (DESC_ENABLE_MULTI_CFG_SUPPORT)
      DescBool isSupported = ApplDescIsDataIdSupported(pid);
      if(isSupported == kDescFalse)
      {
        /* Nothing more to look for */
        break;
      }
      else
#endif
      {
#if defined (DESC_ENABLE_PID_SECURITY_FILTER)
        DescBool isAllowed = DescPmCheckPidSecurityAccess(&(g_descPIDInfo[idx].tinyInfo.checkState));
        if(isAllowed == kDescFalse)
        {
          /* Nothing more to look for */
          break;
        }
        else
#endif
        {
          /* Bingoooo :) */
#if defined (DESC_ENABLE_MULTI_VARIANT)
          /*Check if it is allowed in the actual configuration*/
          if(DescPermittedInConfig(g_descPIDInfo[idx].tinyInfo.variantMask) == 0)
          {
            return kDescInvalidPidHandle;
          }
          else
#endif
          {
            return idx;
          }
        }
      }
    }
    /* Determine which half shall be taken */
    if (pid < g_descPIDInfo[idx].reqPid)
    {
      /* Avoid use of signed types */
      if(idx == 0)
      {
        break;
      }
      hiIdx = (DescPidInstIndex)(idx - 1);
    }
    else
    {
      /* Message 'greater' than service instance: Use upper half of interval... */
      loIdx = (DescPidInstIndex)(idx + 1);
    }
  }
  while (loIdx <= hiIdx);
  /* return the search result */
  return kDescInvalidPidHandle;
}

/*******************************************************************************
* NAME:              DescRidAnalyseRoutine
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescRidAnalyseRoutine(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescRidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo, DescBool isOnRid)
{
  /*---------------------------------------------*/
  /*     Service ID addressing method check      */
  /*---------------------------------------------*/
  if ((pRefTinyInfo->msgAddInfo.reqType &
       g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
  {
#if defined (DESC_ENABLE_AUTO_STATES)
    /* Generated state checks */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = DescCheckState(&(pRefTinyInfo->checkState));
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
    {
#if defined (DESC_ENABLE_RID_PREHANDLER_USAGE)
      /*---------------------------------------------*/
      /*    Application specific condition check     */
      /*---------------------------------------------*/
      /* Call the pre handler */
      g_descPreHandlerTable[pRefTinyInfo->preHandlerRef](DESC_CONTEXT_PARAM_ONLY);
#endif
    }
    else
    {
      /* Correct the negative response code dependent on the sub-function availability */
      if((g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcSubfunctionNotSupportedInActiveSession) &&
         (isOnRid == kDescTrue))
      {
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
      }
    }
  }
  else
  {
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
  }
}

/*******************************************************************************
* NAME:              DescRidFindSubFunction
*
* CALLED BY:         DescRoutineControlByIdentifier
* PRECONDITIONS:     
*
* DESCRIPTION:       Check if sub-function supported
* 
*******************************************************************************/
static DescRidInstIndex DescRidFindSubFunction(vuint8 subFuncId, DescRidInstIndex ridRef)
{
  /* Assume failed */
  DescRidInstIndex result = kDescInvalidRidInstHandle;
  /* Valid sub-function at all (top limit)? ($1, $2 or $3 only)*/
  if(subFuncId < 4)
  {
    /* Is supported at all? */
    result = g_descRidSubFuncToCtrlTypeMap[subFuncId];

    if(result < kDescInvalidRidInstHandle)
    {
#if defined (DESC_ENABLE_RID_CTRL_OPER_CHECK)
      result = g_descRidControlTypeInfo[ridRef][result];
#else
# if (kDescNumRidControlTypes > 1)
      ridRef *= kDescNumRidControlTypes;
      ridRef += result;
# else
      /* Since 1:1 relation - the value is already assigned! */
# endif
      result = ridRef;
#endif
    }
  }
  return result;
}

/*******************************************************************************
* NAME:              DescRoutineControlByIdentifier
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Main handler for RID handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescRoutineControlByIdentifier(DescMsgContext* pMsgContext)
{
  DescRidInstIndex   ridInstRef;
  /* Use iContext when necessary */
  DESC_CONTEXT_PARAM_DEF_LOCAL
#if (kDescNumContexts > 1)
  /* Use iContext as name to be able to use the DESC_CONTEXT_PARAM_VALUE macro */
  DESC_CONTEXT_PARAM_VALUE = pMsgContext->iContext;
#endif

#if defined (DESC_ENABLE_RID_POSTHANDLER_USAGE)
  /* Set reference to invalid (skip application post-handler call) */
  g_descRidCurrInstRef = kDescInvalidRidInstHandle;
#endif
  /* Check minimum length (SubFunction and RID must be inside) */
  if(pMsgContext->reqDataLen > 2)
  {
    ridInstRef = DescRidFindRoutineId(DescMake16Bit(pMsgContext->reqData[1], pMsgContext->reqData[2]));

    /* Is the RID supported? */
    if(ridInstRef < kDescInvalidRidHandle)
    {
      /* analyze the RID specific information */
      DescRidAnalyseRoutine(DESC_CONTEXT_PARAM_FIRST &(g_descRIDInfo[ridInstRef]), kDescTrue);
      /* Dispatching successful?*/
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
      {
        /* Check if sub-function valid (at all and for RID) */
        ridInstRef = DescRidFindSubFunction(pMsgContext->reqData[0], ridInstRef);

#if defined (DESC_ENABLE_RID_POSTHANDLER_USAGE)
        /* Store the RID reference for later */
        g_descRidCurrInstRef = (DescMemRidInstIndex)ridInstRef;
#endif

        /* Does the RID support the control type? */
        if(ridInstRef < kDescInvalidRidInstHandle)
        {
          /* If dynamic request length OR valid one - process the service */
          if((g_descRIDInstInfo[ridInstRef].reqDataLen == 0) ||
             (pMsgContext->reqDataLen == g_descRIDInstInfo[ridInstRef].reqDataLen))
          {
            /* analyze the sub-function specific information */
            DescRidAnalyseRoutine(DESC_CONTEXT_PARAM_FIRST &(g_descRIDInstInfo[ridInstRef].tinyInfo), kDescFalse);

            /* Dispatching successful?*/
            if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
            {
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
              /* Redirect main-handler call */
              _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, g_descRIDInstInfo[ridInstRef].mainHandler);
#endif
              /* Skip the routine Id and sub-function */
              pMsgContext->reqData+=3;
              pMsgContext->resData+=3;
              pMsgContext->reqDataLen-=3;
              /* Set the context mode */
              g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeRoutineControl;
              /* Call the main-handler */
              g_descRIDInstInfo[ridInstRef].mainHandler(pMsgContext);
              /* Let the application to take care about the service */
              return;
            }
            /*else - NRC is already registered */
          }
          else
          {
            /* Invalid service length */
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
          }
        }
        else
        {
          /* the RID is available but the sub-function not */
          g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcSubfunctionNotSupported;
        }
      }
      /*else - NRC is already registered */
    }
    else
    {
      /* the RID is not available but the sub-function not */
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
    }
  }
  else
  {
    /* Too short service length */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
  }

  /* Error Case */
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescRidProcessingDone
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent processing done for a RID 
* iContext for the main response is also the same for the RID 
*******************************************************************************/
static void DescRidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Add the sub-function and RID length */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += 3;
  /* Go on with the response */
  DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
#if defined (DESC_ENABLE_RES_RINGBUFFER)
  /* Modify the write pointer for the ring buffer manager (+ sub-function and RID length) */
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex += 3;
  /* Those bytes are protocol data */
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen += 3;
#endif
}

#if defined (DESC_ENABLE_RID_POSTHANDLER_USAGE)
/*******************************************************************************
* NAME:              DescPostRoutineControlByIdentifier
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Post handler for RID handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescPostRoutineControlByIdentifier(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  if(g_descRidCurrInstRef < kDescInvalidRidInstHandle)
  {
    /* Call the post handler */
    g_descPostHandlerTable[g_descRIDInstInfo[g_descRidCurrInstRef].postHandlerRef](DESC_CONTEXT_PARAM_FIRST status);
  }
}
#endif

/*******************************************************************************
* NAME:              DescRidFindRoutineId
*
* CALLED BY:         Rid Processor
* PRECONDITIONS:     
*
* DESCRIPTION:       Linear look-up for RID (there are not so many RIDs expected).
* 
*******************************************************************************/
static DescRidLookUpIndex DescRidFindRoutineId(vuint16 rid)
{
  DescRidLookUpIndex  result = kDescInvalidRidHandle;
  DescRidLookUpIndex  iter   = kDescInvalidRidHandle;

  while(iter != 0)
  {
    iter--;
    if(g_descRidLookUpTable[iter] == rid)
    {
#if defined (DESC_ENABLE_MULTI_VARIANT)
      /*Check if it is allowed in the actual configuration*/
      if(DescPermittedInConfig(g_descRIDInfo[iter].variantMask) != 0)
#endif
      {
        result = iter;
      }
      iter = 0;
    }
  }
  return result;
}

/*******************************************************************************
* NAME:              DescRingBufferIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the ringbuffer subcomponent context specific data.
*
*******************************************************************************/
static void DescRingBufferIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Ring buffer init */
  /* The following members are initialized always before used:
  * g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;  - DescProcessRingBuffer/DescProcessingDone
  * g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex = 0; - DescProcessRingBuffer/DescProcessingDone
  * g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0; - DescProcessRingBuffer
  */
  DescRingBufferStateReset(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescRingBufferStateReset
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the states of the ringbuffer
*
*******************************************************************************/
static void DescRingBufferStateReset(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Ring buffer relevant states reset */
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive = 0;
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive = 0;
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated = 0;
}

/*******************************************************************************
* NAME:              DescRingBufferGetProgress
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the amount of currently written bytes.
*******************************************************************************/
DescMsgLen DESC_API_CALL_TYPE DescRingBufferGetProgress(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* The progress is exactly the amount of written bytes */
  return g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten;
}

/*******************************************************************************
* NAME:              DescRingBufferGetFreeSpace
*
* CALLED BY:         Application/CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the ring buffer free space
*******************************************************************************/
DescMsgLen DESC_API_CALL_TYPE DescRingBufferGetFreeSpace(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescMsgLen txReadIndex;
  DescMsgLen txWriteIndex;
  DescMsgLen returnValue;

  /* Code and runtime optimization */
  txReadIndex  = g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex;
  txWriteIndex = g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex;

  /* Check data free space availability */
  if(txReadIndex > txWriteIndex)
  {
    returnValue = (DescMsgLen)((txReadIndex - txWriteIndex) - 1);
  }
  else /* txReadIndex <= txWriteIndex */
  {
    returnValue = (DescMsgLen)((DescNetGetAvailBufferLenByIContext(DESC_CONTEXT_PARAM_VALUE) - 1) - (txWriteIndex - txReadIndex));
  }

  return returnValue;
}

/*******************************************************************************
* NAME:              DescRingBufferWrite
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Request writing data from the application into the ring buffer.
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE DescRingBufferWrite(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMsg dataSource, DescMsgLen dataLen)
{
  DescMsgLen txWriteIndex;
  DescMsgLen dataU16;
  vuint8 returnValue;

  /* Check call validity:
  * there shall be
  *  - long data active before calling this function
  *  - still data to be written
  */
  DescAssertCommon((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0), kDescAssertUnexpectedWriteIntoRingBuffer);

  /* Check for some place */
  if(DescRingBufferGetFreeSpace(DESC_CONTEXT_PARAM_ONLY) < dataLen)
  {
    returnValue = kDescFailed;
  }
  else
  {
    /* Code optimizer */
    txWriteIndex = g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex;

    /* Update total response data length */
    g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten += dataLen;

    /* Check if the response data length is exceeded */
    DescAssertCommon(((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen) >= (g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten + g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen)), kDescAssertRingBufferWriteExceedsTheResLen);
    /* Copy application data into the ring buffer */
    if((txWriteIndex + dataLen) >= DescNetGetAvailBufferLenByIContext(DESC_CONTEXT_PARAM_VALUE))
    {
      dataU16 = (DescMsgLen)(DescNetGetAvailBufferLenByIContext(DESC_CONTEXT_PARAM_VALUE) - txWriteIndex);
      DescMsgCopyFarRamToFarRam(&g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[txWriteIndex], dataSource, dataU16);
      /* Calculate the first part of the copy */
      dataLen -= dataU16;
      /* Update the source pointer */
      dataSource += dataU16;
      /* Start from the begining */
      txWriteIndex = 0;
    }

    /* Linear copy (for both second copy if wrap-around and in real linear case)
    * Note: The case where (txWriteIndex + dataLen) = kPrimBufferLen
    * this function call is just spended - no copy will be performed (dataLen = 0) */
    DescMsgCopyFarRamToFarRam(&g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[txWriteIndex], dataSource, dataLen);
    txWriteIndex += dataLen;

    /* POP the global value */
    g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex = txWriteIndex;
    /* See if the transmission may be started or the if the total length has been copied */
    DescRingBufferCheckStartEndCondition(DESC_CONTEXT_PARAM_ONLY);
    /* Acknowledge that the application data has been accepted */

    returnValue = kDescOk;
  }
  return returnValue;
}

#if defined (DESC_ENABLE_RING_BUFFER_GET_WRITE_PTR)
/*******************************************************************************
* NAME:              DescRingBufferGetCurrWritePointer
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       
*******************************************************************************/
static DescMsg DescRingBufferGetCurrWritePointer(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return &g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex];
}
#endif

#if defined (DESC_ENABLE_RING_BUFFER_WRITE_NO_DATA) || \
    defined (DESC_ENABLE_PID_LIST_MODE)
/*******************************************************************************
* NAME:              DescRingBufferIndexAddition
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       
*******************************************************************************/
static void DescRingBufferIndexAddition(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMsgLen* pIndex, DescMsgLen incValue)
{
  DESC_IGNORE_UNREF_PARAM(DESC_CONTEXT_PARAM_VALUE);/* Ignore since in most cases the context parameter is not used! */

  /* Wrap around? */
  *pIndex += incValue;
  if(*pIndex > DescNetGetAvailBufferLenByIContext(DESC_CONTEXT_PARAM_VALUE))
  {
    /* Calculate the correct offset */
    *pIndex -= DescNetGetAvailBufferLenByIContext(DESC_CONTEXT_PARAM_VALUE);
  }
}
#endif

#if defined (DESC_ENABLE_PID_LIST_MODE)
/*******************************************************************************
* NAME:              DescLinearResponseProcessing
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       
*******************************************************************************/
static void DescLinearResponseProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Linear writing only - check if there was enough place */
  DescAssertUser((g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen <= DescLinearBufferGetFreeSpace(DESC_CONTEXT_PARAM_ONLY)), kDescAssertPidResLenToCurrLinearFreeSpace);
  /* Set back to zero the protocol length */
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen = 0;
  /* Initilize the end condition for CopyToCan */
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
  /* Add offset for the linear data */
  g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData += g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
  /* Total written data (must be set because of the "buffer underrun" check in the DescCopyToCan) - add the data length to the PID length (2Byte) */
  DescRingBufferIndexAddition(DESC_CONTEXT_PARAM_FIRST &g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex, g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen);
}
#endif

#if defined (DESC_ENABLE_RING_BUFFER_WRITE_NO_DATA)
/*******************************************************************************
* NAME:              DescRingBufferWriteNoData
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       
*******************************************************************************/
static void DescRingBufferWriteNoData(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMsgLen dataLen)
{
  /* Simulate the write buffer function without data */
  DescRingBufferIndexAddition(DESC_CONTEXT_PARAM_FIRST &g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex, dataLen);
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten += dataLen;
  DescRingBufferCheckStartEndCondition(DESC_CONTEXT_PARAM_ONLY);
}
#endif

/*******************************************************************************
* NAME:              DescRingBufferCheckStartEndCondition
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       
*******************************************************************************/
static void DescRingBufferCheckStartEndCondition(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  vuint16 currWrittenDataLen;
  vuint16 totalResDataLen;

  /* Speed up the process (add the response header length (sid + sub-service id bytes)) */
  currWrittenDataLen = (vuint16)(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten +
                                 g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen);

  /* Cache the result */
#if defined (DESC_ENABLE_PID_LIST_MODE)
  /* If list mode service - process using its context */
  if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode == kDescContextModePidList)
  {
    /* use it for faster calculations */
    totalResDataLen = (vuint16)(g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen + g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen);
  }
  else
#endif
  {
    /* use it for faster calculations */
    totalResDataLen = g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
  }

  /* Compare the total response length to the currently written portion */
  if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive == 0)
  {
     vuint16 txMinLen = DescUsdtNetGetRingBuffTxMinLen(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
    /* Shall we start the transmission ? (either full length or FF length is achieved)*/
    if((currWrittenDataLen >= totalResDataLen) ||
       (currWrittenDataLen >= txMinLen))
    {
      /* Update ringbuffer manager state */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive = 1;
      /* Set ready for transmit */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTxReady;
    }
  }

  /* If all bytes written - don't call any more the application */
  if(currWrittenDataLen >= totalResDataLen)
  {
    /* Stop calling the application if set */
    _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
  }
}

/*******************************************************************************
* NAME:              DescRingBufferStart
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Initiates the ring buffer mechanism write process.
*******************************************************************************/
void DESC_API_CALL_TYPE DescRingBufferStart(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* If special functional request buffer - no long data for it is allowed */
#if (kDescNumFuncReqContexts > 0)
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE != kDescSecContext), kDescAssertFuncReqWoResMayNotUseRingBuffer);
#endif
#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
  /* Do not consider the bit information - send always positive response */
#else
  DescAssertCommon((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes == 0), kDescAssertIllegalUsageOfRingBufferOnSupprPosRes);

  /* By default reset the flag to allow positive responses */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = 0;
#endif

#if defined (DESC_ENABLE_PID_LIST_MODE)
  /* Check for reactivation */
  if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
  {
    g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated = 1;
  }
  else
#endif
  {
    /* Activate the ring buffer */
    g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive = 1;
  }

  /* At this time point must be already zeroed 
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive = 0;
  */
  /* Will be initialized during processing done 
  * g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex = ...
  */
  /* Will be initialized during processing done 
  * Start reading from the begining 
  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
  */

  /* Process the response */
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescLinearBufferGetFreeSpace
*
* CALLED BY:         Application/CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the linear buffer free space
*******************************************************************************/
DescMsgLen DESC_API_CALL_TYPE DescLinearBufferGetFreeSpace(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescMsgLen returnValue;
  /* Calculate the remaining buffer for the response data */
  /* Check if the free space is wrapped */
  if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex <  g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex)
  {
    /* In this case the buffer is closed between [write, read) indexes */
    returnValue = (DescMsgLen)(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex -
                        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex - 1);
  }
  else
  {
    /* In this case the buffer is closed between [write, bufferEnd) positions */
    returnValue =  (DescMsgLen)((DescNetGetAvailBufferLenByIContext(DESC_CONTEXT_PARAM_VALUE) - 1) -
                        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex);
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              DescUsdtNetAbsRingBufferCopyRoutine
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       transmission has finished
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsRingBufferCopyRoutine(t_descUsdtNetInfoPoolPtr infoPool, DescUsdtNetMsg pDestination, vuint8 dataLength)
{
  t_descUsdtNetResult returnValue;
  DescMsgLen dataU16;
  DESC_CONTEXT_PARAM_DEF_LOCAL

#if (kDescNumContexts > 1)
    /* Enabled only if UDS has more than one context */
    DESC_CONTEXT_PARAM_ONLY = infoPool->descHandle;
#endif
    /* Check data availability
    * Decrement by one since the DescRingBufferGetFreeSpace() delivers one byte less, which leads to 
    * wrong interpretation of the data availability.
  */
  dataU16 = (vuint16)((DescGetAvailBufferLenByInfoPool(infoPool) - 1) - DescRingBufferGetFreeSpace(DESC_CONTEXT_PARAM_ONLY));
  if(dataU16 < dataLength)
  {
#if defined (DESC_ENABLE_PID_LIST_MODE)
    /* Only for PID LIst mode */
    if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode == kDescContextModePidList)
    {
      /* Consider buffer indexes only if the PidProcessingDone is called */
      if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed != 0)
      {
        /* If all data has been written start next PID (in case the PID uses ring-buffer)*/
        if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten == g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen)
        {
          /* Move only if fragmented buffer */
          if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex != 0)
          {
            /* Check if wrap around necessary (check only ">" since in case "==" -> (wrInd == 0) so nothing to shift to right )*/
            if((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex + dataU16) > DescGetAvailBufferLenByInfoPool(infoPool))
            {
              /* VStdMemCpy* copy the data from the end to the begining -> no data will be overwritten */
              DescMsgCopyFarRamToFarRam(
                                        infoPool->reqDataPtr + g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex,
                                        infoPool->reqDataPtr,
                                        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex
                                        );
              dataU16 -= g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex;
            }

            /* Move the left portion to the begining of the buffer (ring buffer defragmentor :o)) */
            DescMsgCopyFarRamToFarRam(
                                      infoPool->reqDataPtr,
                                      &infoPool->reqDataPtr[g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex],
                                      dataU16
                                      );
            /* Start reading from the begining */
            g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
            /* Start writing from the new offset (left portion)  */
            /* No collision with DescRingBufferWrite is possible since, reaching this code excludes 
             * the call of DescRingBufferWrite (no active main-handler)!!! -> no inconsistency problem */
            g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex = dataU16;
          }

          /* Reset the written byte counter - this will avoid this code execution even if the next MainHandler is not so fast with the data suppliment. */
          g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0;
          /* Set back to zero the protocol length */
          g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen = 0;
          /* Prepare where to write the data if linear writing used (offset 2 will be added in the PIDTask after copy of PID )*/
          g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData = &infoPool->reqDataPtr[dataU16];
          /* Process next PID */
          g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid++;

          if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid <
             g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount)
          {
            g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed = 0;
            g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 1;
          }
          else
          {
            /* There are missing data but also there are no more PIDs where shall I get this missing bytes?? */
            DescAssertInternalAlways(kDescAssertMissingDataForTransmission);
          }
        }
      }
    }
#endif
    /* Not enough data */
    returnValue = kDescUsdtNetBufferUnderrun;
  }
  else
  { /* Take the linear case always */
    dataU16 = dataLength;

    /* Copy application data into the ring buffer */
    if((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex + dataLength) >= DescGetAvailBufferLenByInfoPool(infoPool))
    {
      dataU16 = (DescMsgLen)(DescGetAvailBufferLenByInfoPool(infoPool) - g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex);
      DescMsgCopyFarRamToFarRam(
                             pDestination,
                             &infoPool->reqDataPtr[g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex],
                             dataU16
                             );
      /* Update the source pointer */
      pDestination += dataU16;
      /* Calculate the second part of the copy */
      dataU16 = (DescMsgLen)(dataLength - dataU16);
      /* Start from the begining */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
    }

    /* Linear copy (for both second copy if wrap-around and in real linear case) 
    * Note: The case where (txReadIndex + dataLen) = kDescPrimBufferLen 
    * this function call is just spended - no copy will be performed (dataU16 = 0) */
    DescMsgCopyFarRamToFarRam(
                           pDestination,
                           &infoPool->reqDataPtr[g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex],
                           dataU16
                           );
    g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex += dataU16;
    returnValue = kDescUsdtNetworkOk;   /*Everythings ok now*/
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              DescRingBufferCancel
*
* CALLED BY:         Application/Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       Cancels the current ring-buffer progress
*******************************************************************************/
void DESC_API_CALL_TYPE DescRingBufferCancel(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Check call validity: 
   * there shall be 
   *  - long data active before calling this function
   */
  DescAssertCommon((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0), kDescAssertIllegalCallOfRingBufferCancel);

  /* Stop calling the application if set */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);

  /* If ring-buffer currently on transmission - reset communication channel */
  if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive != 0)
  {
    /* Let the TP to detect a buffer-underrun */
  }
  else
  {
    /* Since ring-buffer can be started only for positive responses, just undo the response Id */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr[0] -= kDescPosResIdOffset;
    g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive = 0;
    /* Restore awaitness of DescProcessingDone() */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcess;
    /* Mark "transfer suspended" */
#if defined(DESC_ENABLE_PROTOCOL_UDS)
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcTransferDataSuspended;
#else
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcTransferSuspended;
#endif
#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
    /* Skip the processing-done dispatcher */
    DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
#else
    DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
#endif
  }
}




