/* -----------------------------------------------------------------------------
  Filename:     frfm.h
  Description:  Toolversion: 01.00.35.01.21.00.21.01.00.00
                
                Serial Number: CBD1210021
                Customer Info: Nxtr
                               Package: CBD_Chrysler_SLP1_UDS_Sgl
                               Micro: TexasInstruments TMS570 - TMX570LS0805APGEQQ1
                               Compiler: Texas Instruments 4.9.5
                Manufacturer : Chrysler (Car)
                
                Configuration: C:\cmsynergy\My_CL\Chrysler_LWR_EPS_TMS570\Tools\AsrProject\GENy\EPS_PN_4102_EI1555.cdi
                
                
                Interface of DiagFrfm visible to any application.

  Generated by  DtcGen v3.20.1 (2012-08-17)  at:  2014-02-06 21:12:42 -05:00
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2004-2012 by Vctr Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vctr Informatik 
  GmbH.
  
  Vctr Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

#if !defined(__FRFM_H__)
#define __FRFM_H__

/* -----------------------------------------------------------------------------
    &&&~ History
 ----------------------------------------------------------------------------- */

/* 
------------------------------------------------------------------------------------------------------------------------
                                             A U T H O R   I D E N T I T Y                                              
------------------------------------------------------------------------------------------------------------------------
Initials   Name                  Company                                                                                
---------- --------------------- ---------------------------------------------------------------------------------------
Hrs        Stefan Huebner        Vctr Informatik GmbH                                                                 
------------------------------------------------------------------------------------------------------------------------
                                            R E V I S I O N   H I S T O R Y                                             
------------------------------------------------------------------------------------------------------------------------
Date       Version  Author Modification type Issue Id      Affects                     Description                       
---------- -------- ------ ----------------- ------------- --------------------------- ----------------------------------
2010-08-19 03.19.03
                    -      -                 -             -                           No relevant changes available in this version.
2011-08-04 03.19.04
                    -      -                 -             -                           No relevant changes available in this version.
2011-09-16 03.20.00
                    Hrs    Added             N/A           Chrysler/Car(UDS)           First version with support for Chrysler/UDS.
2012-08-17 03.20.01
                    Hrs    Fixed             ESCAN00057661 Chrysler/Car(UDS)           Compiler error: memory attributes not allowed on auto variables or parameters.
                    Hrs    Fixed             ESCAN00059591 Chrysler/Car(UDS)           Compiler error: "syntax error in parameter" in function frfm.c::FrfmVoltageMonitor().
------------------------------------------------------------------------------------------------------------------------
 */


/* -----------------------------------------------------------------------------
    &&&~ Configuration switches
 ----------------------------------------------------------------------------- */

/* TestFailed DTC status bit will be supported. */
#define FRFM_ENABLE_TESTFAILED_STATUS
/* TestFailedThisOperationCycle DTC status bit will be supported. */
#define FRFM_ENABLE_TFTOC_BIT_STATUS
/* PendingDTC status bit will be supported. */
#define FRFM_ENABLE_PENDINGDTC_STATUS
/* ConfirmedDTC status bit will be supported. */
#define FRFM_ENABLE_CONFIRMEDDTC_STATUS
/* TestNotCompletedSinceLastClear DTC status bit will be supported. */
#define FRFM_ENABLE_TNCSLC_BIT_STATUS
/* TestFailedSinceLastClear DTC status bit will be supported. */
#define FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS
/* TestNotCompletedThisOperationCycle DTC status bit will be supported. */
#define FRFM_ENABLE_TNCTOC_BIT_STATUS
/* WarningIndicatorRequested DTC status bit will be supported. */
#define FRFM_ENABLE_WARNINGINDICATOR_STATUS
/* TriggerOnStatusChange suppression (RoE/DM1) for individual DTCs will not be supported. */
#define FRFM_DISABLE_NO_STAT_CHG_TRIGGER
/* TriggerOnStatusChange suppression permanently stored in NVRAM will not be supported. */
#define FRFM_DISABLE_NVRAM_CHG_TRIGGER
/* Debug mode will not be supported. */
#define FRFM_DISABLE_DEBUG_MODE
/* Subsequent EnvData Update for TestFailed during unfulfilled EnableConditions on stored events will not be supported. */
#define FRFM_DISABLE_POST_UPDATE_ENV_DATA
/* KWP2000 will not be supported. */
#define FRFM_DISABLE_PROTOCOL_KWP
/* Chrysler specific features will be supported. */
#define FRFM_ENABLE_CHRYSLER_FEATURES
/* 4-byte pattern to check NVRAM will be supported. */
#define FRFM_ENABLE_PATTERN_CHECK
/* 2-byte checksum on NVRAM will be supported. */
#define FRFM_ENABLE_CONSISTENCY_CHECK
/* Runtime configuration of DTC attributes will not be supported. */
#define FRFM_DISABLE_DTC_RUNTIME_CONFIG
/* De-bouncing of DTCs will be supported. */
#define FRFM_ENABLE_DTC_DEBOUNCING
/* ResponseOnEvent Light will be supported. */
#define FRFM_ENABLE_ROE_LIGHT
/* ResponseOnEvent Light on MOST will not be supported. */
#define FRFM_DISABLE_ROE_LIGHT_MOST
/* De-/Activation of ResponseOnEvent Light messages via diagnostic request will be supported. */
#define FRFM_ENABLE_ROE_DIAGN_ACTIVATE
/* DM1 Light will not be supported. */
#define FRFM_DISABLE_DM1_LIGHT
/* Historical stack will not be supported. */
#define FRFM_DISABLE_HISTORICALSTACK
/* Application callback before executing service 'FrfmClearHistoricalData' will not be supported. */
#define FRFM_DISABLE_APPL_CLEAR_HISTDATA
/* NVRAM data corruption monitoring will not be supported. */
#define FRFM_DISABLE_MON_NVRAM_CORRUPT
/* Voltage monitoring will not be supported. */
#define FRFM_DISABLE_MON_VOLTAGE
/* System Under-Voltage monitoring will not be supported. */
#define FRFM_DISABLE_MON_SYS_UNDERVOLTG
/* System Over-Voltage monitoring will not be supported. */
#define FRFM_DISABLE_MON_SYS_OVERVOLTG
/* Local Under-Voltage monitoring will not be supported. */
#define FRFM_DISABLE_MON_LOC_UNDERVOLTG
/* Local Over-Voltage monitoring will not be supported. */
#define FRFM_DISABLE_MON_LOC_OVERVOLTG
/* Mutual exclusion matrix for DTCs will be supported. */
#define FRFM_ENABLE_DTC_MUTUALEXCLUSION
/* DTC readiness group value will not be supported. */
#define FRFM_DISABLE_READINESS_GROUPS
/* DTC priority value will be supported. */
#define FRFM_ENABLE_DTC_PRIORITY_SUPPORT
/* First Confirmed Env Data will not be supported. */
#define FRFM_DISABLE_FIRST_CONFIRMED_ENV_DATA
/* Most Recent Env Data will be supported. */
#define FRFM_ENABLE_MOST_RECENT_ENV_DATA
/* Application callback before executing Service 'ClearAllDtcs' will be supported. */
#define FRFM_ENABLE_APPL_CLEARDIAGINFO
/* Reset of 'testNotCompletedThisOperationCycle' to 1 at new ignition cycle will not be supported. */
#define FRFM_DISABLE_IGNCYC_RESETS_TEST
#ifndef FRFM_DISABLE_APPL_ENABLECOND
# define FRFM_ENABLE_APPL_ENABLECOND
#endif
#ifndef FRFM_DISABLE_CLEAR_DTC_NOTIFY
# define FRFM_ENABLE_CLEAR_DTC_NOTIFY
#endif


/* Diagnostic Service $19 0A will be supported. */
#define FRFM_ENABLE_REPORT_ALLSUPPORTED


/* -----------------------------------------------------------------------------
    &&&~ Preprocessor constants (defines)
 ----------------------------------------------------------------------------- */

/* ##V_CFG_MANAGEMENT ##CQProject : Diag_Faultmemory CQComponent : Implementation */
#define DIAG_FAULTMEMORY_VERSION                                       0x0320
#define DIAG_FAULTMEMORY_RELEASE_VERSION                               0x01
/* Backward compatible version defines: */
#define FRFM_MAIN_VERSION                                              0x0320
#define FRFM_RELEASE_VERSION                                           0x01
/* Total number of necessary bytes to store all status of DTCs. */
#define kFrfmByteSizeOfStatusBits                                      24
#define kFrfmInvalidDtc                                                 kFrfmNumDtc


/* This magic number provides inter Frfm generation process consistency check.All Frfm files must have the same one. */
#define FRFM_DECL_INTERFACE_MAGIC_NUMBER                               31611
/* Debug codes */
#define kFrfmAssertIllegalCStackSize                                    (vuint8)(0x01)
#define kFrfmAssertDtcNotFound                                          (vuint8)(0x02)
#define kFrfmAssertErasingEmptyCStack                                   (vuint8)(0x03)
#define kFrfmAssertInvalidOdometerValue                                 (vuint8)(0x04)
#define kFrfmAssertZeroNonVolatileDatPtr                                (vuint8)(0x05)
#define kFrfmAssertIllegalCStackReference                               (vuint8)(0x06)
#define kFrfmAssertWrongDtcStatus                                       (vuint8)(0x07)
#define kFrfmAssertMemAreasOverlap                                      (vuint8)(0x08)
#define kFrfmAssertIllegalSfn                                           (vuint8)(0x09)
#define kFrfmAssertIllegalMultiConfig                                   (vuint8)(0x0a)
#define kFrfmAssertIllegalSfnInMultiCfg                                 (vuint8)(0x0b)
#define kFrfmAssertIllegalHStackSize                                    (vuint8)(0x0c)
#define kFrfmAssertIllegalHStackIndex                                   (vuint8)(0x0d)
#define kFrfmAssertIllegalEnablCondGroup                                (vuint8)(0x0e)
#define kFrfmAssertConversionDataLoss                                   (vuint8)(0x0f)
#define kFrfmAssertZeroPointer                                          (vuint8)(0x10)
#define kFrfmAssertCompilerBugSizeof                                    (vuint8)(0x11)


#define kFrfmPatternSize                                                4


/* Call cycle time (in microseconds). */
#define kFrfmCallCycleUs                                               10000
/* Ignition Cycle De-Bounce Delay (in ms). */
#define kFrfmIgnitionCycleDelay                                        10000
/* Enable Condition: De-Bounce NetworkCommunication conditions (in ms). */
#define kFrfmDebounceNetworkComDelay                                   5000
/* Enable Condition: De-Bounce PowerDistribution conditions (in ms). */
#define kFrfmDebouncePowerDistrDelay                                   5000
/* The maximum valid System Voltage (in 0.1V) */
#define kFrfmSystemVoltageUpperLimit                                   160
/* The minimum valid System Voltage (in 0.1V) */
#define kFrfmSystemVoltageLowerLimit                                   100
/* The maximum valid Local Voltage (in 0.1V) */
#define kFrfmLocalVoltageUpperLimit                                    160
/* The minimum valid Local Voltage (in 0.1V) */
#define kFrfmLocalVoltageLowerLimit                                    100
/* The maximum valid odometer for clearing historical data (in km) */
#define kFrfmOdometerLimitClearHistRec                                 0
/* Total number of DTC found in the database. */
#define kFrfmNumDtc                                                    31
/* Multiple Configuration: Number of defined configuration sets. */
#define kFrfmNumConfigs                                                1
/* The chronological stack size. */
#define kFrfmChronoStackSize                                           10
/* Worst case of 1st kFrfmChronoStackSize DTC record sizes. */
#define kFrfmChronoStackAddEnvSize                                     170
/* All DTC numbered defines to access internal structures. */
#define FRFM_DTC_000000                                                0
#define FRFM_DTC_55C100                                                1
#define FRFM_DTC_55DB00                                                2
#define FRFM_DTC_612800                                                3
#define FRFM_DTC_612916                                                4
#define FRFM_DTC_612917                                                5
#define FRFM_DTC_612A84                                                6
#define FRFM_DTC_612A85                                                7
#define FRFM_DTC_620600                                                8
#define FRFM_DTC_621000                                                9
#define FRFM_DTC_621700                                                10
#define FRFM_DTC_621900                                                11
#define FRFM_DTC_C00200                                                12
#define FRFM_DTC_C10000                                                13
#define FRFM_DTC_C10100                                                14
#define FRFM_DTC_C12100                                                15
#define FRFM_DTC_C14000                                                16
#define FRFM_DTC_C15500                                                17
#define FRFM_DTC_C15900                                                18
#define FRFM_DTC_C21200                                                19
#define FRFM_DTC_C40100                                                20
#define FRFM_DTC_C40200                                                21
#define FRFM_DTC_C41500                                                22
#define FRFM_DTC_C42200                                                23
#define FRFM_DTC_C42300                                                24
#define FRFM_DTC_C45A00                                                25
#define FRFM_DTC_D21500                                                26
#define FRFM_DTC_D41500                                                27
#define FRFM_DTC_D44700                                                28
#define FRFM_DTC_D48D00                                                29
#define FRFM_DTC_D60100                                                30
/* All DTC names (error text) defines to access internal structures. */
/* 
Configuration EPS_PN_4102_EI1555 */
#define FRFM_DTC_FRFM_EVENT_INVALID_                                   0
#define FRFM_DTC_EPS_MECHANICAL_PERFORMANCE_                           1
#define FRFM_DTC_LATCH_ACTIVE_                                         2
#define FRFM_DTC_ECU_RESET_RECOVERY_OCCURRED_                          3
#define FRFM_DTC_BATTERY_VOLTAGE_CIRCUIT_VOLTAGE_BELOW_THRESHOLD       4
#define FRFM_DTC_BATTERY_VOLTAGE_CIRCUIT_VOLTAGE_ABOVE_THRESHOLD       5
#define FRFM_DTC_SYSTEM_VOLTAGE_SIGNAL_BELOW_ALLOWABLE_RANGE           6
#define FRFM_DTC_SYSTEM_VOLTAGE_SIGNAL_ABOVE_ALLOWABLE_RANGE           7
#define FRFM_DTC_VEHICLE_CONFIGURATION_MISMATCH_                       8
#define FRFM_DTC_ECU_OVERTEMPERATURE_                                  9
#define FRFM_DTC_ELECTIC_POWER_STEERING_MODULE_INTERNAL_               10
#define FRFM_DTC_ECU_UNABLE_TO_CONFIGURE_CONFIGURATION_NOT_LEARNED_    11
#define FRFM_DTC_CAN_C_BUS_OFF_PERFORMANCE_                            12
#define FRFM_DTC_LOST_COMMUNICATION_WITH_ECM_PCM_                      13
#define FRFM_DTC_LOST_COMMUNICATION_WITH_TCM_                          14
#define FRFM_DTC_LOST_COMMUNICATION_WITH_ANTI_LOCK_BRAKE_SYSTEM_ABS_CONTROL_MODULE_ 15
#define FRFM_DTC_LOST_COMMUNICATION_WITH_BODY_CONTROL_MODULE_          16
#define FRFM_DTC_LOST_COMMUNICATION_WITH_CLUSTER_CCN_                  17
#define FRFM_DTC_LOST_COMMUNICATION_WITH_PARKING_ASSIST_CONTROL_MODULE_ 18
#define FRFM_DTC_LOST_COMMUNICATION_WITH_SCM_                          19
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEIVED_FROM_ECM_PCM_               20
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEIVED_FROM_TCM_                   21
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEIVED_FROM_ABS_                   22
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEIVED_FROM_BODY_CONTROL_MODULE_   23
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEIVED_FROM_CLUSTER_CCN_           24
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEIVED_FROM_PARKING_ASSIST_MODULE_ 25
#define FRFM_DTC_LOST_COMMUNICATION_WITH_FORWARD_FACING_CAMERA_        26
#define FRFM_DTC_IMPLAUSIBLE_MISSING_VEHICLE_CONFIGURATION_DATA_       27
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEVIED_FROM_SCM_                   28
#define FRFM_DTC_IMPLAUSIBLE_DATA_RECEIVED_FROM_FORWARD_FACING_CAMERA_CCN_ 29
#define FRFM_DTC_ECU_APPLICATION_SOFTWARE_CODE_1_MISSING_OR_CORRUPTED_ 30

#define kFrfmFailed                                                     (vuint8)0x00
#define kFrfmSuccess                                                    (vuint8)0x01
#define kFrfmNvDataInit                                                 (vuint8)0x02

#define kFrfmTestFailedBit                                              0x01u
#define kFrfmTestFailedThisOperationCycleBit                            0x02u
#define kFrfmPendingDTCBit                                              0x04u
#define kFrfmConfirmedDTCBit                                            0x08u
#define kFrfmTestNotCompletedSinceLastClearBit                          0x10u
#define kFrfmTestFailedSinceLastClearBit                                0x20u
#define kFrfmTestNotCompletedThisOperationCycleBit                      0x40u
#define kFrfmWarningIndicatorRequestedBit                               0x80u




/* -----------------------------------------------------------------------------
    &&&~ Datatype definitions
 ----------------------------------------------------------------------------- */

typedef enum
{
  frfmRC_OK                 = 0,
  frfmRC_NoMoreData         = 1,
  frfmRC_Failed             = 2,
  frfmRC_WrongDTC           = 3,
  frfmRC_WrongRecordNumber  = 4
} t_FrfmReturnCode;

typedef vuint8 t_FrfmRecordNumber;
typedef vuint8 t_FrfmDTCStatusMask;


typedef enum
{
  frfmDO_ChronoStack              = 0
#if defined (FRFM_ENABLE_HISTORICALSTACK)
 ,frfmDO_HistoricalStack          = 1
#endif
#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
 ,frfmDO_FaultDetectionCounter    = 2
#endif
#if defined (FRFM_ENABLE_REPORT_ALLSUPPORTED)
 ,frfmDO_AllSupported             = 3
#endif
} t_FrfmDTCOrigin;


typedef vuint8 t_FrfmDtcMutualExclusionRef; /* datatype to index the count of elements of the mutual exclusion matrix */
typedef vuint8 t_FrfmMutualListLength; /* datatype to store max. length of each mutual exclusion sub-list */
typedef vuint32 t_FrfmDtcNumType; /* DTC number type is dependent on the GENtool settings. */
typedef vuint8 t_FrfmDtcSfnType; /* DTC number type is dependent on total DTC count(+1) found in the database. */
typedef vuint8 t_FrfmDtcChronoRefType; /* DTC number type is dependent on chronological stack size. */
typedef vuint8 t_FrfmAddEnvIndexType; /* DTC number type is dependent on pre-calculated maximum additional environmental data size. */
/* Handles of the all possible configurations (fault memory description) used as a parameter for FrfmInitPowerOn()!!! */
typedef enum
{
  FRFM_CFG_EPS_PN_4102_EI1555 =  0
} t_FrfmNumConfigs;
typedef enum
{
  ignitionRun                   = 0,
  ignitionAccessory             = 1,
  ignitionOff                   = 2,
  engineStart                   = 3,
  ignitionUnknown               = 4
} t_FrfmIgnitionState;

typedef enum
{
  /* unused                     = 0 */ 
  testFailed                    = 1
 ,testPassed                    = 2
  /* unused                     = 3 */
#if defined (FRFM_ENABLE_DTC_DEBOUNCING)
  /* unused                     = 4 */
 ,monitorPreFailed              = 5
 ,monitorPrePassed              = 6
#endif
} t_FrfmSetEventStatus;

typedef enum
{
  storageEnable                 = 0,
  storageDisable                = 1
} t_FrfmStorageState;

typedef enum
{
  frfmIODFuseStateOut           = 0,
  frfmIODFuseStateIn            = 1,
  frfmIODFuseStateUnknown       = 2
} t_FrfmIODFuseState;

typedef enum
{
  frfmFalse                     = 0,
  frfmTrue                      = 1
} t_FrfmBool;


typedef vuint16 t_FrfmOdometer;
typedef vuint16 t_FrfmVoltage;

typedef struct
{
#if defined ( C_CPUTYPE_BITORDER_MSB2LSB )
# if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
  vbittype bWarningIndicatorRequested:1;           /*0x80*/
# else
  vbittype unused7:1;
# endif
# if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS)
  vbittype bTestNotCompletedThisOperationCycle:1;  /*0x40*/
# else
  vbittype unused6:1;
#  define bTestNotCompletedThisOperationCycle unused6     /* only internally required */
# endif
# if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
  vbittype bTestFailedSinceLastClear:1;            /*0x20*/
# else
  vbittype unused5:1;
# endif
# if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
  vbittype bTestNotCompletedSinceLastClear:1;      /*0x10*/
# else
  vbittype unused4:1;
# endif
  vbittype bConfirmedDTC:1;                        /*0x08*/
# if defined (FRFM_ENABLE_PREFAILED_STATUS)
  vbittype bPreFailed:1;                           /*0x04*/
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
  vbittype bPendingDTC:1;                          /*0x04*/
# else
  vbittype unused2:1;
# endif
# if defined (FRFM_ENABLE_TFTOC_BIT_STATUS)
  vbittype bTestFailedThisOperationCycle:1;        /*0x02*/
# else
  vbittype unused1:1;
#  define bTestFailedThisOperationCycle unused1     /* only internally required */
# endif
  vbittype bTestFailed:1;                          /*0x01*/

#else

  vbittype bTestFailed:1;                          /*0x01*/
# if defined (FRFM_ENABLE_TFTOC_BIT_STATUS)
  vbittype bTestFailedThisOperationCycle:1;        /*0x02*/
# else
  vbittype unused1:1;
#  define bTestFailedThisOperationCycle unused1     /* only internally required */
# endif
# if defined (FRFM_ENABLE_PREFAILED_STATUS)
  vbittype bPreFailed:1;                           /*0x04*/
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
  vbittype bPendingDTC:1;                          /*0x04*/
# else
  vbittype unused2:1;
# endif
  vbittype bConfirmedDTC:1;                        /*0x08*/
# if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
  vbittype bTestNotCompletedSinceLastClear:1;      /*0x10*/
# else
  vbittype unused4:1;
# endif
# if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
  vbittype bTestFailedSinceLastClear:1;            /*0x20*/
# else
  vbittype unused5:1;
# endif
# if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS)
  vbittype bTestNotCompletedThisOperationCycle:1;  /*0x40*/
# else
  vbittype unused6:1;
#  define bTestNotCompletedThisOperationCycle unused6   /* only internally required */
# endif
# if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
  vbittype bWarningIndicatorRequested:1;           /*0x80*/
# else
  vbittype unused7:1;
# endif
#endif
} t_FrfmDtcStatusByte_s;

typedef t_FrfmDtcStatusByte_s t_FrfmGetEventStatus;

typedef union
{
  t_FrfmDtcStatusByte_s s;
  vuint8  c;
} t_FrfmDtcStatusByte;

/* Chrono Stack */
typedef struct
{
 t_FrfmDtcChronoRefType  ref;
 t_FrfmDtcSfnType        dtcInternalNumber;
} t_FrfmChronoStackManager;

typedef vuint16 t_checksum;

typedef struct
{
 /* t_FrfmDtcInternalLength  dtcInternalNumber; stored in ChronoStackManager */
 /* t_FrfmDtcStatusByte      dtcStatusByte;  stored in dtcStatusByte */
 /* vbittype                 occurenceFlag;  stored in ROM */
 vuint16                  originalOdometer;
 vuint16                  mostRecentOdometer;
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA)
 vuint16                  envDataIndex_firstConfirmed;
#endif
#if defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
 vuint16                  envDataIndex_mostRecent;
#endif
 vuint8                   frequencyCounter;
 vuint8                   ignitionCycleCounter;
} t_FrfmChronoStack;

/* tracking of last access to chrono stack */
typedef struct
{
  t_FrfmOdometer            odometer;             /* value at last chrono-stack read access*/
  vuint8                    readCount;            /* number of read accesses on chrono stack */
} t_FrfmInterrogationRecord;


/* Historical Stack */
#if defined (FRFM_ENABLE_HISTORICALSTACK)

typedef vuint8  t_FrfmHstackIndexType;      /* Type is dependent on number of historical entries (kFrfmHistoricalStackSize). */
typedef vuint8  t_FrfmHstackOptEnvDataLen;  /* Type is dependent on largest historical record size. */
typedef vuint16 t_FrfmHstackBufIndexType;   /* Type is dependent on historical buffer size (kFrfmHistoricalStackAddEnvSize). */

/* Historical Stack Element */
typedef struct
{
 t_FrfmDtcSfnType           dtcInternalNumber;
 t_FrfmDtcStatusByte        status;
 /* vbittype                occurenceFlag;        stored in ROM */
 vuint16                    originalOdometer;
# if defined (FRFM_ENABLE_HSTACK_ADD_ENV_DATA)
 t_FrfmHstackOptEnvDataLen  optEnvDataLength;
# endif
} t_FrfmHstackElement;

# if defined (FRFM_ENABLE_HSTACK_ADD_ENV_DATA)
/* Historical Stack Buffer for Optional Env. Data */
typedef struct
{
 t_FrfmHstackBufIndexType   firstFreeIdx;         /* first unused bytepos */
 vuint8                     buf[kFrfmHistoricalStackAddEnvSize];
} t_FrfmHstackOptEnvData;
# endif

#endif


/* Runtime configuration of SuppressDTC flag (diagnostic request and ChronoStack entry) */
#if defined (FRFM_ENABLE_DTC_RUNTIME_CONFIG)
typedef struct
{
  vuint8 frfmRtDtcSuppressFlag[((kFrfmNumDtc-1)/8)+1];
} t_FrfmRuntimeConfigurableData;
#endif /*FRFM_ENABLE_DTC_RUNTIME_CONFIG*/


/* Suppress DTC specific the RoE-lite resp. DM1 message */
#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
typedef struct {
  vuint8 frfmRtSuppressTrOnEvFlag[((kFrfmNumDtc-1)/8)+1];
} t_FrfmSuppressTriggerStatusChg;
#endif /*FRFM_ENABLE_NO_STAT_CHG_TRIGGER*/


/* Non volatile data */
typedef struct
{
  /* Non volatile Historical Stack and Historical Interrogation Record */
#if defined (FRFM_ENABLE_CONSISTENCY_CHECK)
  t_checksum                      historicalDataChecksum;
#endif
  t_FrfmInterrogationRecord       interrogationRecord;
#if defined (FRFM_ENABLE_HISTORICALSTACK)
  t_FrfmHstackIndexType           historicalStackCurrentSize;                   /* currently used element count */
  t_FrfmHstackElement             historicalStack[kFrfmHistoricalStackSize];
# if defined (FRFM_ENABLE_HSTACK_ADD_ENV_DATA)
  t_FrfmHstackOptEnvData          historicalStackOptEnvData;                    /* env data buffer and buffer usage counter */
# endif
#endif
#if defined (FRFM_ENABLE_PATTERN_CHECK)
  vuint8                          historicalConsistencyPattern[kFrfmPatternSize];
#endif
} t_FrfmNvHistoricalData;

typedef struct
{
  /* Non volatile Chronological Stack and configurable Data */
#if defined (FRFM_ENABLE_CONSISTENCY_CHECK)
  t_checksum                      chronoDataChecksum;
#endif
  t_FrfmDtcChronoRefType          chronoStackCurrentSize;
  t_FrfmAddEnvIndexType           chronoStackAddEnvCurrentIndex;
  t_FrfmChronoStack               chronoStack[kFrfmChronoStackSize];
  t_FrfmChronoStackManager        chronoStackManager[kFrfmChronoStackSize];
  vuint8                          dtcStatusBits[kFrfmByteSizeOfStatusBits];     /* compressed dtcStatusByte[] */
#if defined (FRFM_ENABLE_FIRST_CONFIRMED_ENV_DATA) || defined (FRFM_ENABLE_MOST_RECENT_ENV_DATA)
  vuint8                          chronoStackAddEnvData[kFrfmChronoStackAddEnvSize];
#endif
  /* calibration data */
  vbittype                        permanentFulfillIgnitionEC:1;                 /* Ignition Status (EC 2) is permanently fulfilled */
#if defined (FRFM_ENABLE_ROE_DIAGN_ACTIVATE)
  vbittype                        roelSendCalibration:1;                        /* send/suppress sending of all RoE-Light messages */
#endif
  t_FrfmNumConfigs                usedMultipleConfigurationIndex;
#if defined (FRFM_ENABLE_DTC_RUNTIME_CONFIG)
  t_FrfmRuntimeConfigurableData   runtimeConfigurableData;                      /* suppress DTCs for diagnostic requests and don't store in ChronoStack */
#endif
#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER) && defined (FRFM_ENABLE_NVRAM_CHG_TRIGGER)
  t_FrfmSuppressTriggerStatusChg  suppressTrOnEvFlag;                           /* suppress DTC specific the RoE/DM1 message */
#endif
#if defined (FRFM_ENABLE_DB_TRUCK_FEATURES)
  vuint8                          selfHealingLevel2Cycles;                      /* configurable cycle count for 'self_healing_level_2' */
  vuint8                          selfHealingLevel3Cycles;                      /* configurable cycle count for 'self_healing_level_3' */
                                                                                /* no array used for cycles, to avoid padding here */
#endif
#if defined (FRFM_ENABLE_PATTERN_CHECK)
  vuint8                          chronoConsistencyPattern[kFrfmPatternSize];
#endif
} t_FrfmNvChronologicalData;

#if defined (FRFM_NVDATA_SIZE_ADJUST)
# if ! defined (FRFM_ENABLE_DEBUG_MODE)
#  error "Warning: Please activate in GENy 'Support Debug Mode' - some compilers fail with sizeof() calculations - you need runtime assertion check."
# endif
/* Via defining FRFM_NVDATA_SIZE_ADJUST you can define a hard coded size for the structure t_FrfmNonVolatileData
* (variable: g_frfmNVData). If the actual required size for Chrono- and Historical Stack would be smaller than the
*  ADJUST value, the struct will be enlarged to that size. If the actual size would be larger than the ADJUST value,
*  then (typically) you get a compiler error about array element with negative size. In that case either remove the
*  ADJUST definition or increment it to/above the new minimum value.
*  By using this mechanism you will always waste at least 1 byte for the unused[] array plus zero or more bytes
*  introduced from the compiler for correct alignment of that array. If your compiler would permit zero-length
*  arrays (unused[0];) don't use that feature! It may remove the alignment padding too, and result in wrong size!
*
*  Define FRFM_NVDATA_SIZE_ADJUST e.g. in file "can_inc.h".
*
* The use of this feature is neither recommended nor supported by Vctr Informatik GmbH.
*/
/* To calculate the (compiler specific) padding values between the elements, we define a dummy structure here: */
typedef struct
{
# if defined (FRFM_ENABLE_HISTORICALSTACK)
  t_FrfmNvHistoricalData      hist_dummy;
# endif
  t_FrfmNvChronologicalData   chron_dummy;
  vuint8                      unused_dummy[5];
} t_FrfmNonVolatileData_dummy;
#endif

typedef struct
{
#if defined (FRFM_ENABLE_HISTORICALSTACK)
  t_FrfmNvHistoricalData      hist;   /* historical nv data    */
#endif
  t_FrfmNvChronologicalData   chron;  /* chronological nv data */
#if defined (FRFM_NVDATA_SIZE_ADJUST)
  vuint8                      unused[FRFM_NVDATA_SIZE_ADJUST - (sizeof(t_FrfmNonVolatileData_dummy) - 5)];
  /**** When you get a compiler error/warning in previous line, the defined FRFM_NVDATA_SIZE_ADJUST value is too small !! ****/
#endif
} t_FrfmNonVolatileData;




/* -----------------------------------------------------------------------------
    &&&~ Function prototypes
 ----------------------------------------------------------------------------- */

void                  FrfmMemMove(vuint8* tgtAddr, const vuint8* srcAddr, vuint16 blockLen);
void                  FrfmMemClear(void* tgtAddr, vuint16 blockLen);

t_FrfmDtcSfnType      FrfmGetDtcSFN(const t_FrfmDtcNumType dtcNum);
t_FrfmDtcNumType      FrfmGetDtcNum(const t_FrfmDtcSfnType dtcSfn);


t_FrfmDTCStatusMask   FrfmGetDTCStatusAvailab_Mask(void);
t_FrfmReturnCode      FrfmGetNextFilteredDTC(t_FrfmDtcNumType *reqDtcCode, vuint8 *value);
void                  FrfmNvInitChronoStack(void);
t_FrfmReturnCode      FrfmClearDTC(t_FrfmDtcNumType reqDtcCode, t_FrfmDTCOrigin dtcOrigin);
vuint16               FrfmGetSizeOfExtendedDataRecord(t_FrfmDtcNumType reqDtcCode, t_FrfmDTCOrigin dtcOrigin, t_FrfmRecordNumber recordNumber);
t_FrfmReturnCode      FrfmLockExtendedDataRecordByDTC(t_FrfmDtcNumType reqDtcCode, t_FrfmDTCOrigin dtcOrigin, t_FrfmRecordNumber recordNumber, vuint16* responseDataLength);
t_FrfmReturnCode      FrfmGetExtendedDataRecordByDTC(vuint8 **sourceBuffer, vuint16 *bufferSize);
t_FrfmBool            FrfmUnlockExtDataRecordByDTC(void);
vuint8                FrfmGetDtcFormat(void);
t_FrfmBool            FrfmIsSupportedDTC(t_FrfmDtcNumType reqDtcCode);


vuint16               FrfmSetDTCFilter(t_FrfmDTCStatusMask reqDtcStatusMask, t_FrfmDTCOrigin dtcOrigin);


#if (kFrfmNumConfigs > 1)
void                  FrfmInitPowerOn(t_FrfmNumConfigs selectedConfig);
#else
void                  FrfmInitPowerOn(void);
#endif
void                  FrfmTask(void);
vuint8                FrfmPowerUp(void);
void                  FrfmPowerDown(void);
t_FrfmBool            FrfmSyncNvramMirror(void);
t_FrfmBool            FrfmIsNvramMirrorSynchronized(void);


#if defined (FRFM_ENABLE_ROE_LIGHT_MOST)
#else
void                  FrfmRoelConfirmation(void);
#endif
#if defined (FRFM_ENABLE_ROE_DIAGN_ACTIVATE)
void                  FrfmRoelSetActiveState(t_FrfmBool activateRoelMessages);
t_FrfmBool            FrfmRoelGetActiveState(void);
#endif


vsint8                FrfmGetFaultDetectionCounter(t_FrfmDtcSfnType dtcSfn);
void                  FrfmDebounceEventFailed(t_FrfmDtcSfnType dtcSfn, vuint8 stepSize);
void                  FrfmDebounceEventPassed(t_FrfmDtcSfnType dtcSfn, vuint8 stepSize);


void                  FrfmSetEventStatus(t_FrfmDtcSfnType dtcSfn, t_FrfmSetEventStatus eventStatus);
t_FrfmGetEventStatus  FrfmGetEventStatus(t_FrfmDtcSfnType dtcSfn);
#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
t_FrfmBool            FrfmSuppressTriggerOnStatusChg(const t_FrfmDtcSfnType dtcSfn, const vuint8 newSuppressFlag);
#endif
t_FrfmBool            FrfmServiceSetDtcSuppressFlag(const t_FrfmDtcNumType reqDtc, const vuint8 newSuppressFlag);
t_FrfmBool            FrfmServiceSetStorageState(t_FrfmStorageState storageState);
void                  FrfmSetIgnitionStatus(t_FrfmIgnitionState ignitionState);
void                  FrfmSetLocalIgnitionStatus(t_FrfmIgnitionState ignitionState);
void                  FrfmSetBusReceivedIgnitionStatus(t_FrfmIgnitionState ignitionState);
t_FrfmBool            FrfmPermanentFulfullIgnitionEC(t_FrfmBool permanent);
void                  FrfmSetLocalVoltage(t_FrfmVoltage localMeasuredVoltage);
void                  FrfmSetSystemVoltage(t_FrfmVoltage busReceivedVoltage);
void                  FrfmSetIodFuseState(t_FrfmIODFuseState newState);
void                  FrfmSetIodFuseEnableCond(t_FrfmBool newState);
void                  FrfmSetNwConfigEnableCond(t_FrfmBool newState);
void                  FrfmSetBusPhysicEnableCond(t_FrfmBool newState);
void                  FrfmSetIODevConfEnableCond(t_FrfmBool newState);

t_FrfmBool            FrfmGetEnableConditions(t_FrfmDtcSfnType dtcSfn);
vuint8                FrfmMapStatusByteIntToExt(t_FrfmDtcStatusByte internalStatus);

#if defined( FRFM_ENABLE_READINESS_GROUPS )
void                  FrfmTestedThisOperationCycle(vuint8 readinessGroup);
#endif




/* -----------------------------------------------------------------------------
    &&&~ Global variable declarations
 ----------------------------------------------------------------------------- */

/* Buffer for NVRAM data (RAM mirror) */
extern t_FrfmNonVolatileData g_frfmNVData;



/* -----------------------------------------------------------------------------
    &&&~ ROM definitions
 ----------------------------------------------------------------------------- */


V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kFrfmMainVersion;
V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kFrfmSubVersion;
V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kFrfmReleaseVersion;



/* -----------------------------------------------------------------------------
    &&&~ Macro definitions
 ----------------------------------------------------------------------------- */

/* (value) asseble/deassemble macros */
/* compose from byte stream a 16 bit (value) */
#define FrfmMake16Bit(hiByte,loByte)                                    ((vuint16)(((vuint16)(hiByte)<<8)| \
                                                                        ((vuint16)(loByte))))
/* compose from byte stream a 32 bit (value) */
#define FrfmMake32Bit(hiHiByte,hiLoByte,loHiByte,loLoByte)              ((vuint32)(((vuint32)(hiHiByte)<<24)| \
                                                                        ((vuint32)(hiLoByte)<<16)| \
                                                                        ((vuint32)(loHiByte)<<8) | \
                                                                        ((vuint32)(loLoByte))))
/* decompose 16 bit (value) in byte stream */
#define FrfmGetHiByte(value)                                            ((vuint8)((vuint16)(value)>>8))
#define FrfmGetLoByte(value)                                            ((vuint8)((value)))

/* decompose 32 bit (value) in byte stream */
#define FrfmGetHiHiByte(value)                                          ((vuint8)((vuint32)(value)>>24))
#define FrfmGetHiLoByte(value)                                          ((vuint8)((vuint32)(value)>>16))
#define FrfmGetLoHiByte(value)                                          ((vuint8)((vuint32)(value)>>8))
#define FrfmGetLoLoByte(value)                                          ((vuint8)(value))


/* Suppress RoE-lite for individual DTCs. */
#if defined (FRFM_ENABLE_NO_STAT_CHG_TRIGGER)
# define FrfmServiceSetRoESuppressFlag(sfn,flag)                        FrfmSuppressTriggerOnStatusChg((sfn), (flag))
#endif


#define FrfmSetEventStatusDtc(externalDtcNumber, eventStatus)           FrfmSetEventStatus(FrfmGetDtcSFN(externalDtcNumber),(eventStatus))
#define FrfmGetEventStatusDtc(externalDtcNumber)                        FrfmGetEventStatus(FrfmGetDtcSFN(externalDtcNumber))


#define FrfmIsTestFailedBitSet(statusByte)                              ((statusByte).bTestFailed == 1)
#define FrfmIsTestFailedBitNotSet(statusByte)                           (!FrfmIsTestFailedSet(statusByte))

#if defined (FRFM_ENABLE_TFTOC_BIT_STATUS)
#define FrfmIsTestFailedThisOperationCycleBitSet(statusByte)            ((statusByte).bTestFailedThisOperationCycle == 1)
#define FrfmIsTestFailedThisOperationCycleBitNotSet(statusByte)         (!FrfmIsTestFailedThisOperationCycleBitSet(statusByte))
#endif

#if defined (FRFM_ENABLE_PREFAILED_STATUS)
# define FrfmIsPreFailedBitSet(statusByte)                              ((statusByte).bPreFailed == 1)
# define FrfmIsPreFailedBitNotSet(statusByte)                           (!FrfmIspreFailedBitSet(statusByte))
#elif defined (FRFM_ENABLE_PENDINGDTC_STATUS)
# define FrfmIsPendingDTCBitSet(statusByte)                             ((statusByte).bPendingDTC == 1)
# define FrfmIsPendingDTCBitNotSet(statusByte)                          (!FrfmIsPendingDTCBitSet(statusByte))
#endif

#define FrfmIsConfirmedDTCBitSet(statusByte)                            ((statusByte).bConfirmedDTC == 1)
#define FrfmIsConfirmedDTCBitNotSet(statusByte)                         (!FrfmIsConfirmedDTCBitSet(statusByte))

#if defined (FRFM_ENABLE_TNCSLC_BIT_STATUS)
#define FrfmIsTestNotCompletedSinceLastClearBitSet(statusByte)          ((statusByte).bTestNotCompletedSinceLastClear == 1)
#define FrfmIsTestNotCompletedSinceLastClearBitNotSet(statusByte)       (!FrfmIsTestNotCompletedSinceLastClearBitSet(statusByte))
#endif

#if defined (FRFM_ENABLE_TESTFAILEDSINCEL_CLEAR_STATUS)
# define FrfmIsTestFailedSinceLastClearBitSet(statusByte)               ((statusByte).bTestFailedSinceLastClear == 1)
# define FrfmIsTestFailedSinceLastClearBitNotSet(statusByte)            (!FrfmIsTestFailedSinceLastClearBitSet(statusByte))
#endif

#if defined (FRFM_ENABLE_TNCTOC_BIT_STATUS)
#define FrfmIsTestNotCompletedThisOperationCycleBitSet(statusByte)      ((statusByte).bTestNotCompletedThisOperationCycle == 1)
#define FrfmIsTestNotCompletedThisOperationCycleBitNotSet(statusByte)   (!FrfmIsTestNotCompletedThisOperationCycleBitSet(statusByte))
#endif

#if defined (FRFM_ENABLE_WARNINGINDICATOR_STATUS)
# define FrfmIsWarningIndicatorRequestedBitSet(statusByte)              ((statusByte).bWarningIndicatorRequested == 1)
# define FrfmIsWarningIndicatorRequestedBitNotSet(statusByte)           (!FrfmIsWarningIndicatorRequestedBitSet(statusByte))
#endif


/* Macros to access bits stored in a vuint8[] array */
#define FrfmSetBitInArray(i,arr)                                        ((arr)[(i)>>3] |=  (vuint8)   (1u << ((i)&7) ))
#define FrfmClearBitInArray(i,arr)                                      ((arr)[(i)>>3] &=  (vuint8) (~(1u << ((i)&7) )))
#define FrfmGetBitInArray(i,arr)                                        ((arr)[(i)>>3] & ( (vuint8)   (1u << ((i)&7) )) )
#define FrfmIsBitSetInArray(i,arr)                                      (FrfmGetBitInArray((i),(arr)) != ((vuint8)0u))
#define FrfmIsBitClearedInArray(i,arr)                                  (FrfmGetBitInArray((i),(arr)) == ((vuint8)0u))


/* Obsolete. Use function FrfmNvInitChronoStack(); instead.
#define FrfmNvDataInit()                                                (void)FrfmClearDTC(0xffffffu, frfmDO_ChronoStack)
*/




#endif /* __FRFM_H__ */
